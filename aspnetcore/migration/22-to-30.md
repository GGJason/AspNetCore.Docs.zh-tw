---
title: 從 ASP.NET Core，移轉到 3.0 2.2 預覽
author: tdykstra
description: 了解如何將 ASP.NET Core 2.2 專案移轉至 ASP.NET Core 3.0。
ms.author: tdykstra
ms.custom: mvc
ms.date: 06/17/2019
uid: migration/22-to-30
ms.openlocfilehash: 7f78daeae1147adaa4711b60da71aa83ad939e63
ms.sourcegitcommit: d6e51c60439f03a8992bda70cc982ddb15d3f100
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/03/2019
ms.locfileid: "67555906"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>從 ASP.NET Core 2.2 到 3.0 移轉

藉由[Scott Addie](https://github.com/scottaddie)和[Rick Anderson](https://twitter.com/RickAndMSFT)

這篇文章說明如何更新現有的 ASP.NET Core 2.2 專案，以 ASP.NET Core 3.0。

## <a name="prerequisites"></a>必要條件

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>更新專案檔

* 設定[目標 Framework Moniker (TFM)](/dotnet/standard/frameworks#referring-to-frameworks)到`netcoreapp3.0`:

  ```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
  ```

* 移除任何`<PackageReference>`要[Microsoft.AspNetCore.All](xref:fundamentals/metapackage)或是[Microsoft.AspNetCore.App](xref:fundamentals/metapackage-app)中繼套件。

* 更新`Version`屬性上剩餘`<PackageReference>`項目`Microsoft.AspNetCore.*`目前的預覽版本的封裝 (比方說， `3.0.0-preview5-19227-01`)。

  如果沒有任何的 3.0 版的封裝，封裝可能已被取代 3.0。 許多這些套件屬於`Microsoft.AspNetCore.App`，而且不應該單獨參考。 不會再產生 3.0 中的封裝的初步清單，請參閱[同時停止生產套件共用的 framework 3.0 中的組件 (aspnet/AspNetCore #3756)](https://github.com/aspnet/AspNetCore/issues/3756)。 *共用的架構*是組件集 ( *.dll*檔案)，它們是電腦上安裝，並且參考`Microsoft.AspNetCore.App`。 如需詳細資訊，請參閱[共用的架構](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) \(英文\)。

* 值得注意的幾個元件的組件已移除從`Microsoft.AspNetCore.App`3.0。 新增`<PackageReference>`如果您使用 Api 從封裝中所列的項目[Microsoft.AspNetCore.App 3.0 所移除的組件 (aspnet/AspNetCore #3755)](https://github.com/aspnet/AspNetCore/issues/3755)。

  移除元件的範例包括：

  * `Microsoft.AspNet.WebApi.Client`
  * `Microsoft.EntityFrameworkCore`
  * `System.Data.SqlClient`

  出貨的組件清單`Microsoft.AspNetCore.App`尚未完成，而且之前 3.0 RTM 將會變更。

  請考慮下列程式碼：

  ```csharp
  var branches = await response.Content.ReadAsAsync<IEnumerable<GitHubBranch>>();
  ```

  `ReadAsAsync`上述的程式碼中呼叫的方法納入`Microsoft.AspNet.WebApi.Client`。 安裝[Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 套件以解決在 3.0 中的編譯問題。

* 新增[Json.NET 支援](#jsonnet-support)。

* 專案預設值為[同處理序主控模型](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model)在 ASP.NET Core 3.0 或更新版本。 您可以選擇性移除`<AspNetCoreHostingModel>`屬性中的專案檔，如果其值為`InProcess`。

## <a name="jsonnet-support"></a>Json.NET 支援

工作的一部分[改善 ASP.NET Core 的共用的架構](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)， [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm)已從 ASP.NET Core 的共用架構。

若要使用 Json.NET 在 ASP.NET Core 3.0 專案：

* 新增的套件參考[Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)。
* 更新`Startup.ConfigureServices`呼叫`AddNewtonsoftJson`。

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  Json.NET 設定可在呼叫`AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC 服務登錄

ASP.NET Core 3.0 新增新的選項，以註冊內的 MVC 案例`Startup.ConfigureServices`。

三個新的最上層的擴充方法與在 MVC 案例`IServiceCollection`可用。 範本會使用這些新的方法，而不是`UseMvc`。 不過，`AddMvc`會繼續如之前的版本中運作。

下列範例會將控制站和 API 相關的功能，但無法檢視或網頁的支援。 [API] 範本會使用此程式碼：

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

下列範例會將控制站、 API 相關的功能，並檢視中，但不是頁面的支援。 Web 應用程式 (MVC) 範本會使用此程式碼：

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

下列範例會將支援 Razor 頁面與最小的控制器支援。 Web 應用程式範本會使用此程式碼：

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

也可以結合新的方法。 下列範例相當於呼叫`AddMvc`ASP.NET Core 2.2 中： 

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    services.AddRazorPages();
}
```

## <a name="update-routing-startup-code"></a>更新路由的啟始程式碼

如果應用程式呼叫`UseMvc`或是`UseSignalR`，移轉應用程式[端點路由](xref:fundamentals/routing)的話。 若要改善端點路由與舊版 MVC 的相容性，我們已在 ASP.NET Core 2.2 中導入的 URL 產生的一些變更還原。 如果您遇到使用 2.2 中的 端點路由的問題時，預期在 ASP.NET Core 3.0 改進，但有下列例外狀況：

* 如果應用程式實作`IRouter`或繼承自`Route`，您可能想要避免這一次移轉。 提供在提供意見反應[計劃移轉到端點路由 IRouter 基礎實作](https://github.com/aspnet/AspNetCore/issues/4221)。

* 如果應用程式直接存取`RouteData.Routers`在 MVC 中，您可能想要避免這一次移轉。 提供在提供意見反應[移轉指導方針使用 RouteData.Routers](https://github.com/aspnet/AspNetCore/issues/9148)。

端點路由支援相同的路由模式語法和撰寫功能的路由模式`IRouter`。 端點路由支援`IRouteContraint`。 端點的路由支援`[Route]`， `[HttpGet]`，和其他 MVC 路由屬性。

大部分的應用程式只`Startup`需要做的變更。

### <a name="migrate-startupconfigure"></a>移轉 Startup.Configure

建議這麼做：

* 新增`UseRouting`。 
* 如果應用程式呼叫`UseStaticFiles`，將`UseStaticFiles`**之前** `UseRouting`。
* 如果應用程式使用驗證/授權功能 (例如 `AuthorizePage` 或 `[Authorize]`)，請將對 `UseRouting` 的呼叫放在 `UseAuthentication` 與 `UseAuthorization` 之**後**。
* 如果應用程式中使用[CORS](xref:security/cors)功能，例如`[EnableCors]`，將`UseCors`下一步。
* 取代`UseMvc`或是`UseSignalR`使用`UseEndpoints`。

以下是範例`Startup.Configure`典型的 ASP.NET Core 2.2 應用程式中：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

在上一個更新之後`Startup.Configure`程式碼：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();
    
    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();
    app.UseCors();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="security-middleware-guidance"></a>安全性中介軟體的指導方針

授權和 CORS 支援統一周圍[中介軟體](xref:fundamentals/middleware/index)方法。 這是在這些情況下允許使用相同的中介軟體和功能。 在此版本中，提供更新的授權中介軟體和 CORS 中介軟體已增強，使它可以了解 MVC 控制站所使用的屬性。

#### <a name="cors"></a>CORS

先前，可能難以設定 CORS。 中介軟體提供使用，在某些使用案例，但 MVC 篩選條件適用於**而不需要**在其他中的介軟體的使用案例。 ASP.NET Core 3.0 中，我們建議所有的應用程式需要 CORS，在搭配端點的路由中使用 CORS 中介軟體。 `UseCors` 隨附預設原則，並`[EnableCors]`和`[DisableCors]`屬性可用來覆寫預設原則，視需要。 

在以下範例中：

* 所有的端點，以啟用 CORS`default`命名原則。
* `MyController`類別會停用的 CORS`[DisableCors]`屬性。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default"); 

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

在舊版的 ASP.NET Core 中，透過提供授權支援`[Authorize]`屬性。 授權中介軟體無法使用。 在 ASP.NET Core 3.0 中，授權中介軟體則是必要項目。 建議您放在 ASP.NET Core 授權中介軟體 (`UseAuthorization`) 之後立即`UseAuthentication`。 授權中介軟體也可以設定預設原則，可以覆寫。

在 ASP.NET Core 3.0 或更新版本中，`UseAuthorization`中稱為`Startup.Configure`，以及下列`HomeController`中使用者需要帶正負號：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

如果應用程式中使用`AuthorizeFilter`MVC 中的全域篩選器，建議您重構程式碼，以提供一項原則`UseAuthorization`中介軟體。

在下列範例中，要套用至所有的自訂原則會要求時`UseAuthorization`呼叫，而`HomeController`允許存取，而不需要讓使用者登入應用程式：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization(new AuthorizationPolicyBuilder().Build()));

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

由中介軟體的授權就不會有任何特定的知識，授權的 framework。 比方說，[健康狀態檢查](xref:host-and-deploy/health-checks)一無所知特定的授權，但健康情況檢查可以有一個中介軟體所套用的可設定的授權原則。

在下列範例中，`UseAuthorization`處理授權，沒有預設原則，但`/healthz`健康狀態檢查端點會要求使用者在`admin`角色： 

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

保護被實作在某些情況下。 `UseEndpoint` 如果因為遺漏的中介軟體而略過授權或 CORS 原則是中介軟體，則會擲回例外狀況。 分析器支援服務，以提供其他意見反應的相關設定錯誤正在進行中。

### <a name="migrate-signalr"></a>移轉 SignalR

現在的 SignalR 中樞對應發生內`UseEndpoints`。 

對應與每個中樞`MapHub`。 如同舊版中，明確列出每個中樞。

在下列範例中，支援`ChatHub`SignalR 中樞新增：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

### <a name="migrate-mvc-controllers"></a>移轉 MVC 控制器

現在對應的控制站發生內`UseEndpoints`。 

新增`MapControllers`如果應用程式中使用屬性路由。 由於路由包含支援許多架構在 ASP.NET Core 3.0 或更新版本，新增屬性路由的控制器是選用功能。 

取代下列項目：

* `MapRoute` 使用 `MapControllerRoute`
* `MapAreaRoute` 使用 `MapAreaControllerRoute`

由於路由現在包含不只是 MVC 支援，所以術語已變更為讓這些方法應該清楚地陳述它們的功用。 慣例路由，例如`MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute`就會新增的順序套用。 先放置更明確的路由 （例如區域的路由）。

在以下範例中：

* `MapControllers` 新增支援屬性路由的控制器。
* `MapAreaControllerRoute` 新增控制器慣例路由的區域。
* `MapControllerRoute` 新增控制器慣例路由。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin", 
            "admin", 
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="migrate-razor-pages"></a>Razor 頁面移轉

現在對應的 Razor 頁面發生內`UseEndpoints`。

新增`MapRazorPages`如果應用程式中使用 Razor 頁面。 因為端點路由包含支援許多架構中，新增 Razor Pages 現在選用功能。

在下列範例中，`MapRazorPages`新增支援 Razor 頁面：

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>使用 MVC，而不需要端點的路由

使用透過 MVC`UseMvc`或是`UseMvcWithDefaultRoute`ASP.NET Core 3.0 需要明確選擇單元內`Startup.ConfigureServices`。 這是必要的因為 MVC 必須知道是否它可以依賴的授權和 CORS 中介軟體在初始化期間。 分析器會提供，會發出警告如果應用程式會嘗試使用不支援的組態。

如果應用程式需要舊版`IRouter`支援，請停用`EnableEndpointRouting`使用下列任一方法中， `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="migrate-health-checks"></a>移轉健康情況檢查

健康情況檢查可以用作*路由器軟體*端點路由。

新增`MapHealthChecks`使用健康狀態檢查端點的路由。 `MapHealthChecks`方法會接受引數類似`UseHealthChecks`。 使用的優點`MapHealthChecks`透過`UseHealthChecks`是套用授權，以及可以更精細的比對原則控制的能力。 

在下列範例中，`MapHealthChecks`會針對在健康狀態檢查端點呼叫`/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder 取代 WebHostBuilder

ASP.NET Core 3.0 範本會使用[泛型主機](xref:fundamentals/host/generic-host)。 使用的舊版[Web 主機](xref:fundamentals/host/web-host)。 下列程式碼顯示產生的 ASP.NET Core 3.0 範本`Program`類別：

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

下列程式碼會顯示在範本產生的 ASP.NET Core 2.2`Program`類別：

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> 會保留在 3.0 中，而且類型`webBuilder`上述的程式碼範例所示。 <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> 會在未來版本中已被取代，並取代`HostBuilder`。

從最重大的改變`WebHostBuilder`要`HostBuilder`處於[相依性插入 (DI)](xref:fundamentals/dependency-injection)。 使用時`HostBuilder`，您只可以插入<xref:Microsoft.Extensions.Configuration.IConfiguration>並<xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment>成`Startup`的建構函式。 `HostBuilder` DI 條件約束：

* 啟用 DI 容器來建置一次。
* 可避免產生的物件存留期問題，例如解決多個單一執行個體。

## <a name="update-signalr-code"></a>更新 SignalR 的程式碼

`System.Text.Json` 是現在用戶端和伺服器所使用的預設中樞通訊協定。

在  `Startup.ConfigureServices`，呼叫`AddJsonProtocol`設定序列化程式的選項。

**伺服器：**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**用戶端：**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>切換至 Newtonsoft.Json

如果您使用的功能`Newtonsoft.Json`不支援的`System.Text.Json`，您可以切換回`Newtonsoft.Json`:

1. 安裝[Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet 套件。
1. 在用戶端，鏈結`AddNewtonsoftJsonProtocol`方法呼叫`HubConnectionBuilder`執行個體：

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. 在伺服器上，鏈結`AddNewtonsoftJsonProtocol`方法呼叫`AddSignalR`方法呼叫中`Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>選擇在執行階段編譯

在 3.0 中，執行階段編譯是選擇性的案例。 若要啟用執行階段編譯，請參閱<xref:mvc/views/view-compilation#runtime-compilation>。
