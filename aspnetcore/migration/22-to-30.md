---
title: 從 ASP.NET 核心 2.2 遷移到 3.0
author: rick-anderson
description: 瞭解如何將ASP.NET核心 2.2 專案遷移到 ASP.NET核心 3.0。
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977232"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>從 ASP.NET 核心 2.2 遷移到 3.0

由[斯科特·阿迪](https://github.com/scottaddie)和[里克·安德森](https://twitter.com/RickAndMSFT)

本文介紹如何將現有的ASP.NET酷睿 2.2 專案更新為 ASP.NET Core 3.0。

## <a name="prerequisites"></a>Prerequisites

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>更新 global.json 中的 .NET Core SDK 版本

如果解決方案依賴於[global.json](/dotnet/core/tools/global-json)檔來定位特定的 .NET Core`version`SDK 版本, 請將其屬性更新到電腦上安裝的 3.0 版本:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>更新項目檔案

### <a name="update-the-target-framework"></a>更新目標框架

ASP.NET核心 3.0 和更高版本僅在 .NET Core 上運行。 將[目標框架 Moniker (TFM)](/dotnet/standard/frameworks)設定為`netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>移除過時的套件參考

大量 NuGet 包不是為 ASP.NET Core 3.0 生產的。 此類包引用應從專案檔中刪除。 請考慮ASP.NET酷睿 2.2 Web 應用的專案檔:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

ASP.NET Core 3.0 的更新項目檔:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

更新ASP.NET Core 3.0 專案檔:

* 在 `<PropertyGroup>` 中：
  * 將 TFM 更新到`netcoreapp3.0`
  * 刪除元素`<AspNetCoreHostingModel>`。 有關詳細資訊,請參閱本文件中的[行程內託管模型](#in-process-hosting-model)。

* 在 `<ItemGroup>` 中：
  * `Microsoft.AspNetCore.App`已刪除。 有關詳細資訊,請參考此文件中的[框架參考](#framework-reference)。
  * `Microsoft.AspNetCore.Razor.Design`刪除,並在以下不再生成的包清單中刪除。

要檢視不再產生的套件的完整清單,請選擇以下延伸清單:

<details>
    <summary>點選以展開不再產生的套件清單</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>微軟.AspNetCore。SignalR</li>
        <li>微軟.AspNetCore。SignalR.核心</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>檢視變更

[檢視變更](#break)

### <a name="framework-reference"></a>框架參考

通過上面列出的軟體包之一提供的ASP.NET Core 的功能可作為共用框架`Microsoft.AspNetCore.App`的一部分提供。 *共用框架*是安裝在計算機上的程式集 *(.dll*檔)的集合,包括運行時元件和目標包。 如需詳細資訊，請參閱[共用的架構](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) \(英文\)。

* 以`Microsoft.NET.Sdk.Web`SDK 為目標的專案`Microsoft.AspNetCore.App`隱式 引用框架。

  這些專案不需要其他引用:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* 目標`Microsoft.NET.Sdk`或`Microsoft.NET.Sdk.Razor`SDK 的項目應`FrameworkReference`向`Microsoft.AspNetCore.App`新增 :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>使用 Docker 與框架相關的產生

使用相依 ASP.NET Core[共用框架](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)的套件的主控台應用的與框架相關的產生可能會導致以下執行時錯誤:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`是包含ASP.NET核心運行時的共用框架,僅存在於[dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker映射上。 3.0 SDK 通過不包括共用框架中可用的庫的副本來減小使用 ASP.NET Core 的與框架相關的生成的大小。 這是高達 18 MB 的潛在節省,但它要求存在/安裝 ASP.NET 核心執行時才能運行應用。

要確定應用在ASP.NET Core 共用框架上是否有依賴項(直接或間接),請檢查在應用生成/發佈期間生成的*運行時 config.json*檔。 以下 JSON 檔顯示對 ASP.NET 核心共用框架的依賴:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

如果應用正在使用 Docker,請使用包含 ASP.NET 酷睿 3.0 的基本映射。 例如： `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0` 。

### <a name="add-package-references-for-removed-assemblies"></a>新增套件為已移除的程式集加入套件

ASP.NET Core 3.0`Microsoft.AspNetCore.App`刪除以前屬於 包引用的某些程式集。 要可視化已刪除的程式集,請比較兩個共用框架資料夾。 例如,比較版本 2.2.7 和 3.0.0:

![共用框架程式集比較](22-to-30/_static/assembly-diff.png)

要繼續使用已刪除程式集提供的功能,請參閱相應包的 3.0 版本:

* 具有**個人使用者帳戶**的樣本產生的 Web 應用需要新增以下套件:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  有關引用特定於資料庫提供者的套件的詳細資訊,請參考[資料庫提供者](/ef/core/providers/index)。

* 識別 UI

  可以通過引用[Microsoft.AspNetCore.Identity.UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)包來添加對[標識 UI](xref:security/authentication/identity)的支援。

* SPA服務

  * [微軟.AspNetCore.Spa服務](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [微軟.AspNetCore.Spa服務.擴展](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* 第&ndash;三方身份驗證串流的身分驗證支援可作為 NuGet 套件提供:

  * 臉譜網 ([微軟. AspNetCore. 身份驗證. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * 谷歌OAuth ([微軟.AspNetCore.身份驗證.谷歌](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * 微軟帳戶身份驗證 ([微軟.AspNetCore. 身份驗證. 微軟帳戶](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID 連線認證 ([微軟. AspNetCore. 身份認證. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID 連線承載權杖 ([微軟.AspNetCore.身份驗證.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * 推特OAuth ([微軟.AspNetCore.身份驗證.推特](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ws 驗證 ([微軟. AspNetCore. 身份驗證. Ws 聯盟](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* `System.Net.HttpClient` [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 套件的格式和內容協商支援為`System.Net.HttpClient`API 提供了 有`ReadAsAsync`用`PostJsonAsync`的擴展,例如和 。 &ndash;

* Razor 執行時編&ndash;譯 支援 Razor 檢視和頁面的執行時編譯現在是 Microsoft 的一部分[。](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)

* MVC(Json.NET)`Newtonsoft.Json`&ndash;支援`Newtonsoft.Json`支援使用 MVC,現在屬於[微軟。](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="startup-changes"></a>啟動變更

下圖顯示 ASP.NET 核心 2.2 Razor 網頁網頁 應用中已刪除和更改的行:

![已移除與變更的行在ASP.NET核心 2.2 Razor Web 應用程式](22-to-30/_static/startup2.2.png)

在前面的圖像中,刪除的代碼顯示為紅色。 已刪除的代碼不顯示 Cookie 選項代碼,該選項代碼在比較檔之前已被刪除。

下圖顯示了 ASP.NET 酷睿 3.0 Razor 頁面 Web 應用中新增和更改的行:

![在ASP.NET核心 3.0 Razor Web 應用程式中新增和更改的行](22-to-30/_static/startup3.0.png)

在前面的圖像中,添加的代碼顯示為綠色。 有關以下變更的資訊:

* `services.AddMvc`請`services.AddRazorPages`參考此文件的[MVC 服務註冊](#mvc-service-registration)。
* `CompatibilityVersion`,請參閱<xref:mvc/compatibility-version>。
* `IHostingEnvironment`到`IWebHostEnvironment`,請參閱[此 GitHub 公告](https://github.com/dotnet/AspNetCore/issues/7749)。
* `app.UseAuthorization`已添加到範本中,以顯示必須添加的訂單授權中間件。 如果應用不使用授權,則可以安全地刪除對`app.UseAuthorization`的調用。
* `app.UseEndpoints`,請參閱[Razor 頁面](#razor-pages)或[遷移啟動。](#migrate-startupconfigure)在此文檔中配置。

### <a name="analyzer-support"></a>分析儀支援

以前作為`Microsoft.NET.Sdk.Web`[Microsoft.AspNetCore.Mvc.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/)包的一部分,以隱式引用分析器為目標的專案。 無需其他引用即可啟用這些引用。

如果你的應用程式使用以前使用[Microsoft.AspNetCore.Mvc.Api.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/)套件附帶的[API 分析器](xref:web-api/advanced/analyzers),請編輯專案檔以參考作為 .NET Core Web SDK 的一部分提供的分析器:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor 類別庫

為 MVC 提供 UI 元件的`AddRazorSupportForMvc`Razor 函式庫項目必須在專案檔中設定屬性:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>同處理序裝載模型

專案預設為 ASP.NET Core 3.0 或更高版本中[的行程中託管模型](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model)。 如果屬性的值為`<AspNetCoreHostingModel>``InProcess`,則可以選擇刪除專案檔中的屬性。

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>組態

將 Kestrel 設定移到`ConfigureWebHostDefaults`( *Program.cs*) 提供的 Web 主機產生器 :

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

如果應用程式使用 手動建立主機`HostBuilder`, 請`UseKestrel`呼`ConfigureWebHostDefaults`叫中的 Web 主機產生器:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>連接中間件取代連接介面

連接配接器`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`( ) 已從 Kestrel 中刪除。 將連接介面替換為連接中間件。 連接中間件類似於ASP.NET核心管道中的 HTTP 中間件,但對於較低級別的連接。 HTTPS 與連線紀錄紀錄:

* 已從連接適配器移動到連接中間件。
* 這些擴展方法的工作方式與早期版本的 ASP.NET Core 相同。 

有關詳細資訊,請參閱[Kestrel 文章的「偵聽選項.協定」部分中的 TlsFilterConnectionHandler](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)範例。

### <a name="transport-abstractions-moved-and-made-public"></a>傳輸抽象移動並公開

Kestrel 傳輸層已作為 公共介面`Connections.Abstractions`在 中 公開。 為這些更新的一部分:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`和關聯的類型已被刪除。
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>已移動到<xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions>傳輸選項。
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`從<xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>中刪除。

有關詳細資訊,請參閱以下 GitHub 資源:

* [用戶端/伺服器網络抽象(點網/阿斯普網核心#10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [實現新的基岩偵聽器抽象,並在頂部重新鍍凱斯特雷爾(點網/阿斯普內科#10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>凱斯特雷爾請求拖車頭

對於針對早期版本的ASP.NET核心的應用:

* Kestrel 將 HTTP/1.1 塊狀的掛頁標頭添加到請求標頭集合中。
* 在讀取請求正文到末尾后,可以使用拖車。

這會引起一些對標題和拖車之間歧義的擔憂,因此拖車已移動到 3.0 中`RequestTrailerExtensions`的新集合 ( )。

HTTP/2 請求預告片包括:

* ASP.NET酷睿 2.2 中不可用。
* 3.0`RequestTrailerExtensions`表示 ,以 。

存在新的請求擴展方法來訪問這些拖車。 與 HTTP/1.1 一樣,在讀取請求正文到末尾後,拖車可用。

對於 3.0 版本,`RequestTrailerExtensions`可以使用 以下方法:

* `GetDeclaredTrailers`&ndash;獲取列出正文`Trailer`後要預期的預告片的請求標頭。
* `SupportsTrailers`&ndash;指示請求是否支援接收拖車標頭。
* `CheckTrailersAvailable`&ndash;檢查請求是否支援預告片,以及它們是否可供讀取。 此檢查不假定有要讀取的預告片。 即使`true`此方法返回,也可能沒有要讀取的預告片。
* `GetTrailer`&ndash;從回應獲取請求的尾隨標頭。 呼叫`SupportsTrailers``GetTrailer`之前檢查,或<xref:System.NotSupportedException>如果 要求不支援尾隨標頭,則可能發生 。

有關詳細資訊,請參閱[將請求預告片放入單獨的集合中(dotnet/AspNetCore #10410)。](https://github.com/dotnet/AspNetCore/pull/10410)

### <a name="allowsynchronousio-disabled"></a>允許關閉同步IO

`AllowSynchronousIO`開啟或關閉同步 I/O API,`HttpRequest.Body.Read`如`HttpResponse.Body.Write`與`Stream.Flush`。 這些 API 是導致應用崩潰的線程不足的來源。 在 3.0`AllowSynchronousIO`中,默認情況下處於禁用狀態。 有關詳細資訊,請參閱[Kestrel 文章中的同步 I/O 部分](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)。

如果需要同步 I/O,可以通過配置正在使用的`AllowSynchronousIO`伺服器上的選項來啟用它(例如,在`ConfigureKestrel`調用 時,如果使用 Kestrel)。 請注意,伺服器(Kestrel、HRSys、TestServer等)都有`AllowSynchronousIO`自己的選項,不會影響其他伺服器。 使用`IHttpBodyControlFeature.AllowSynchronousIO`以下選項,可按請求為每個伺服器開啟同步 I/O:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

如果在 Dispose<xref:System.IO.TextWriter>中 調用同步 API 的[Dispose](/dotnet/standard/garbage-collection/implementing-dispose)實現或其他流時遇到 問題<xref:System.IO.Stream.DisposeAsync*>,請改為調用 新的 API。

有關詳細資訊,請參閱[[通知] 允許在所有伺服器(點網/阿斯普內科#7644)中禁用同步IO。](https://github.com/dotnet/AspNetCore/issues/7644)

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>微軟.AspNetCore.Server.Kestrel.HHt程式集已被刪除

在ASP.NET核心2.1中,*微軟.AspNetCore.Server.Kestrel.H00H H0 00*公尺的內容被移到*微軟.AspNetCore.Server.Kestrel.Core.dll。* 這是使用`TypeForwardedTo`屬性的非中斷更新。 對於 3.0,空的*Microsoft.AspNetCore.Server.Kestrel.HHHH H.h.dll*程式集和 NuGet 包已被刪除。

引用[Microsoft.AspNetCore.Server.Kestrel.H 核心](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)依賴項更新為 2.1 或更高版本。

面向ASP.NET Core 2.1 或更高版本的應用和庫應刪除對[Microsoft.AspNetCore.Server.Kestrel.HHs](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)包的任何直接引用。

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>牛頓軟.Json (Json.NET) 支援

作為[改進ASP.NET核心共用框架](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)工作的一部分,[牛頓軟.Json(Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm)已被從ASP.NET核心共用框架中刪除。

ASP.NET核心的預設 JSON 序列化器<xref:System.Text.Json>現在是 ,這是 .NET Core 3.0 中的新序列化程式。 盡可能`System.Text.Json`考慮使用。 它具有高性能,不需要額外的庫依賴項。 但是,由於`System.Text.Json`它是新的,因此當前可能缺少應用所需的功能。 有關詳細資訊,請參閱[如何從 Newtonsoft.Json 遷移到系統.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)。

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>在ASP.NET核心3.0SignalR專案中使用牛頓軟.Json

* 安裝[微軟.AspNetCore.SignalR. . .協定.牛頓軟日新](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson)核包裝。

* 在用戶端上,將`AddNewtonsoftJsonProtocol`方法呼叫連結`HubConnectionBuilder`到 實體:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* 在伺服器上,將`AddNewtonsoftJsonProtocol`方法呼叫`AddSignalR`連結到 方法呼`Startup.ConfigureServices`叫 :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>在ASP.NET核心 3.0 MVC 專案中使用牛頓軟.Json

* 安裝[微軟.AspNetCore.Mvc.牛頓套件](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)。

* 更新`Startup.ConfigureServices`以呼`AddNewtonsoftJson`叫 。

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`與新的 MVC 服務註冊方法相容:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`可以呼叫 中設定`AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**註:** 如果`AddNewtonsoftJson`該方法不可用,請確保安裝了[Microsoft.AspNetCore.Mvc.NewtonsoftJon](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)套件。 常見的錯誤是安裝[牛頓軟.Json](https://www.nuget.org/packages/Newtonsoft.Json/)包,而不是[微軟.AspNetCore.Mvc.牛頓軟日包](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)。

## <a name="mvc-service-registration"></a>MVC 服務註冊

ASP.NET Core 3.0 添加了`Startup.ConfigureServices`用於在 中註冊 MVC 方案的新選項。

有三種與 MVC`IServiceCollection`方案相關的新頂級擴充方法可用。 樣本使用這些新方法而不是`AddMvc`。 但是,`AddMvc`繼續像以前版本中一樣。

下面的範例添加了對控制器和 API 相關功能的支援,但不支援檢視或頁面。 API 樣本使用此代碼:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

下面的範例添加了對控制器、API 相關功能和檢視的支援,但不包括頁面。 Web 應用程式 (MVC) 樣本使用以下代碼:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

下面的範例增加了對Razor頁面的支援和最小控制器支援。 Web 應用程式樣本使用此代碼:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

也可以組合新方法。 以下範例等效於在ASP.NET`AddMvc`酷 2.2 中呼叫:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>路由啟動代碼

如果應用呼叫`UseMvc``UseSignalR`或 ,如果可能,將應用遷移到[終結點路由](xref:fundamentals/routing)。 為了提高端點路由與 MVC 早期版本的相容性,我們還原了 ASP.NET Core 2.2 中引入的 URL 生成中的一些更改。 如果您在 2.2 中使用端點路由時遇到問題,則 ASP.NET Core 3.0 中會出現改進,但有以下例外情況:

* 如果應用實現`IRouter`或繼承`Route`, 請使用[DynamicRouteValue 變形金剛](https://github.com/dotnet/AspNetCore.Docs/issues/12997)作為替換。
* 如果應用直接存取`RouteData.Routers`MVC 內部解析 URL,則可以使用[LinkParser](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*)替換它。 
  * 使用路由名稱定義路由。
  * 使用`LinkParser.ParsePathByEndpointName`並傳遞所需的路由名稱。

終結點路由支援與的相同路由模式語法和路由模式創作功能`IRouter`。 終結點路由支援`IRouteConstraint`。 終結點路由支援`[Route]``[HttpGet]`,和其他 MVC 路由屬性。

對於大多數應用程式,只需要`Startup`更改。

### <a name="migrate-startupconfigure"></a>移轉開機.設定

一般建議:

* 加入 `UseRouting`。
* 如果套`UseStaticFiles`用呼叫`UseStaticFiles`,則在**前**`UseRouting`放置 。
* 如果應用程式使用`AuthorizePage`認證或認證或認證功能(`[Authorize]`如或 ),則`UseAuthentication`將`UseAuthorization`呼`UseRouting`叫`UseCors`放在與`UseEndpoints`之後 **,** 但在 :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* 取代`UseMvc``UseSignalR`或`UseEndpoints`使用 。
* 如果套用[式使用 CORS](xref:security/cors)專案`[EnableCors]`(如`UseCors`,將呼叫放在 CORS 的任何其他中間`UseCors``UseAuthentication`件`UseAuthorization`之前(`UseEndpoints`例如,在之前放置 , 和 )
* 取代為`IHostingEnvironment``IWebHostEnvironment`並添加命名`using`空間<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>的語句。
* 取代為`IApplicationLifetime`<xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime>命名<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>空間。
* 取代為`EnvironmentName`<xref:Microsoft.Extensions.Hosting.Environments>命名<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>空間。

以下代碼是典型的`Startup.Configure`ASP.NET 酷 2.2 應用中的範例:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

更新前面的`Startup.Configure`代碼後:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> 對於大多數`UseAuthentication`應用,對`UseAuthorization`的調`UseCors`用 必須出現在`UseRouting`調`UseEndpoints`用 和 之間才能有效。

### <a name="health-checks"></a>健康情況檢查

運行狀況檢查使用與通用主機的終結點路由。 在`Startup.Configure`中`MapHealthChecks`,使用終結點網址 或相對路徑呼叫終結點產生器:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

執行狀況檢查終結點可以:

* 指定一個或多個允許的主機/埠。
* 需要授權。
* 需要 CORS。

如需詳細資訊，請參閱 <xref:host-and-deploy/health-checks>。

### <a name="security-middleware-guidance"></a>安全中間件指南

圍繞[中間件](xref:fundamentals/middleware/index)方法統一支援授權和 CORS。 這允許在這些方案中使用相同的中間件和功能。 此版本中提供了更新的授權中間件,並增強了 CORS 中間件,以便瞭解 MVC 控制器使用的屬性。

#### <a name="cors"></a>CORS

以前,CORS 可能難以配置。 提供中間件用於某些用例,但MVC篩選器旨在在其他用例**中不使用**中間件。 使用 ASP.NET 酷 3.0,我們建議所有需要 CORS 的應用與端點路由一起使用 CORS 中間件。 `UseCors`可以提供預設策略,並且`[EnableCors]``[DisableCors]`屬性可用於在需要時覆蓋預設策略。

在下例中︰

* 使用`default`命名策略為所有終結點啟用 CORS。
* 類`MyController`禁用具有屬性的`[DisableCors]`CORS。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>授權

在早期版本的ASP.NET Core 中,授權支援是`[Authorize]`通過 該屬性提供的。 授權中間件不可用。 在ASP.NET酷 3.0 中,需要授權中間件。 我們建議在 之後立即放置 ASP.NET`UseAuthorization`核心`UseAuthentication`授權中間 件 ( ) 。 授權中間件也可以配置預設策略,可以重寫該策略。

在 ASP.NET Core`UseAuthorization`3.0 或更高`Startup.Configure``HomeController`版本中呼叫, 並且以下要求登入使用者:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

使用端點路由時,我們建議不要配置`<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>`,而是依賴授權中間件。  如果應用在 MVC 中`AuthorizeFilter`使用 作為全域篩選器,我們建議重構代碼以在`AddAuthorization`調用 中提供策略。

`DefaultPolicy`最初配置為需要身份驗證,因此不需要其他配置。 在下面的範例中,MVC 終結點被標記`RequireAuthorization`為 ,以便必須`DefaultPolicy`基於授權 所有請求。 但是,由於`HomeController``[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>特定終結點的授權

還可以為特定終結點類別配置授權。 以下代碼是將全域`AuthorizeFilter`設定為具有特定策略的應用需要授權的 MVC 應用的範例:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

也可以自定義策略。 設定為`DefaultPolicy`需要身份驗證:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

或者,可以將所有終結點配置為無需或`[Authorize]``RequireAuthorization`配置 即可獲得`FallbackPolicy`授權。 與`FallbackPolicy`的不同`DefaultPolicy`。 `DefaultPolicy`由`[Authorize]``RequireAuthorization`或 觸發`FallbackPolicy`,而在未設定其他策略時觸發 。 `FallbackPolicy`最初配置為允許授權請求。

以下範例與前面的`DefaultPolicy`範例相同`FallbackPolicy`, 但使用 以始終要求對所有終結點進行身份驗證,`[AllowAnonymous]`除非指定:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

中間件授權無需具有任何特定授權知識的框架即可工作。 例如,[執行狀況檢查](xref:host-and-deploy/health-checks)沒有特定的授權知識,但運行狀況檢查可以應用中間件的可配置授權策略。

此外,每個終結點都可以自定義其授權要求。 在以下`UseAuthorization`範例中,使用 處理`DefaultPolicy`授權`/healthz`, 但 執行狀況`admin`檢查終結點需要 使用者:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

某些方案都實現了保護。 如果由於缺少中間件而跳過授權或 CORS 策略,則端點中間件將引發異常。 分析器支援提供有關錯誤配置的其他反饋,目前正在進行中。

#### <a name="custom-authorization-handlers"></a>自訂授權處理程式

如果應用使用自定義[授權處理程式](xref:security/authorization/policies#authorization-handlers),則終結點路由會將不同的資源類型傳遞給與 MVC 不同的處理程式。 需要更新預期授權處理程式上下文資源為類型的<xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext>處理程式[(MVC 篩選器提供](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)的資源類型)<xref:Microsoft.AspNetCore.Routing.RouteEndpoint>來處理類型 資源(終結點路由提供給授權處理程序的資源類型)。

MVC`AuthorizationFilterContext`仍 使用資源,因此,如果應用使用 MVC 授權篩選器以及終結點路由授權,則可能需要處理這兩種類型的資源。

### SignalR

集線SignalR器的映射現在`UseEndpoints`發生在內部。

使用 映射`MapHub`每個中心。 與早期版本中一樣,每個中心都顯式列出。

在下面的範例中,添加了對`ChatHub`SignalR中心的支援:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

有一個用於控制來自用戶端的消息大小限制的新選項。 例如，在 `Startup.ConfigureServices` 中：

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

在ASP.NET Core 2.2`TransportMaxBufferSize`中, 您可以設置 和,這將有效地控制最大消息大小。 在 ASP.NET Core 3.0 中,該選項現在僅控制觀察到背壓之前的最大大小。

### <a name="mvc-controllers"></a>MVC 控制器

控制器的對應現在發生在內部`UseEndpoints`。

如果`MapControllers`應用使用屬性路由,則添加。 由於路由包括支援ASP.NET Core 3.0 或更高版本中的許多框架,因此添加屬性路由控制器是選擇加入的。

取代下列項目：

* `MapControllerRoute` 的 `MapRoute`
* `MapAreaControllerRoute` 的 `MapAreaRoute`

由於路由現在包括對 MVC 的支援,因此術語已更改,使這些方法清楚地說明它們所做操作的內容。 常規路由(如`MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute`按添加順序應用)。 首先放置更具體的路線(如區域的路線)。

在下例中︰

* `MapControllers`添加對屬性路由控制器的支援。
* `MapAreaControllerRoute`為區域中的控制器添加常規路由。
* `MapControllerRoute`為控制器添加常規路由。

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>從控制器操作名稱中移除非同步後綴

在ASP.NET核心 3.0 中,ASP.NET核心`Async`MVC 從控制器操作名稱中刪除後綴。 路由和鏈路生成都受此新預設值的影響。 例如：

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

在 ASP.NET核心 3.0 之前:

* 可以在*產品/ListAsync*路由上訪問上述操作。
* 需要指定後綴的連結`Async`生成。 例如：

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

在ASP.NET核心 3.0 中:

* 可以在 *"產品/清單*"路由上存取上述操作。
* 連結生成不需要指定`Async`後綴。 例如：

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

此更改不會影響使用[`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute)屬性 指定的名稱。 可以使用以下代碼關閉預設行為`Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>連結產生變更

如在有關[與早期路由版本差異](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)的文檔中所述,在連結生成`Url.Link`(例如使用和類似的 API)上存在一些差異。 其中包括：

* 默認情況下,當使用端點路由時,生成的URI中路由參數的大小寫不一定保留。 此行為可以`IOutboundParameterTransformer`通過 介面進行控制。
* 為無效路由(不存在的控制器/操作或頁面)生成URI將在終結點路由下生成空字串,而不是生成無效URI。
* 環境值(當前上下文中的路由參數)不會自動用於與端點路由的連結生成。 以前,在生成指向其他操作(或頁面)的連結時,將從*當前*路由環境值推斷出未指定的路由值。 使用端點路由時,必須在連結生成期間顯式指定所有路由參數。

### <a name="razor-pages"></a>Razor 頁面

映射剃刀頁面現在發生在內部`UseEndpoints`。

如果`MapRazorPages`應用使用剃刀頁面,則添加。 由於端點路由包括對許多框架的支援,因此現在選擇添加 Razor 頁面。

在以下`Startup.Configure`方法中`MapRazorPages`, 加入對 Razor 頁面的支援:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>使用沒有終結點路由的 MVC

使用 MVC`UseMvc``UseMvcWithDefaultRoute`透過或 ASP.NET Core`Startup.ConfigureServices`3.0 需要在 中顯式加入加入 。 這是必需的,因為 MVC 必須知道它在初始化期間是否可以依賴授權和 CORS 中間件。 提供分析器,用於警告應用是否嘗試使用不受支援的配置。

如果應用需要舊版`IRouter`支援,請`EnableEndpointRouting`使用`Startup.ConfigureServices`以下 任一方法關閉 :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>健康情況檢查

執行狀況檢查可用的點路由*的路由器軟體*。

添加`MapHealthChecks`以將運行狀況檢查與終結點路由一起添加。 該方法`MapHealthChecks`接受類似`UseHealthChecks`於的參數。 使用`MapHealthChecks`超過`UseHealthChecks`的優點是能夠應用授權和對匹配策略具有更大的細粒度控制。

在下面的範例中,`MapHealthChecks`在 呼叫狀態檢查終結點`/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>主機構建器取代 WebHostBuilder

ASP.NET核心 3.0 樣本使用[通用主機](xref:fundamentals/host/generic-host)。 以前的版本使用[Web 主機](xref:fundamentals/host/web-host)。 以下代碼顯示 ASP.NET Core 3.0`Program`樣本 產生的類別:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

以下代碼顯示 ASP.NET Core 2.2 樣本`Program`產生的類別:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>保留在 3.0 中,`webBuilder`是前面 代碼示例中看到的類型。 <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>將在將來的版本中棄用,代之以`HostBuilder`。

到 中最重要的`WebHostBuilder``HostBuilder`變化 是[依賴項注入 (DI)。](xref:fundamentals/dependency-injection) 使用`HostBuilder`時,只能將以下內容注入`Startup`到 的建構函數中:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

DI`HostBuilder`限制:

* 使 DI 容器只能生成一次。
* 避免生成的物件存留期問題,如解決單例的多個實例。

有關詳細資訊,請參閱[ASP.NET 酷 3 中避免啟動服務注入](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)。

## <a name="addauthorization-moved-to-a-different-assembly"></a>將授權移至其他應用程式集的新增授權

ASP.NET核心2.2和較低的`AddAuthorization`方法在*微軟.AspNetCore.授權.dll*:

* 已重新命名`AddAuthorizationCore`。
* 已移至*微軟.AspNetCore.授權.政策.dll*。

使用*Microsoft.AspNetCore.授權.dll*和*Microsoft.AspNetCore.授權.策略.dll*的應用不受影響。

不使用*Microsoft.AspNetCore.授權.policy.dll*的應用應執行以下操作之一:

* 新增對*Microsoft 的參考.AspNetCore.授權.政策.dll*。 此方法適用於大多數應用,並且是所有必需的應用。
* 切換到使用`AddAuthorizationCore`

有關詳細資訊,請參閱[在`AddAuthorization(o =>`) 中分解更改,#386 中位於其他程式集中](https://github.com/aspnet/Announcements/issues/386)。

## <a name="identity-ui"></a>識別 UI

ASP.NET核心 3.0 的識別 UI 更新:

* 新增對[Microsoft 的套件引用.AspNetCore.身份.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI)。
* 不使用 Razor 頁面的應用程式必須`MapRazorPages`呼叫 。 請參考此文件的[剃刀頁](#razor-pages)。
* 引導 4 是預設的 UI 框架。 設定`IdentityUIFrameworkVersion`項目屬性以更改預設值。 有關詳細資訊,請參閱此[GitHub 公告](https://github.com/aspnet/Announcements/issues/380)。

## SignalR

SignalR JavaScript 客戶端已`@aspnet/signalr``@microsoft/signalr`變更為 。 要對此更改做出反應,更改*包.json*`require`檔、 語句和 ECMAScript`import`語句中的引用。

### <a name="systemtextjson-is-the-default-protocol"></a>系統.Text.Json 是預設的協定

`System.Text.Json`現在客戶端和伺服器使用的預設集線器協定。

在`Startup.ConfigureServices``AddJsonProtocol`中 調用 以設置序列化器選項。

**伺服器:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**用戶端：**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>切換到牛頓軟. Json

如果您使用的為[Newtonsoft.Json 的功能,系統中不支援。Text.Json,](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)您可以切換`Newtonsoft.Json`回 。 請參閱本文前面[ASP.NET SignalR Core 3.0 專案中使用 Newtonsoft.Json。](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project)

## <a name="redis-distributed-caches"></a>雷瑞斯分散式緩存

[Microsoft.擴展.緩存.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis)包不適用於ASP.NET酷睿 3.0 或更高版本的應用。 將包引用替換為[Microsoft.擴展.快取.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis)。 如需詳細資訊，請參閱 <xref:performance/caching/distributed>。

## <a name="opt-in-to-runtime-compilation"></a>加入宣告執行時編譯

在ASP.NET Core 3.0 之前,視圖的運行時編譯是框架的一個隱式功能。 運行時編譯補充視圖的生成時間編譯。 它允許框架在修改檔時編譯 Razor 檢視和頁面 *(.cshtml*檔),而無需重建整個應用程式。 此功能支援在 IDE 中快速編輯和刷新瀏覽器以查看更改的方案。

在ASP.NET酷3.0中,運行時編譯是一種加入加入方案。 生成時間編譯是默認情況下啟用的檢視編譯的唯一機制。 執行時依賴於 Visual Studio 代碼中的 Visual Studio 或[點網監視](xref:tutorials/dotnet-watch),以在檢測到*對 .cshtml*檔的更改時重建專案。 在 Visual Studio 中,對 *.cs、.cshtml*或 *.razor*檔所做的更改將發生在正在運行的專案中<kbd>(Ctrl_F5),</kbd>但不調試<kbd>(F5),</kbd>從而觸發專案的重新編譯。 *.cs*

要在 ASP.NET Core 3.0 專案中啟用執行時編譯,請:

1. 安裝[微軟.AspNetCore.Mvc.Razor.運行時編譯](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)NuGet包。
1. 更新`Startup.ConfigureServices`以呼`AddRazorRuntimeCompilation`叫 :

    對於ASP.NET核心 MVC,請使用以下代碼:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    對於ASP.NET核心剃刀頁面,請使用以下代碼:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
中的https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation範例顯示了在開發環境中有條件地啟用運行時編譯的範例。

有關 Razor 檔編譯的詳細資訊,請<xref:mvc/views/view-compilation>參閱 。

## <a name="migrate-libraries-via-multi-targeting"></a>透過多目標移轉庫

庫通常需要支援ASP.NET核心的多個版本。 大多數根據以前版本的ASP.NET Core 編譯的庫應繼續工作,沒有問題。 以下條件要求交叉編譯應用:

* 庫依賴於具有二進制[中斷更改](#breaking-api-changes)的功能。
* 該庫希望利用ASP.NET Core 3.0 中的新功能。 

例如：

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

開啟`#ifdefs`ASP.NET核心 3.0 特定的 API:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

有關在類庫中使用ASP.NET核心 API 的詳細資訊,請<xref:fundamentals/target-aspnetcore>參閱 。

## <a name="miscellaneous-changes"></a>其他變更

.NET Core 3.0 中的驗證系統及其後處理非空參數或綁定屬性,就像它們`[Required]`具有屬性一 樣。 有關詳細資訊,請參閱[[必需] 屬性](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute)。

### <a name="publish"></a>發佈

刪除項目目錄中的*bin*和*obj*資料夾。

## <a name="testserver"></a>測試伺服器

<xref:Microsoft.AspNetCore.TestHost.TestServer>對於直接與[通用主機](xref:fundamentals/host/web-host)一起使用的應用`TestServer`<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>,<xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>在中 創建

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>破壞 API 變更

檢視重大變更:

* [ASP.NET酷睿 3.0 版本中斷更改的完整清單](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [在反偽造、CORS、診斷、MVC 和路由 中破壞 API 更改](https://github.com/aspnet/Announcements/issues/387)。 此清單包括相容換機的中斷更改。
* 有關 .NET Core、ASP.NET核心和實體框架核心的 2.2 到 3.0 重大更改的摘要,請參閱[從版本 2.2 到 3.0 的遷移的中斷更改](/dotnet/core/compatibility/2.2-3.0)。

## <a name="net-core-30-on-azure-app-service"></a>Azure 應用服務上的 .NET 核心 3.0

有關 .NET 核心到 Azure 應用服務的推出進度,請參閱[應用服務網站上的官方 .NET Core。](https://aspnetcoreon.azurewebsites.net/) 在 .NET Core 3.0 在 Azure 應用服務上可用之前,請按照[將 ASP.NET核心預覽版部署到 Azure 應用服務](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service))中的說明操作。
