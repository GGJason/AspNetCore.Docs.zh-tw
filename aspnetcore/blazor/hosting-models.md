---
title: ASP.NET核心Blazor託管模型
author: guardrex
description: 瞭解BlazorBlazorWeb 組裝和伺服器託管模型。
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/31/2020
no-loc:
- Blazor
- SignalR
uid: blazor/hosting-models
ms.openlocfilehash: 0dfc991f76acb227ce9ea27a07fbae50571f0117
ms.sourcegitcommit: f7886fd2e219db9d7ce27b16c0dc5901e658d64e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2020
ms.locfileid: "80471824"
---
# <a name="aspnet-core-opno-locblazor-hosting-models"></a><span data-ttu-id="5a12c-103">ASP.NET核心Blazor託管模型</span><span class="sxs-lookup"><span data-stu-id="5a12c-103">ASP.NET Core Blazor hosting models</span></span>

<span data-ttu-id="5a12c-104">由[丹尼爾·羅斯](https://github.com/danroth27)</span><span class="sxs-lookup"><span data-stu-id="5a12c-104">By [Daniel Roth](https://github.com/danroth27)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

Blazor<span data-ttu-id="5a12c-105">是一個 Web 架構,旨在在瀏覽器中執行用戶端在基於[Webassembly](https://webassembly.org/)的 .NET 執行時*Blazor(WebAssembly)* 或伺服器端 ASP.NET 核心 (*Blazor伺服器*) 中。</span><span class="sxs-lookup"><span data-stu-id="5a12c-105"> is a web framework designed to run client-side in the browser on a [WebAssembly](https://webassembly.org/)-based .NET runtime (*Blazor WebAssembly*) or server-side in ASP.NET Core (*Blazor Server*).</span></span> <span data-ttu-id="5a12c-106">無論託管模型如何,應用程式和元件模型*都是相同的*。</span><span class="sxs-lookup"><span data-stu-id="5a12c-106">Regardless of the hosting model, the app and component models *are the same*.</span></span>

<span data-ttu-id="5a12c-107">要為本文中描述的託管模型建立專案,請參閱<xref:blazor/get-started>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-107">To create a project for the hosting models described in this article, see <xref:blazor/get-started>.</span></span>

<span data-ttu-id="5a12c-108">有關進階設定,請參<xref:blazor/hosting-model-configuration>閱 。</span><span class="sxs-lookup"><span data-stu-id="5a12c-108">For advanced configuration, see <xref:blazor/hosting-model-configuration>.</span></span>

## <a name="opno-locblazor-webassembly"></a>Blazor<span data-ttu-id="5a12c-109">網路組裝</span><span class="sxs-lookup"><span data-stu-id="5a12c-109"> WebAssembly</span></span>

<span data-ttu-id="5a12c-110">的主要Blazor託管模型是在 WebAssembly 上的瀏覽器中運行用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-110">The principal hosting model for Blazor is running client-side in the browser on WebAssembly.</span></span> <span data-ttu-id="5a12c-111">應用Blazor、其依賴項和 .NET 運行時將下載到瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-111">The Blazor app, its dependencies, and the .NET runtime are downloaded to the browser.</span></span> <span data-ttu-id="5a12c-112">應用程式會直接在瀏覽器 UI 執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="5a12c-112">The app is executed directly on the browser UI thread.</span></span> <span data-ttu-id="5a12c-113">UI 更新和事件處理在同一進程中進行。</span><span class="sxs-lookup"><span data-stu-id="5a12c-113">UI updates and event handling occur within the same process.</span></span> <span data-ttu-id="5a12c-114">應用的資產作為靜態檔部署到能夠向用戶端提供靜態內容的 Web 伺服器或服務。</span><span class="sxs-lookup"><span data-stu-id="5a12c-114">The app's assets are deployed as static files to a web server or service capable of serving static content to clients.</span></span>

<span data-ttu-id="5a12c-115">![BlazorWeb 組裝Blazor: 應用在瀏覽器內的 UI 線程上運行。](hosting-models/_static/blazor-webassembly.png)</span><span class="sxs-lookup"><span data-stu-id="5a12c-115">![Blazor WebAssembly: The Blazor app runs on a UI thread inside the browser.](hosting-models/_static/blazor-webassembly.png)</span></span>

<span data-ttu-id="5a12c-116">要使用用戶端Blazor託管模型創建應用,請使用**BlazorWebAssembly 應用程式**樣本[(dotnet 新 blazorwasm](/dotnet/core/tools/dotnet-new))。</span><span class="sxs-lookup"><span data-stu-id="5a12c-116">To create a Blazor app using the client-side hosting model, use the **Blazor WebAssembly App** template ([dotnet new blazorwasm](/dotnet/core/tools/dotnet-new)).</span></span>

<span data-ttu-id="5a12c-117">選擇**BlazorWebAssembly 應用**樣本後,您可以選擇透過選擇**ASP.NET 核心託管**複選框[(dotnet new blazorwasm -- 託管](/dotnet/core/tools/dotnet-new))來配置應用以使用ASP.NET核心後端介面。</span><span class="sxs-lookup"><span data-stu-id="5a12c-117">After selecting the **Blazor WebAssembly App** template, you have the option of configuring the app to use an ASP.NET Core backend by selecting the **ASP.NET Core hosted** check box ([dotnet new blazorwasm --hosted](/dotnet/core/tools/dotnet-new)).</span></span> <span data-ttu-id="5a12c-118">ASP.NET核心應用將Blazor應用服務到用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-118">The ASP.NET Core app serves the Blazor app to clients.</span></span> <span data-ttu-id="5a12c-119">WebAssemblyBlazor應用可以使用 Web API[SignalR](xref:signalr/introduction)呼<xref:tutorials/signalr-blazor-webassembly>叫或 () 透過網路與伺服器進行互動。</span><span class="sxs-lookup"><span data-stu-id="5a12c-119">The Blazor WebAssembly app can interact with the server over the network using web API calls or [SignalR](xref:signalr/introduction) (<xref:tutorials/signalr-blazor-webassembly>).</span></span>

<span data-ttu-id="5a12c-120">樣本包括處理以下情況`blazor.webassembly.js`的腳本:</span><span class="sxs-lookup"><span data-stu-id="5a12c-120">The templates include the `blazor.webassembly.js` script that handles:</span></span>

* <span data-ttu-id="5a12c-121">下載 .NET 運行時、應用和應用的依賴項。</span><span class="sxs-lookup"><span data-stu-id="5a12c-121">Downloading the .NET runtime, the app, and the app's dependencies.</span></span>
* <span data-ttu-id="5a12c-122">初始化運行應用的運行時。</span><span class="sxs-lookup"><span data-stu-id="5a12c-122">Initialization of the runtime to run the app.</span></span>

<span data-ttu-id="5a12c-123">Blazor WebAssembly 託管模型具有以下幾個優點:</span><span class="sxs-lookup"><span data-stu-id="5a12c-123">The Blazor WebAssembly hosting model offers several benefits:</span></span>

* <span data-ttu-id="5a12c-124">沒有 .NET 伺服器端依賴項。</span><span class="sxs-lookup"><span data-stu-id="5a12c-124">There's no .NET server-side dependency.</span></span> <span data-ttu-id="5a12c-125">應用程式在下載到用戶端後已完全正常運行。</span><span class="sxs-lookup"><span data-stu-id="5a12c-125">The app is fully functioning after it's downloaded to the client.</span></span>
* <span data-ttu-id="5a12c-126">充分利用客戶端資源和功能。</span><span class="sxs-lookup"><span data-stu-id="5a12c-126">Client resources and capabilities are fully leveraged.</span></span>
* <span data-ttu-id="5a12c-127">工作從伺服器卸載到用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-127">Work is offloaded from the server to the client.</span></span>
* <span data-ttu-id="5a12c-128">ASP.NET 酷網路伺服器不需要託管應用。</span><span class="sxs-lookup"><span data-stu-id="5a12c-128">An ASP.NET Core web server isn't required to host the app.</span></span> <span data-ttu-id="5a12c-129">可以使用無伺服器部署方案(例如,從CDN為應用提供服務)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-129">Serverless deployment scenarios are possible (for example, serving the app from a CDN).</span></span>

<span data-ttu-id="5a12c-130">Blazor Web 組裝託管有缺點:</span><span class="sxs-lookup"><span data-stu-id="5a12c-130">There are downsides to Blazor WebAssembly hosting:</span></span>

* <span data-ttu-id="5a12c-131">該應用程式僅限於瀏覽器的功能。</span><span class="sxs-lookup"><span data-stu-id="5a12c-131">The app is restricted to the capabilities of the browser.</span></span>
* <span data-ttu-id="5a12c-132">需要有能力的用戶端硬體和軟體(例如,Web 組裝支援)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-132">Capable client hardware and software (for example, WebAssembly support) is required.</span></span>
* <span data-ttu-id="5a12c-133">下載大小較大,並且載入應用需要更長的時間。</span><span class="sxs-lookup"><span data-stu-id="5a12c-133">Download size is larger, and apps take longer to load.</span></span>
* <span data-ttu-id="5a12c-134">.NET 運行時和工具支援不太成熟。</span><span class="sxs-lookup"><span data-stu-id="5a12c-134">.NET runtime and tooling support is less mature.</span></span> <span data-ttu-id="5a12c-135">例如[,.NET 標準](/dotnet/standard/net-standard)支持和調試中存在限制。</span><span class="sxs-lookup"><span data-stu-id="5a12c-135">For example, limitations exist in [.NET Standard](/dotnet/standard/net-standard) support and debugging.</span></span>

<span data-ttu-id="5a12c-136">管理系統Blazor應用程式模型支援[Docker 容器](/dotnet/standard/microservices-architecture/container-docker-introduction/index)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-136">The Blazor Hosted app model supports [Docker containers](/dotnet/standard/microservices-architecture/container-docker-introduction/index).</span></span> <span data-ttu-id="5a12c-137">右鍵按一下可視化工作室中的伺服器項目,然後選擇 **「添加** > **Docker 支援**」。。</span><span class="sxs-lookup"><span data-stu-id="5a12c-137">Right-click on the Server project in Visual Studio and select **Add** > **Docker Support**.</span></span>

## <a name="opno-locblazor-server"></a>Blazor<span data-ttu-id="5a12c-138">伺服器</span><span class="sxs-lookup"><span data-stu-id="5a12c-138"> Server</span></span>

<span data-ttu-id="5a12c-139">使用Blazor伺服器託管模型,應用將在伺服器上從ASP.NET核心應用內執行。</span><span class="sxs-lookup"><span data-stu-id="5a12c-139">With the Blazor Server hosting model, the app is executed on the server from within an ASP.NET Core app.</span></span> <span data-ttu-id="5a12c-140">UI 更新、事件處理和 JAVAScript[SignalR](xref:signalr/introduction)呼叫透過連接處理。</span><span class="sxs-lookup"><span data-stu-id="5a12c-140">UI updates, event handling, and JavaScript calls are handled over a [SignalR](xref:signalr/introduction) connection.</span></span>

<span data-ttu-id="5a12c-141">![瀏覽器透過SignalR連接與伺服器上的應用(託管在ASP.NET核心應用內)進行交互。](hosting-models/_static/blazor-server.png)</span><span class="sxs-lookup"><span data-stu-id="5a12c-141">![The browser interacts with the app (hosted inside of an ASP.NET Core app) on the server over a SignalR connection.](hosting-models/_static/blazor-server.png)</span></span>

<span data-ttu-id="5a12c-142">Blazor要使用Blazor伺服器託管模型創建應用,請使用ASP.NET核心**Blazor伺服器應用程式**範本[(dotnet 新的 blazorserver)。](/dotnet/core/tools/dotnet-new)</span><span class="sxs-lookup"><span data-stu-id="5a12c-142">To create a Blazor app using the Blazor Server hosting model, use the ASP.NET Core **Blazor Server App** template ([dotnet new blazorserver](/dotnet/core/tools/dotnet-new)).</span></span> <span data-ttu-id="5a12c-143">ASP.NET核心應用託管Blazor伺服器應用並SignalR創建用戶端連接的終結點。</span><span class="sxs-lookup"><span data-stu-id="5a12c-143">The ASP.NET Core app hosts the Blazor Server app and creates the SignalR endpoint where clients connect.</span></span>

<span data-ttu-id="5a12c-144">ASP.NET核心應用引用應用的`Startup`類別以新增:</span><span class="sxs-lookup"><span data-stu-id="5a12c-144">The ASP.NET Core app references the app's `Startup` class to add:</span></span>

* <span data-ttu-id="5a12c-145">伺服器端服務。</span><span class="sxs-lookup"><span data-stu-id="5a12c-145">Server-side services.</span></span>
* <span data-ttu-id="5a12c-146">到請求處理管道的應用。</span><span class="sxs-lookup"><span data-stu-id="5a12c-146">The app to the request handling pipeline.</span></span>

<span data-ttu-id="5a12c-147">文本`blazor.server.js`建立用戶端連接。</span><span class="sxs-lookup"><span data-stu-id="5a12c-147">The `blazor.server.js` script establishes the client connection.</span></span> <span data-ttu-id="5a12c-148">應用有責任根據需要保持和恢復應用狀態(例如,在網路連接丟失時)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-148">It's the app's responsibility to persist and restore app state as required (for example, in the event of a lost network connection).</span></span> <span data-ttu-id="5a12c-149">文本`blazor.server.js`從ASP.NET核心共用框架中的嵌入式資源提供。</span><span class="sxs-lookup"><span data-stu-id="5a12c-149">The `blazor.server.js` script is served from an embedded resource in the ASP.NET Core shared framework.</span></span>

<span data-ttu-id="5a12c-150">伺服器Blazor託管模型具有以下幾個優點:</span><span class="sxs-lookup"><span data-stu-id="5a12c-150">The Blazor Server hosting model offers several benefits:</span></span>

* <span data-ttu-id="5a12c-151">下載大小明顯小於BlazorWebAssembly 應用,並且該應用載入速度更快。</span><span class="sxs-lookup"><span data-stu-id="5a12c-151">Download size is significantly smaller than a Blazor WebAssembly app, and the app loads much faster.</span></span>
* <span data-ttu-id="5a12c-152">該應用程式充分利用了伺服器功能,包括使用任何.NET Core 相容 API。</span><span class="sxs-lookup"><span data-stu-id="5a12c-152">The app takes full advantage of server capabilities, including use of any .NET Core compatible APIs.</span></span>
* <span data-ttu-id="5a12c-153">伺服器上的 .NET Core 用於運行應用,因此現有的 .NET 工具(如調試)按預期工作。</span><span class="sxs-lookup"><span data-stu-id="5a12c-153">.NET Core on the server is used to run the app, so existing .NET tooling, such as debugging, works as expected.</span></span>
* <span data-ttu-id="5a12c-154">支援精簡用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-154">Thin clients are supported.</span></span> <span data-ttu-id="5a12c-155">例如,Blazor伺服器應用適用於不支援 WebAssembly 和資源受限的設備上的瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-155">For example, Blazor Server apps work with browsers that don't support WebAssembly and on resource-constrained devices.</span></span>
* <span data-ttu-id="5a12c-156">應用程式的 .NET/C++ 代碼庫(包括應用的元件代碼)不提供給用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-156">The app's .NET/C# code base, including the app's component code, isn't served to clients.</span></span>

<span data-ttu-id="5a12c-157">Blazor伺服器託管有缺點:</span><span class="sxs-lookup"><span data-stu-id="5a12c-157">There are downsides to Blazor Server hosting:</span></span>

* <span data-ttu-id="5a12c-158">通常存在更高的延遲。</span><span class="sxs-lookup"><span data-stu-id="5a12c-158">Higher latency usually exists.</span></span> <span data-ttu-id="5a12c-159">每個使用者交互都涉及網路躍點。</span><span class="sxs-lookup"><span data-stu-id="5a12c-159">Every user interaction involves a network hop.</span></span>
* <span data-ttu-id="5a12c-160">沒有離線支援。</span><span class="sxs-lookup"><span data-stu-id="5a12c-160">There's no offline support.</span></span> <span data-ttu-id="5a12c-161">如果用戶端連接失敗,應用將停止工作。</span><span class="sxs-lookup"><span data-stu-id="5a12c-161">If the client connection fails, the app stops working.</span></span>
* <span data-ttu-id="5a12c-162">對於許多用戶的應用來說,可擴充性具有挑戰性。</span><span class="sxs-lookup"><span data-stu-id="5a12c-162">Scalability is challenging for apps with many users.</span></span> <span data-ttu-id="5a12c-163">伺服器必須管理多個用戶端連接並處理用戶端狀態。</span><span class="sxs-lookup"><span data-stu-id="5a12c-163">The server must manage multiple client connections and handle client state.</span></span>
* <span data-ttu-id="5a12c-164">需要ASP.NET核心伺服器才能為應用提供服務。</span><span class="sxs-lookup"><span data-stu-id="5a12c-164">An ASP.NET Core server is required to serve the app.</span></span> <span data-ttu-id="5a12c-165">無法使用無伺服器部署方案(例如,從CDN為應用提供服務)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-165">Serverless deployment scenarios aren't possible (for example, serving the app from a CDN).</span></span>

<span data-ttu-id="5a12c-166">伺服器Blazor應用模型支援[Docker 容器](/dotnet/standard/microservices-architecture/container-docker-introduction/index)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-166">The Blazor Server app model supports [Docker containers](/dotnet/standard/microservices-architecture/container-docker-introduction/index).</span></span> <span data-ttu-id="5a12c-167">右鍵單擊可視化工作室中的項目,然後選擇 **「添加** > **Docker 支援**」。。</span><span class="sxs-lookup"><span data-stu-id="5a12c-167">Right-click on the project in Visual Studio and select **Add** > **Docker Support**.</span></span>

### <a name="comparison-to-server-rendered-ui"></a><span data-ttu-id="5a12c-168">與伺服器呈現的 UI 進行比較</span><span class="sxs-lookup"><span data-stu-id="5a12c-168">Comparison to server-rendered UI</span></span>

<span data-ttu-id="5a12c-169">瞭解Blazor伺服器應用的一種方法是瞭解它與使用 Razor 檢視或 Razor 頁面在 ASP.NET 核心應用中呈現 UI 的傳統模型有何不同。</span><span class="sxs-lookup"><span data-stu-id="5a12c-169">One way to understand Blazor Server apps is to understand how it differs from traditional models for rendering UI in ASP.NET Core apps using Razor views or Razor Pages.</span></span> <span data-ttu-id="5a12c-170">這兩種模型都使用 Razor 語言來描述 HTML 內容,但它們在呈現標記的方式上存在顯著差異。</span><span class="sxs-lookup"><span data-stu-id="5a12c-170">Both models use the Razor language to describe HTML content, but they significantly differ in how markup is rendered.</span></span>

<span data-ttu-id="5a12c-171">呈現 Razor 頁面或檢視時,每行 Razor 代碼都會以文本形式發出 HTML。</span><span class="sxs-lookup"><span data-stu-id="5a12c-171">When a Razor Page or view is rendered, every line of Razor code emits HTML in text form.</span></span> <span data-ttu-id="5a12c-172">呈現後,伺服器將釋放頁面或視圖實例,包括生成的任何狀態。</span><span class="sxs-lookup"><span data-stu-id="5a12c-172">After rendering, the server disposes of the page or view instance, including any state that was produced.</span></span> <span data-ttu-id="5a12c-173">當發生另一個頁面請求時,例如伺服器驗證失敗並顯示驗證摘要時:</span><span class="sxs-lookup"><span data-stu-id="5a12c-173">When another request for the page occurs, for instance when server validation fails and the validation summary is displayed:</span></span>

* <span data-ttu-id="5a12c-174">整個頁面將再次重新呈現為 HTML 文本。</span><span class="sxs-lookup"><span data-stu-id="5a12c-174">The entire page is rerendered to HTML text again.</span></span>
* <span data-ttu-id="5a12c-175">該頁將發送到用戶端。</span><span class="sxs-lookup"><span data-stu-id="5a12c-175">The page is sent to the client.</span></span>

<span data-ttu-id="5a12c-176">應用Blazor由稱為*元件*的 UI 的可重用元素組成。</span><span class="sxs-lookup"><span data-stu-id="5a12c-176">A Blazor app is composed of reusable elements of UI called *components*.</span></span> <span data-ttu-id="5a12c-177">元件包含 C# 代碼、標記和其他元件。</span><span class="sxs-lookup"><span data-stu-id="5a12c-177">A component contains C# code, markup, and other components.</span></span> <span data-ttu-id="5a12c-178">顯示元件時,Blazor產生類似於 HTML 或 XML 文件物件模型 (DOM) 的包含元件的圖形。</span><span class="sxs-lookup"><span data-stu-id="5a12c-178">When a component is rendered, Blazor produces a graph of the included components similar to an HTML or XML Document Object Model (DOM).</span></span> <span data-ttu-id="5a12c-179">此圖形包括屬性和欄位中持有的元件狀態。</span><span class="sxs-lookup"><span data-stu-id="5a12c-179">This graph includes component state held in properties and fields.</span></span> Blazor<span data-ttu-id="5a12c-180">計算元件圖以生成標記的二進位表示形式。</span><span class="sxs-lookup"><span data-stu-id="5a12c-180"> evaluates the component graph to produce a binary representation of the markup.</span></span> <span data-ttu-id="5a12c-181">二進位格式可以是:</span><span class="sxs-lookup"><span data-stu-id="5a12c-181">The binary format can be:</span></span>

* <span data-ttu-id="5a12c-182">轉換為 HTML 文本(&dagger;在預渲染期間)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-182">Turned into HTML text (during prerendering&dagger;).</span></span>
* <span data-ttu-id="5a12c-183">用於在常規渲染期間有效地更新標記。</span><span class="sxs-lookup"><span data-stu-id="5a12c-183">Used to efficiently update the markup during regular rendering.</span></span>

<span data-ttu-id="5a12c-184">&dagger;*預成*&ndash;一個使用者的 Razor 元件在伺服器上編譯為靜態 HTML 並發送到用戶端,並呈現給使用者。</span><span class="sxs-lookup"><span data-stu-id="5a12c-184">&dagger;*Prerendering* &ndash; The requested Razor component is compiled on the server into static HTML and sent to the client, where it's rendered to the user.</span></span> <span data-ttu-id="5a12c-185">在用戶端和伺服器之間建立連接后,元件的靜態預渲染元素將被互動式元素替換。</span><span class="sxs-lookup"><span data-stu-id="5a12c-185">After the connection is made between the client and the server, the component's static prerendered elements are replaced with interactive elements.</span></span> <span data-ttu-id="5a12c-186">預渲染使應用對用戶的反應更快。</span><span class="sxs-lookup"><span data-stu-id="5a12c-186">Prerendering makes the app feel more responsive to the user.</span></span>

<span data-ttu-id="5a12c-187">的BlazorUI 更新由:</span><span class="sxs-lookup"><span data-stu-id="5a12c-187">A UI update in Blazor is triggered by:</span></span>

* <span data-ttu-id="5a12c-188">使用者互動,例如選擇按鈕。</span><span class="sxs-lookup"><span data-stu-id="5a12c-188">User interaction, such as selecting a button.</span></span>
* <span data-ttu-id="5a12c-189">應用觸發器,如計時器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-189">App triggers, such as a timer.</span></span>

<span data-ttu-id="5a12c-190">重新渲染圖形,並計算 UI*差異*(差異)。</span><span class="sxs-lookup"><span data-stu-id="5a12c-190">The graph is rerendered, and a UI *diff* (difference) is calculated.</span></span> <span data-ttu-id="5a12c-191">此差異是更新用戶端上的 UI 所需的最小 DOM 編輯集。</span><span class="sxs-lookup"><span data-stu-id="5a12c-191">This diff is the smallest set of DOM edits required to update the UI on the client.</span></span> <span data-ttu-id="5a12c-192">差異以二進位格式發送到用戶端,並由瀏覽器應用。</span><span class="sxs-lookup"><span data-stu-id="5a12c-192">The diff is sent to the client in a binary format and applied by the browser.</span></span>

<span data-ttu-id="5a12c-193">使用者在用戶端上導航后釋放元件。</span><span class="sxs-lookup"><span data-stu-id="5a12c-193">A component is disposed after the user navigates away from it on the client.</span></span> <span data-ttu-id="5a12c-194">當使用者與元件交互時,元件的狀態(服務、資源)必須保持在伺服器的記憶體中。</span><span class="sxs-lookup"><span data-stu-id="5a12c-194">While a user is interacting with a component, the component's state (services, resources) must be held in the server's memory.</span></span> <span data-ttu-id="5a12c-195">由於伺服器可能同時維護許多元件的狀態,因此記憶體耗盡是必須解決的問題。</span><span class="sxs-lookup"><span data-stu-id="5a12c-195">Because the state of many components might be maintained by the server concurrently, memory exhaustion is a concern that must be addressed.</span></span> <span data-ttu-id="5a12c-196">有關如何創作Blazor伺服器應用以確保最佳使用伺服器記憶體的指導,請參閱<xref:security/blazor/server>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-196">For guidance on how to author a Blazor Server app to ensure the best use of server memory, see <xref:security/blazor/server>.</span></span>

### <a name="circuits"></a><span data-ttu-id="5a12c-197">電路</span><span class="sxs-lookup"><span data-stu-id="5a12c-197">Circuits</span></span>

<span data-ttu-id="5a12c-198">伺服器應用程式構建在[ASP.NETSignalR核心](xref:signalr/introduction)之上Blazor。</span><span class="sxs-lookup"><span data-stu-id="5a12c-198">A Blazor Server app is built on top of [ASP.NET Core SignalR](xref:signalr/introduction).</span></span> <span data-ttu-id="5a12c-199">每個客戶端透過一個或多個稱為電SignalR路 連線與伺服器*通訊*。</span><span class="sxs-lookup"><span data-stu-id="5a12c-199">Each client communicates to the server over one or more SignalR connections called a *circuit*.</span></span> <span data-ttu-id="5a12c-200">電路是Blazor可以容忍臨時網路中SignalR斷 的連接的抽象。</span><span class="sxs-lookup"><span data-stu-id="5a12c-200">A circuit is Blazor's abstraction over SignalR connections that can tolerate temporary network interruptions.</span></span> <span data-ttu-id="5a12c-201">當Blazor用戶端看到SignalR連接斷開連接時,它會嘗試使用SignalR新 連接重新連接到伺服器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-201">When a Blazor client sees that the SignalR connection is disconnected, it attempts to reconnect to the server using a new SignalR connection.</span></span>

<span data-ttu-id="5a12c-202">連接到Blazor伺服器應用的每個瀏覽器螢幕(瀏覽器選項卡或 iframe)SignalR都使用 連接。</span><span class="sxs-lookup"><span data-stu-id="5a12c-202">Each browser screen (browser tab or iframe) that is connected to a Blazor Server app uses a SignalR connection.</span></span> <span data-ttu-id="5a12c-203">與典型的伺服器呈現應用相比,這是另一個重要區別。</span><span class="sxs-lookup"><span data-stu-id="5a12c-203">This is yet another important distinction compared to typical server-rendered apps.</span></span> <span data-ttu-id="5a12c-204">在伺服器呈現的應用中,在多個瀏覽器螢幕中打開同一應用通常不會轉化為伺服器上的其他資源需求。</span><span class="sxs-lookup"><span data-stu-id="5a12c-204">In a server-rendered app, opening the same app in multiple browser screens typically doesn't translate into additional resource demands on the server.</span></span> <span data-ttu-id="5a12c-205">在BlazorServer 應用中,每個瀏覽器螢幕都需要由伺服器管理的單獨的電路和元件狀態的單獨實例。</span><span class="sxs-lookup"><span data-stu-id="5a12c-205">In a Blazor Server app, each browser screen requires a separate circuit and separate instances of component state to be managed by the server.</span></span>

Blazor<span data-ttu-id="5a12c-206">考慮關閉瀏覽器選項卡或以*正常*終止形式導航到外部 URL。</span><span class="sxs-lookup"><span data-stu-id="5a12c-206"> considers closing a browser tab or navigating to an external URL a *graceful* termination.</span></span> <span data-ttu-id="5a12c-207">如果正常終止,電路和相關資源將立即釋放。</span><span class="sxs-lookup"><span data-stu-id="5a12c-207">In the event of a graceful termination, the circuit and associated resources are immediately released.</span></span> <span data-ttu-id="5a12c-208">用戶端也可能非正常斷開連接,例如由於網路中斷。</span><span class="sxs-lookup"><span data-stu-id="5a12c-208">A client may also disconnect non-gracefully, for instance due to a network interruption.</span></span> Blazor<span data-ttu-id="5a12c-209">伺服器在可配置的間隔記憶體儲存斷開連接的電路,以允許用戶端重新連接。</span><span class="sxs-lookup"><span data-stu-id="5a12c-209"> Server stores disconnected circuits for a configurable interval to allow the client to reconnect.</span></span>

Blazor<span data-ttu-id="5a12c-210">伺服器允許代碼定義*電路處理程式*,它允許在更改使用者電路的狀態時運行代碼。</span><span class="sxs-lookup"><span data-stu-id="5a12c-210"> Server allows code to define a *circuit handler*, which allows running code on changes to the state of a user's circuit.</span></span> <span data-ttu-id="5a12c-211">如需詳細資訊，請參閱 <xref:blazor/advanced-scenarios#blazor-server-circuit-handler>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-211">For more information, see <xref:blazor/advanced-scenarios#blazor-server-circuit-handler>.</span></span>

### <a name="ui-latency"></a><span data-ttu-id="5a12c-212">UI 延遲</span><span class="sxs-lookup"><span data-stu-id="5a12c-212">UI Latency</span></span>

<span data-ttu-id="5a12c-213">UI 延遲是從啟動的操作到更新 UI 所需的時間。</span><span class="sxs-lookup"><span data-stu-id="5a12c-213">UI latency is the time it takes from an initiated action to the time the UI is updated.</span></span> <span data-ttu-id="5a12c-214">對於應用來說,UI 延遲的較小值對於用戶進行回應是勢在必行的。</span><span class="sxs-lookup"><span data-stu-id="5a12c-214">Smaller values for UI latency are imperative for an app to feel responsive to a user.</span></span> <span data-ttu-id="5a12c-215">在BlazorServer 應用中,每個操作都發送到伺服器,處理併發送回 UI 差異。</span><span class="sxs-lookup"><span data-stu-id="5a12c-215">In a Blazor Server app, each action is sent to the server, processed, and a UI diff is sent back.</span></span> <span data-ttu-id="5a12c-216">因此,UI 延遲是處理操作時網路延遲和伺服器延遲的總和。</span><span class="sxs-lookup"><span data-stu-id="5a12c-216">Consequently, UI latency is the sum of network latency and the server latency in processing the action.</span></span>

<span data-ttu-id="5a12c-217">對於僅限於私有公司網路的業務線應用,通常無法察覺到網路延遲對使用者感知延遲的影響。</span><span class="sxs-lookup"><span data-stu-id="5a12c-217">For a line of business app that's limited to a private corporate network, the effect on user perceptions of latency due to network latency are usually imperceptible.</span></span> <span data-ttu-id="5a12c-218">對於通過 Internet 部署的應用,延遲可能會對使用者造成明顯注意,尤其是在使用者在地理位置上分佈廣泛時。</span><span class="sxs-lookup"><span data-stu-id="5a12c-218">For an app deployed over the Internet, latency may become noticeable to users, particularly if users are widely distributed geographically.</span></span>

<span data-ttu-id="5a12c-219">記憶體使用還會導致應用延遲。</span><span class="sxs-lookup"><span data-stu-id="5a12c-219">Memory usage can also contribute to app latency.</span></span> <span data-ttu-id="5a12c-220">記憶體使用量增加會導致頻繁的垃圾回收或將記憶體分到磁碟,這兩者都降低了應用性能,從而增加了 UI 延遲。</span><span class="sxs-lookup"><span data-stu-id="5a12c-220">Increased memory usage results in frequent garbage collection or paging memory to disk, both of which degrade app performance and consequently increase UI latency.</span></span> <span data-ttu-id="5a12c-221">如需詳細資訊，請參閱 <xref:security/blazor/server>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-221">For more information, see <xref:security/blazor/server>.</span></span>

Blazor<span data-ttu-id="5a12c-222">應優化伺服器應用,通過減少網路延遲和記憶體使用量來最大程度地減少 UI 延遲。</span><span class="sxs-lookup"><span data-stu-id="5a12c-222"> Server apps should be optimized to minimize UI latency by reducing network latency and memory usage.</span></span> <span data-ttu-id="5a12c-223">有關測量網路延遲的方法,請參閱<xref:host-and-deploy/blazor/server#measure-network-latency>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-223">For an approach to measuring network latency, see <xref:host-and-deploy/blazor/server#measure-network-latency>.</span></span> <span data-ttu-id="5a12c-224">有關BlazorSignalR和 的詳細資訊,請參閱:</span><span class="sxs-lookup"><span data-stu-id="5a12c-224">For more information on SignalR and Blazor, see:</span></span>

* <xref:host-and-deploy/blazor/server>
* <xref:security/blazor/server>

### <a name="connection-to-the-server"></a><span data-ttu-id="5a12c-225">連線到伺服器</span><span class="sxs-lookup"><span data-stu-id="5a12c-225">Connection to the server</span></span>

Blazor<span data-ttu-id="5a12c-226">伺服器應用需要與伺服器SignalR的有效連接。</span><span class="sxs-lookup"><span data-stu-id="5a12c-226"> Server apps require an active SignalR connection to the server.</span></span> <span data-ttu-id="5a12c-227">如果連接丟失,應用將嘗試重新連接到伺服器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-227">If the connection is lost, the app attempts to reconnect to the server.</span></span> <span data-ttu-id="5a12c-228">只要客戶端的狀態仍在記憶體中,用戶端會話將恢復而不丟失狀態。</span><span class="sxs-lookup"><span data-stu-id="5a12c-228">As long as the client's state is still in memory, the client session resumes without losing state.</span></span>

<span data-ttu-id="5a12c-229">伺服器Blazor應用預先呈現以回應第一個用戶端請求,該請求在伺服器上設置 UI 狀態。</span><span class="sxs-lookup"><span data-stu-id="5a12c-229">A Blazor Server app prerenders in response to the first client request, which sets up the UI state on the server.</span></span> <span data-ttu-id="5a12c-230">當用戶端嘗試建立連接時,SignalR客戶端必須重新連接到同一伺服器。</span><span class="sxs-lookup"><span data-stu-id="5a12c-230">When the client attempts to create a SignalR connection, the client must reconnect to the same server.</span></span> Blazor<span data-ttu-id="5a12c-231">使用多後端伺服器的伺服器套用應該SignalR為 連線來*黏性作業階段*。</span><span class="sxs-lookup"><span data-stu-id="5a12c-231"> Server apps that use more than one backend server should implement *sticky sessions* for SignalR connections.</span></span>

<span data-ttu-id="5a12c-232">我們建議將[AzureSignalR服務](/azure/azure-signalr)用於Blazor伺服器應用。</span><span class="sxs-lookup"><span data-stu-id="5a12c-232">We recommend using the [Azure SignalR Service](/azure/azure-signalr) for Blazor Server apps.</span></span> <span data-ttu-id="5a12c-233">該服務允許將Blazor伺服器應用擴展到大量併SignalR發 連接。</span><span class="sxs-lookup"><span data-stu-id="5a12c-233">The service allows for scaling up a Blazor Server app to a large number of concurrent SignalR connections.</span></span> <span data-ttu-id="5a12c-234">透過此選項SignalR`ServerStickyMode`或設定值設定為,為 Azure 服務啟用黏滯工作階段`Required`。</span><span class="sxs-lookup"><span data-stu-id="5a12c-234">Sticky sessions are enabled for the Azure SignalR Service by setting the service's `ServerStickyMode` option or configuration value to `Required`.</span></span> <span data-ttu-id="5a12c-235">如需詳細資訊，請參閱 <xref:host-and-deploy/blazor/server#signalr-configuration>。</span><span class="sxs-lookup"><span data-stu-id="5a12c-235">For more information, see <xref:host-and-deploy/blazor/server#signalr-configuration>.</span></span>

<span data-ttu-id="5a12c-236">使用 IIS 時,將使用應用程式請求路由啟用粘滯會話。</span><span class="sxs-lookup"><span data-stu-id="5a12c-236">When using IIS, sticky sessions are enabled with Application Request Routing.</span></span> <span data-ttu-id="5a12c-237">有關詳細資訊,請參閱[使用應用程式請求路由](/iis/extensions/configuring-application-request-routing-arr/http-load-balancing-using-application-request-routing)的 HTTP 負載平衡。</span><span class="sxs-lookup"><span data-stu-id="5a12c-237">For more information, see [HTTP Load Balancing using Application Request Routing](/iis/extensions/configuring-application-request-routing-arr/http-load-balancing-using-application-request-routing).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="5a12c-238">其他資源</span><span class="sxs-lookup"><span data-stu-id="5a12c-238">Additional resources</span></span>

* <xref:blazor/get-started>
* <xref:signalr/introduction>
* <xref:blazor/hosting-model-configuration>
* <xref:tutorials/signalr-blazor-webassembly>
