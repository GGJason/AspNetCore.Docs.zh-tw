---
title: 使用 ASP.NET Core Blazor WebAssembly 建立漸進式 Web 應用程式
author: guardrex
description: 瞭解如何建立以 Blazor為基礎的漸進式 Web 應用程式（Pwa），這是使用新式瀏覽器功能的 Web 應用程式，其行為就像桌面應用程式。
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083717"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="13077-103">使用 ASP.NET Core Blazor WebAssembly 建立漸進式 Web 應用程式</span><span class="sxs-lookup"><span data-stu-id="13077-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="13077-104">作者：[Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="13077-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="13077-105">漸進式 Web 應用程式（PWA）是以 web 為基礎的應用程式，其使用新式瀏覽器 Api 和功能，其行為就像桌面應用程式。</span><span class="sxs-lookup"><span data-stu-id="13077-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="13077-106">這些功能可以包括：</span><span class="sxs-lookup"><span data-stu-id="13077-106">These capabilities can include:</span></span>

* <span data-ttu-id="13077-107">離線工作並一律立即載入，獨立于網路速度</span><span class="sxs-lookup"><span data-stu-id="13077-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="13077-108">能夠在自己的應用程式視窗中執行，而不只是瀏覽器視窗</span><span class="sxs-lookup"><span data-stu-id="13077-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="13077-109">從主機作業系統（OS） [開始] 功能表、[停駐] 或 [主畫面] 啟動</span><span class="sxs-lookup"><span data-stu-id="13077-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="13077-110">從後端伺服器接收推播通知，即使使用者未使用應用程式</span><span class="sxs-lookup"><span data-stu-id="13077-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="13077-111">在背景中自動更新</span><span class="sxs-lookup"><span data-stu-id="13077-111">Automatically updating in the background</span></span>

<span data-ttu-id="13077-112">使用者可能會先在網頁瀏覽器中探索及使用應用程式，就像任何其他單頁應用程式（SPA），然後在其 OS 中安裝它並啟用推播通知。</span><span class="sxs-lookup"><span data-stu-id="13077-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="13077-113">這就是我們使用「*漸進*」一詞的原因。</span><span class="sxs-lookup"><span data-stu-id="13077-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="13077-114"> WebAssembly 是真正以標準為基礎的用戶端 web 應用程式平臺，因此可以使用任何瀏覽器 API，包括以上所列功能所需的 PWA Api。</span><span class="sxs-lookup"><span data-stu-id="13077-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="13077-115">它可以離線工作，就像任何其他用戶端 web 技術一樣。</span><span class="sxs-lookup"><span data-stu-id="13077-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="13077-116">PWA 範本</span><span class="sxs-lookup"><span data-stu-id="13077-116">PWA template</span></span>

<span data-ttu-id="13077-117">建立新的 Blazor WebAssembly 應用程式時，系統會提供您新增 PWA 功能的選項。</span><span class="sxs-lookup"><span data-stu-id="13077-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="13077-118">在 Visual Studio 中，會在 [專案建立] 對話方塊中將選項指定為核取方塊：</span><span class="sxs-lookup"><span data-stu-id="13077-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="13077-120">如果您要在命令列上建立專案，您可以使用 `--pwa` 旗標。</span><span class="sxs-lookup"><span data-stu-id="13077-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="13077-121">例如：</span><span class="sxs-lookup"><span data-stu-id="13077-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="13077-122">在這兩種情況下，您都可以視需要將它與「ASP.NET Core 裝載」選項結合，但不需要這麼做。</span><span class="sxs-lookup"><span data-stu-id="13077-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="13077-123">PWA 功能與裝載模型無關。</span><span class="sxs-lookup"><span data-stu-id="13077-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="13077-124">安裝和應用程式資訊清單</span><span class="sxs-lookup"><span data-stu-id="13077-124">Installation and app manifest</span></span>

<span data-ttu-id="13077-125">流覽使用 PWA 範本選項建立的應用程式時，使用者可以選擇將應用程式安裝到其作業系統的 [開始] 功能表、[停駐] 或 [主畫面]。</span><span class="sxs-lookup"><span data-stu-id="13077-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="13077-126">此選項的呈現方式取決於使用者的瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="13077-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="13077-127">例如，使用以桌面 Chromium 為基礎的瀏覽器（例如 Edge 或 Chrome）時，URL 列中會出現 [*新增*] 按鈕：</span><span class="sxs-lookup"><span data-stu-id="13077-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="13077-129">在 iOS 上，訪客可以使用 Safari 的 [*共用*] 按鈕和其 [*新增至 Homescreen* ] 選項來安裝 PWA。</span><span class="sxs-lookup"><span data-stu-id="13077-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="13077-130">在適用于 Android 的 Chrome 上，使用者應按右上角的 [*功能表*] 按鈕，然後選擇 [*新增到主畫面*]。</span><span class="sxs-lookup"><span data-stu-id="13077-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="13077-131">安裝之後，應用程式會出現在自己的視窗中，而不會有任何網址列。</span><span class="sxs-lookup"><span data-stu-id="13077-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![image](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="13077-133">若要自訂視窗的標題、色彩配置、圖示或其他詳細資料，請參閱專案的*wwwroot*目錄中的檔案 `manifest.json`。</span><span class="sxs-lookup"><span data-stu-id="13077-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="13077-134">此檔案的架構是由 web 標準所定義。</span><span class="sxs-lookup"><span data-stu-id="13077-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="13077-135">如需詳細檔，請參閱 https://developer.mozilla.org/docs/Web/Manifest。</span><span class="sxs-lookup"><span data-stu-id="13077-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="13077-136">離線支援</span><span class="sxs-lookup"><span data-stu-id="13077-136">Offline support</span></span>

<span data-ttu-id="13077-137">根據預設，使用 PWA 範本選項建立的應用程式支援離線執行。</span><span class="sxs-lookup"><span data-stu-id="13077-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="13077-138">使用者必須先在上線時造訪應用程式，瀏覽器才會自動下載並快取離線操作所需的所有資源。</span><span class="sxs-lookup"><span data-stu-id="13077-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13077-139">只有*已發佈*的應用程式才會啟用離線支援。</span><span class="sxs-lookup"><span data-stu-id="13077-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="13077-140">在開發期間不會啟用此功能。</span><span class="sxs-lookup"><span data-stu-id="13077-140">It is not enabled during development.</span></span> <span data-ttu-id="13077-141">這是因為它會干擾進行變更和測試的一般開發週期。</span><span class="sxs-lookup"><span data-stu-id="13077-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="13077-142">如果您想要提供已啟用離線的 PWA，必須瞭解[幾個重要的警告和注意事項](#caveats-for-offline-pwas)。</span><span class="sxs-lookup"><span data-stu-id="13077-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="13077-143">這些是離線 Pwa 的固有特性，而不是 Blazor特定的。</span><span class="sxs-lookup"><span data-stu-id="13077-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="13077-144">請務必閱讀並瞭解這些注意事項，然後才對啟用離線的應用程式的運作方式進行假設。</span><span class="sxs-lookup"><span data-stu-id="13077-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="13077-145">若要查看離線支援的運作方式，請先[發佈您的應用程式](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)，並將它裝載在支援 HTTPS 的伺服器上。</span><span class="sxs-lookup"><span data-stu-id="13077-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="13077-146">當您造訪應用程式時，您應該能夠開啟瀏覽器的開發工具，並確認已為您的主機註冊*服務背景工作角色*：</span><span class="sxs-lookup"><span data-stu-id="13077-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="13077-148">此外，如果您重載頁面，則在 [*網路*] 索引標籤上，您應該會看到載入頁面所需的所有資源都是從*服務背景工作*或*記憶體*快取取得：</span><span class="sxs-lookup"><span data-stu-id="13077-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="13077-150">這會顯示瀏覽器不依賴網路存取來載入您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="13077-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="13077-151">若要確認這種情況，您可以關閉 web 伺服器，或指示瀏覽器模擬離線模式：</span><span class="sxs-lookup"><span data-stu-id="13077-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="13077-153">現在，即使沒有 web 伺服器的存取權，您也應該能夠重載頁面，並查看您的應用程式仍會載入並執行。</span><span class="sxs-lookup"><span data-stu-id="13077-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="13077-154">同樣地，即使您模擬非常緩慢的網路連線，您的頁面仍會立即載入，因為它是與網路無關的載入。</span><span class="sxs-lookup"><span data-stu-id="13077-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="13077-155">服務背景工作</span><span class="sxs-lookup"><span data-stu-id="13077-155">Service worker</span></span>

<span data-ttu-id="13077-156">您可使用服務工作者來完成離線支援。</span><span class="sxs-lookup"><span data-stu-id="13077-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="13077-157">這是 web 標準，不是 Blazor特定的。</span><span class="sxs-lookup"><span data-stu-id="13077-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="13077-158">如需服務工作者的相關檔，請參閱 https://developer.mozilla.org/docs/Web/API/Service_Worker_API。</span><span class="sxs-lookup"><span data-stu-id="13077-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="13077-159">若要深入瞭解服務工作者的常見使用模式，請參閱[服務工作者生命週期](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)的絕佳文章。</span><span class="sxs-lookup"><span data-stu-id="13077-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="13077-160">的 PWA 範本會產生兩個服務工作者檔案：</span><span class="sxs-lookup"><span data-stu-id="13077-160">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="13077-161">*wwwroot/service-worker*，在開發期間使用</span><span class="sxs-lookup"><span data-stu-id="13077-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="13077-162">*wwwroot/service-worker. 已發行的 .js*，會在您的應用程式發行後使用</span><span class="sxs-lookup"><span data-stu-id="13077-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="13077-163">如果您想要在這兩個檔案之間共用邏輯，請考慮新增第三個 JavaScript 檔案來保存通用邏輯，並使用[`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts)將該邏輯載入這兩個檔案。</span><span class="sxs-lookup"><span data-stu-id="13077-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="13077-164">快取優先提取策略</span><span class="sxs-lookup"><span data-stu-id="13077-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="13077-165">內建的*service-worker。已發行的 .js*服務工作者會使用快取*優先*策略來解析要求。</span><span class="sxs-lookup"><span data-stu-id="13077-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="13077-166">這表示不論使用者是否有網路存取權，或伺服器上是否有較新的內容，一律會偏好傳回快取的內容（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="13077-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="13077-167">這是很重要的原因有兩個：</span><span class="sxs-lookup"><span data-stu-id="13077-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="13077-168">**它可確保可靠性。**</span><span class="sxs-lookup"><span data-stu-id="13077-168">**It ensures reliability.**</span></span> <span data-ttu-id="13077-169">網路存取不是布林值狀態。</span><span class="sxs-lookup"><span data-stu-id="13077-169">Network access is not a boolean state.</span></span> <span data-ttu-id="13077-170">使用者不只是「線上」或「離線」。</span><span class="sxs-lookup"><span data-stu-id="13077-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="13077-171">事實上，使用者的裝置可能會相信它已上線，但網路可能會變得很慢，而無法等待。</span><span class="sxs-lookup"><span data-stu-id="13077-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="13077-172">或者，網路可能會傳回特定 Url 的無效結果，例如，有一個目前正在封鎖或重新導向特定要求的「正在進行」的驗證 WIFI 入口網站。</span><span class="sxs-lookup"><span data-stu-id="13077-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="13077-173">這就是為什麼瀏覽器的 `navigator.onLine` API 不可靠，而且不應該依賴。</span><span class="sxs-lookup"><span data-stu-id="13077-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="13077-174">**它可確保正確性。**</span><span class="sxs-lookup"><span data-stu-id="13077-174">**It ensures correctness.**</span></span> <span data-ttu-id="13077-175">建立離線資源的快取時，服務工作者會使用內容雜湊來確保它已在單一時刻取得完整且自我一致的資源快照集。</span><span class="sxs-lookup"><span data-stu-id="13077-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="13077-176">然後，此快取會當做不可部分完成的單位來使用。</span><span class="sxs-lookup"><span data-stu-id="13077-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="13077-177">在此情況下，並不會要求網路提供較新的資源，因為您想要的是您已快取的版本。</span><span class="sxs-lookup"><span data-stu-id="13077-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="13077-178">其他任何風險不一致和不相容（例如，嘗試使用未一起編譯的 .NET 元件版本）。</span><span class="sxs-lookup"><span data-stu-id="13077-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="13077-179">背景更新</span><span class="sxs-lookup"><span data-stu-id="13077-179">Background updates</span></span>

<span data-ttu-id="13077-180">作為心理模型，您可以將離線優先的 PWA 視為行為，就像可以安裝的行動應用程式。</span><span class="sxs-lookup"><span data-stu-id="13077-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="13077-181">它一律會立即啟動，而不考慮網路連線，但已安裝的應用程式邏輯來自可能不是最新版本的時間點快照集。</span><span class="sxs-lookup"><span data-stu-id="13077-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="13077-182">Blazor PWA 範本會產生應用程式，以便在使用者造訪並具有運作中的網路連線時，自動嘗試在背景中自行更新。</span><span class="sxs-lookup"><span data-stu-id="13077-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="13077-183">其運作方式如下：</span><span class="sxs-lookup"><span data-stu-id="13077-183">The way this works is as follows:</span></span>

* <span data-ttu-id="13077-184">在編譯期間，您的專案會產生*服務工作者資產資訊清單*。</span><span class="sxs-lookup"><span data-stu-id="13077-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="13077-185">根據預設，這稱為*service-worker-assets*。</span><span class="sxs-lookup"><span data-stu-id="13077-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="13077-186">這會列出應用程式離線運作所需的所有靜態資源，例如 .NET 元件、JavaScript 檔案、CSS 等，包括其內容雜湊。</span><span class="sxs-lookup"><span data-stu-id="13077-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="13077-187">這份清單是由您的服務工作者載入，讓它知道要快取的資源。</span><span class="sxs-lookup"><span data-stu-id="13077-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="13077-188">每次使用者造訪您的應用程式時，瀏覽器會在背景重新要求*service-worker*和*service-worker-assets* 。</span><span class="sxs-lookup"><span data-stu-id="13077-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="13077-189">如果伺服器傳回其中任一檔案的變更內容（與現有已安裝的服務背景工作角色的位元組比較），服務工作者會嘗試安裝新版的。</span><span class="sxs-lookup"><span data-stu-id="13077-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="13077-190">安裝新版本的本身時，服務背景工作會為離線資源建立新的個別快取，並使用*service-worker-assets*中列出的資源開始擴展。</span><span class="sxs-lookup"><span data-stu-id="13077-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="13077-191">這個邏輯會在 service-worker 內的 `onInstall` 函式中實作為*已發行的 .js*。</span><span class="sxs-lookup"><span data-stu-id="13077-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="13077-192">如果程式順利完成（亦即，所有資源都已載入而沒有錯誤，且所有內容雜湊都符合），則新的服務工作者會進入「等待啟用」狀態。</span><span class="sxs-lookup"><span data-stu-id="13077-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="13077-193">一旦使用者關閉您的應用程式（亦即，沒有剩餘的索引標籤或 windows 顯示您的應用程式），新的服務背景工作角色就會變成「作用中」，並用於後續造訪您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="13077-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="13077-194">系統會刪除舊的服務背景工作角色及其快取。</span><span class="sxs-lookup"><span data-stu-id="13077-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="13077-195">如果進程未順利完成，則會捨棄新的服務背景工作實例。</span><span class="sxs-lookup"><span data-stu-id="13077-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="13077-196">當使用者下一次造訪時，將會再次嘗試更新程式，希望他們有更好的網路連線可以完成要求。</span><span class="sxs-lookup"><span data-stu-id="13077-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="13077-197">您可以藉由編輯服務背景工作邏輯來自訂此程式的任何層面。</span><span class="sxs-lookup"><span data-stu-id="13077-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="13077-198">上述不是 Blazor特有的，但只是 PWA 範本選項所提供的建議。</span><span class="sxs-lookup"><span data-stu-id="13077-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="13077-199">如需詳細資訊，請參閱[服務工作者檔](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.)。</span><span class="sxs-lookup"><span data-stu-id="13077-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="13077-200">如何解決要求</span><span class="sxs-lookup"><span data-stu-id="13077-200">How requests are resolved</span></span>

<span data-ttu-id="13077-201">如上所述，預設的服務工作者會使用快取*優先*策略，這表示它會嘗試提供快取的內容（如果有的話）。</span><span class="sxs-lookup"><span data-stu-id="13077-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="13077-202">如果沒有針對特定 URL 快取任何內容（例如，從後端 API 要求資料時），服務工作者會回復一般網路要求，只有在可連線到伺服器的情況下才會成功。</span><span class="sxs-lookup"><span data-stu-id="13077-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="13077-203">這個邏輯會在 service-worker 內的 `onFetch` 中實作為*已發行的 .js*。</span><span class="sxs-lookup"><span data-stu-id="13077-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="13077-204">如果您的 Blazor 元件依賴從後端 Api 要求資料，而且您想要在這類要求因為網路無法使用而失敗的情況下提供易記的使用者體驗，則您需要在元件內執行邏輯。</span><span class="sxs-lookup"><span data-stu-id="13077-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="13077-205">例如，使用 `try/catch` 圍繞 `HttpClient` 的要求。</span><span class="sxs-lookup"><span data-stu-id="13077-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="13077-206">支援伺服器呈現的頁面</span><span class="sxs-lookup"><span data-stu-id="13077-206">Support server-rendered pages</span></span>

<span data-ttu-id="13077-207">請考慮當使用者第一次流覽至 URL （例如 `/counter` 或應用程式的任何其他深層連結）時，會發生什麼情況。</span><span class="sxs-lookup"><span data-stu-id="13077-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="13077-208">在這些情況下，您不想要傳回快取為 `/counter`的內容，而是需要瀏覽器載入快取為 `/index.html` 的內容，以啟動您的 Blazor WebAssembly 應用程式。</span><span class="sxs-lookup"><span data-stu-id="13077-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="13077-209">這些初始要求稱為「*導覽*要求」（相對於*subresource*對影像/CSS/等的要求，或 API 資料的*fetch/XHR*要求）。</span><span class="sxs-lookup"><span data-stu-id="13077-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="13077-210">預設的服務背景工作包含導覽要求的特殊案例邏輯。</span><span class="sxs-lookup"><span data-stu-id="13077-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="13077-211">它會藉由傳回 `/index.html`的快取內容來解決這些問題，而不論要求的 URL 為何。</span><span class="sxs-lookup"><span data-stu-id="13077-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="13077-212">這個邏輯會在 service-worker 內的 `onFetch` 函式中實作為*已發行的 .js*。</span><span class="sxs-lookup"><span data-stu-id="13077-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="13077-213">如果您的應用程式有特定 Url 必須傳回伺服器呈現的 HTML （而不是從快取提供 `/index.html`），則您需要編輯服務背景工作中的邏輯。</span><span class="sxs-lookup"><span data-stu-id="13077-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="13077-214">例如，如果包含 `/Identity/` 的所有 Url 都必須處理為一般僅線上的伺服器要求，則請修改*service-worker。已發行的 .js* `onFetch` 邏輯。</span><span class="sxs-lookup"><span data-stu-id="13077-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="13077-215">找出下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="13077-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="13077-216">將程式碼變更為下列內容：</span><span class="sxs-lookup"><span data-stu-id="13077-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="13077-217">如果您不這麼做，則不論網路連線為何，服務工作者都會攔截這類 Url 的要求，並使用 `/index.html`加以解析。</span><span class="sxs-lookup"><span data-stu-id="13077-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="13077-218">控制資產快取</span><span class="sxs-lookup"><span data-stu-id="13077-218">Control asset caching</span></span>

<span data-ttu-id="13077-219">如果您的專案定義了名為 `ServiceWorkerAssetsManifest`的 MSBuild 屬性，則 Blazor的組建工具會產生具有指定名稱的服務背景工作資產資訊清單。</span><span class="sxs-lookup"><span data-stu-id="13077-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="13077-220">預設 PWA 範本會產生包含下列專案的專案檔：</span><span class="sxs-lookup"><span data-stu-id="13077-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="13077-221">檔案會放在*wwwroot*輸出目錄中，因此瀏覽器可以藉由要求 `/service-worker-assets.js`來抓取此檔案。</span><span class="sxs-lookup"><span data-stu-id="13077-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="13077-222">若要查看內容，請在文字編輯器中開啟*YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* 。</span><span class="sxs-lookup"><span data-stu-id="13077-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="13077-223">不過，請不要編輯檔案，因為它會在每個組建上重新產生。</span><span class="sxs-lookup"><span data-stu-id="13077-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="13077-224">根據預設，此資訊清單會列出：</span><span class="sxs-lookup"><span data-stu-id="13077-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="13077-225">任何 Blazor管理的資源，例如 .NET 元件和 .NET WebAssembly 執行時間檔案，需要離線運作</span><span class="sxs-lookup"><span data-stu-id="13077-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="13077-226">將在*wwwroot*目錄中發行的所有資源，例如影像、CSS 檔案和 JavaScript 檔案。</span><span class="sxs-lookup"><span data-stu-id="13077-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="13077-227">這包括外部專案和 NuGet 套件所提供的靜態 web 資產。</span><span class="sxs-lookup"><span data-stu-id="13077-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="13077-228">您可以藉由在*service-worker*中編輯 `onInstall` 中的邏輯，來控制服務工作者會提取和快取哪些資源。</span><span class="sxs-lookup"><span data-stu-id="13077-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="13077-229">根據預設，它會提取和快取符合一般 web 副檔名的檔案，例如 *.html*、 *.css*、 *.js*、 *wasm*和其他檔案，再加上 Blazor WebAssembly （ *.dll*， *.pdb*）特定的檔案類型。</span><span class="sxs-lookup"><span data-stu-id="13077-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="13077-230">如果您想要包含不存在於*wwwroot*目錄中的其他資源，您可以藉由定義額外的 MSBuild itemgroup 專案來執行此動作。</span><span class="sxs-lookup"><span data-stu-id="13077-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="13077-231">例如，在您的專案檔中，新增：</span><span class="sxs-lookup"><span data-stu-id="13077-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="13077-232">`AssetUrl` 中繼資料會指定瀏覽器在提取要快取的資源時，應使用的基底相對 URL。</span><span class="sxs-lookup"><span data-stu-id="13077-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="13077-233">這可以獨立于其在磁片上的原始來原始檔案名。</span><span class="sxs-lookup"><span data-stu-id="13077-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="13077-234">新增 `ServiceWorkerAssetsManifestItem` 不會使檔案在您的*wwwroot*目錄中發行。</span><span class="sxs-lookup"><span data-stu-id="13077-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="13077-235">您必須分別控制發行輸出。</span><span class="sxs-lookup"><span data-stu-id="13077-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="13077-236">`ServiceWorkerAssetsManifestItem` 只會導致服務工作者資產資訊清單中出現額外的專案。</span><span class="sxs-lookup"><span data-stu-id="13077-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="13077-237">推播通知</span><span class="sxs-lookup"><span data-stu-id="13077-237">Push notifications</span></span>

<span data-ttu-id="13077-238">就像任何其他 PWA 一樣，Blazor WebAssembly PWA 也可以從後端伺服器接收推播通知。</span><span class="sxs-lookup"><span data-stu-id="13077-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="13077-239">即使使用者未主動使用您的應用程式（例如，當其他使用者執行可能相關的動作時），您的伺服器也可以隨時傳送這些訊息。</span><span class="sxs-lookup"><span data-stu-id="13077-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="13077-240">傳送推播通知的機制完全獨立于 Blazor WebAssembly，因為它是由可使用任何技術的後端伺服器所執行。</span><span class="sxs-lookup"><span data-stu-id="13077-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="13077-241">如果您想要從 ASP.NET Core 伺服器傳送推播通知，請考慮[使用類似于技術比薩研討會中的技巧](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications)。</span><span class="sxs-lookup"><span data-stu-id="13077-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="13077-242">在用戶端上接收和顯示推播通知的機制也獨立于 Blazor WebAssembly，因為它是在服務背景工作中執行，這是 JavaScript 檔案。</span><span class="sxs-lookup"><span data-stu-id="13077-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="13077-243">例如，您可以再次看到在[進行中的比薩研討會中使用的方法](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications)。</span><span class="sxs-lookup"><span data-stu-id="13077-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="13077-244">離線 Pwa 的注意事項</span><span class="sxs-lookup"><span data-stu-id="13077-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="13077-245">並非所有應用程式都應該嘗試支援離線使用。</span><span class="sxs-lookup"><span data-stu-id="13077-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="13077-246">它會增加相當大的複雜性，而不一定會相關。</span><span class="sxs-lookup"><span data-stu-id="13077-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="13077-247">離線支援通常僅與相關：</span><span class="sxs-lookup"><span data-stu-id="13077-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="13077-248">如果您的主要資料存放區是瀏覽器的本機。</span><span class="sxs-lookup"><span data-stu-id="13077-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="13077-249">例如，針對將資料儲存在 `localStorage` 或[IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API)中的[IOT](https://en.wikipedia.org/wiki/Internet_of_things)裝置建立 UI。</span><span class="sxs-lookup"><span data-stu-id="13077-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="13077-250">如果您執行大量工作來提取和快取與每個使用者相關的後端 API 資料，他們就可以離線流覽它。</span><span class="sxs-lookup"><span data-stu-id="13077-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="13077-251">如果您支援編輯，您也必須建立一個系統來追蹤變更，並將它們與後端同步處理。</span><span class="sxs-lookup"><span data-stu-id="13077-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="13077-252">如果您的目標是保證應用程式會立即載入，而不論網路狀況為何。</span><span class="sxs-lookup"><span data-stu-id="13077-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="13077-253">接著，您必須在後端 API 要求中執行適當的使用者體驗，以顯示要求的進度，並在因網路無法使用而失敗時，以正常的方式運作。</span><span class="sxs-lookup"><span data-stu-id="13077-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="13077-254">此外，具備離線功能的 Pwa 必須處理一系列額外的複雜性。</span><span class="sxs-lookup"><span data-stu-id="13077-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="13077-255">開發人員應該謹慎熟悉下列注意事項。</span><span class="sxs-lookup"><span data-stu-id="13077-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="13077-256">只有在發行時才支援離線</span><span class="sxs-lookup"><span data-stu-id="13077-256">Offline support only when published</span></span>

Blazor<span data-ttu-id="13077-257">的 PWA 範本只有在發佈時才會啟用離線支援。</span><span class="sxs-lookup"><span data-stu-id="13077-257">'s PWA template enables offline support only when published.</span></span> <span data-ttu-id="13077-258">這是因為在開發期間，您通常會想要查看瀏覽器中立即反映的每項變更，而不需要進行背景更新程式。</span><span class="sxs-lookup"><span data-stu-id="13077-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="13077-259">因此，在建立具備離線功能的應用程式時，在開發模式中測試您的應用程式並不夠。</span><span class="sxs-lookup"><span data-stu-id="13077-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="13077-260">您必須以其已發佈狀態測試您的應用程式，以瞭解它會如何回應不同的網路狀況。</span><span class="sxs-lookup"><span data-stu-id="13077-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="13077-261">使用者流覽離開應用程式之後的更新完成</span><span class="sxs-lookup"><span data-stu-id="13077-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="13077-262">在使用者從所有索引標籤流覽您的應用程式之前，更新都不會完成。</span><span class="sxs-lookup"><span data-stu-id="13077-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="13077-263">如[背景更新](#background-updates)中所述，在您將更新部署至應用程式之後，瀏覽器將會提取已更新的服務背景工作檔案，並開始進行更新程式。</span><span class="sxs-lookup"><span data-stu-id="13077-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="13077-264">許多開發人員很驚訝，即使這項更新完成，在使用者離開所有索引標籤之前，都**不**會生效。</span><span class="sxs-lookup"><span data-stu-id="13077-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="13077-265">重新整理顯示應用程式的索引標籤並**不**足夠，即使它是顯示應用程式的唯一索引標籤也一樣。</span><span class="sxs-lookup"><span data-stu-id="13077-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="13077-266">在您的應用程式完全關閉之前，新的服務工作者會繼續處於「正在等候啟動」狀態。</span><span class="sxs-lookup"><span data-stu-id="13077-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="13077-267">**這不是 Blazor特有的，而是標準的 web 平臺行為。**</span><span class="sxs-lookup"><span data-stu-id="13077-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="13077-268">這通常是麻煩嘗試測試其服務工作者或離線快取資源更新的開發人員。</span><span class="sxs-lookup"><span data-stu-id="13077-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="13077-269">如果您簽入瀏覽器的開發工具，您可能會看到類似下列的內容：</span><span class="sxs-lookup"><span data-stu-id="13077-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="13077-271">只要「用戶端」清單（也就是顯示您應用程式的索引標籤或視窗）不是空的，工作者就會繼續等待。</span><span class="sxs-lookup"><span data-stu-id="13077-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="13077-272">服務工作者執行此動作的原因是要保證一致性，亦即，所有資源都是從相同的不可部分完成快取中提取。</span><span class="sxs-lookup"><span data-stu-id="13077-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="13077-273">測試變更時，您可能會發現按一下 [skipWaiting] 連結很方便，如上方螢幕擷取畫面所示，然後重載頁面。</span><span class="sxs-lookup"><span data-stu-id="13077-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="13077-274">如有需要，您可以將服務工作者編碼以[略過「等待」階段，並在更新時立即啟用](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase)，讓所有使用者都能自動執行此作業。</span><span class="sxs-lookup"><span data-stu-id="13077-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="13077-275">不過，如果您這樣做，您就能保證資源一律會以一致的方式從相同的快取實例提取。</span><span class="sxs-lookup"><span data-stu-id="13077-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="13077-276">使用者可以執行應用程式的任何歷程記錄版本</span><span class="sxs-lookup"><span data-stu-id="13077-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="13077-277">Web 開發人員 habitually 預期使用者只會執行其 web 應用程式的最新部署版本，因為這在傳統 web 散發模型中是正常的。</span><span class="sxs-lookup"><span data-stu-id="13077-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="13077-278">不過，離線優先的 PWA 更類似于原生行動應用程式，使用者不一定要執行最新版本。</span><span class="sxs-lookup"><span data-stu-id="13077-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="13077-279">如[背景更新](#background-updates)中所述，在您將更新部署至應用程式之後，**每個現有的使用者都將繼續使用先前的版本，以進行至少一次的流覽**（因為更新是在背景中進行，而且在使用者接著流覽離開之前不會啟用）。</span><span class="sxs-lookup"><span data-stu-id="13077-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="13077-280">此外，先前使用的版本不一定是您所部署的前一版-它可以是*任何*歷程記錄版本，視使用者上次完成更新的時間而定。</span><span class="sxs-lookup"><span data-stu-id="13077-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="13077-281">如果應用程式的前端和後端部分需要 API 要求架構的合約，這可能會有問題。</span><span class="sxs-lookup"><span data-stu-id="13077-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="13077-282">您必須先確定所有使用者都已升級，或至少封鎖使用者使用不相容的繼承應用程式，才能部署回溯不相容的 API 架構變更。</span><span class="sxs-lookup"><span data-stu-id="13077-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="13077-283">這就像原生行動應用程式一樣。</span><span class="sxs-lookup"><span data-stu-id="13077-283">This is just like a native mobile app.</span></span> <span data-ttu-id="13077-284">如果您在伺服器 Api 中部署中斷性變更，用戶端應用程式將會中斷，供尚未更新的人員使用。</span><span class="sxs-lookup"><span data-stu-id="13077-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="13077-285">可能的話，請勿將中斷性變更部署至您的後端 Api。</span><span class="sxs-lookup"><span data-stu-id="13077-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="13077-286">但是，如果您必須這麼做，請考慮使用[標準服務背景工作角色 api （例如 `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) ）來判斷應用程式是否為最新狀態，如果不是，則避免使用。</span><span class="sxs-lookup"><span data-stu-id="13077-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="13077-287">伺服器呈現頁面的干擾</span><span class="sxs-lookup"><span data-stu-id="13077-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="13077-288">[如上所述，如果](#support-server-rendered-pages)您想要略過服務工作者針對所有導覽要求傳回 `/index.html` 內容的行為，您必須編輯服務背景工作中的邏輯。</span><span class="sxs-lookup"><span data-stu-id="13077-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="13077-289">預設會快取所有服務工作者資產資訊清單內容</span><span class="sxs-lookup"><span data-stu-id="13077-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="13077-290">[如上所述，](#control-asset-caching) *service-worker-assets*檔案會在組建期間產生，並列出服務工作者應提取和快取的所有資產。</span><span class="sxs-lookup"><span data-stu-id="13077-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="13077-291">因為此清單預設包含所有發出至*wwwroot*的內容（包括外部封裝和專案所提供的內容），所以您必須小心不要在該處放入太多內容。</span><span class="sxs-lookup"><span data-stu-id="13077-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="13077-292">例如，如果您的*wwwroot*目錄包含數百萬個影像，服務工作者會嘗試提取並快取全部，耗用過多的頻寬，而且很可能無法順利完成。</span><span class="sxs-lookup"><span data-stu-id="13077-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="13077-293">您可以藉由編輯*service-worker*中的 `onInstall` 函式，來執行任意邏輯來控制要提取和快取的資訊清單內容子集。</span><span class="sxs-lookup"><span data-stu-id="13077-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="13077-294">與驗證互動</span><span class="sxs-lookup"><span data-stu-id="13077-294">Interaction with authentication</span></span>

<span data-ttu-id="13077-295">您可以使用 [PWA 範本] 選項搭配驗證選項。</span><span class="sxs-lookup"><span data-stu-id="13077-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="13077-296">具有離線功能的 PWA 也可以在使用者具有網路連線能力時支援驗證。</span><span class="sxs-lookup"><span data-stu-id="13077-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="13077-297">不過，當使用者沒有網路連線時，他們將無法驗證或取得存取權杖。</span><span class="sxs-lookup"><span data-stu-id="13077-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="13077-298">嘗試造訪 [登入] 頁面預設會顯示一則訊息，指出「網路錯誤」。</span><span class="sxs-lookup"><span data-stu-id="13077-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="13077-299">因此，您可以設計 UI 流程，讓使用者在離線時執行有用的工作，而不會嘗試驗證或取得存取權杖，或至少在這些情況下以正常方式失敗。</span><span class="sxs-lookup"><span data-stu-id="13077-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="13077-300">如果您的應用程式中無法這麼做，您可能不會想要啟用離線支援。</span><span class="sxs-lookup"><span data-stu-id="13077-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
