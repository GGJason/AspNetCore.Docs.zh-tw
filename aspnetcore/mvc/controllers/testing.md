---
title: 測試 ASP.NET Core 中的控制器邏輯
author: ardalis
description: 了解如何使用 Moq 和 xUnit 測試 ASP.NET Core 中的控制器邏輯。
ms.author: riande
ms.date: 10/14/2016
uid: mvc/controllers/testing
ms.openlocfilehash: fc5f10b4d5947a6af114bf00f8b1d955b083a44d
ms.sourcegitcommit: a1afd04758e663d7062a5bfa8a0d4dca38f42afc
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/20/2018
ms.locfileid: "36273919"
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="f1d4b-103">測試 ASP.NET Core 中的控制器邏輯</span><span class="sxs-lookup"><span data-stu-id="f1d4b-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="f1d4b-104">作者：[Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="f1d4b-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="f1d4b-105">ASP.NET MVC 應用程式中的控制器應該很小，並著重於使用者介面考量。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="f1d4b-106">處理非 UI 考量的大型控制器會比較難測試及維護。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="f1d4b-107">從 GitHub 檢視或下載範例</span><span class="sxs-lookup"><span data-stu-id="f1d4b-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="f1d4b-108">測試控制器</span><span class="sxs-lookup"><span data-stu-id="f1d4b-108">Testing controllers</span></span>

<span data-ttu-id="f1d4b-109">控制器是任何 ASP.NET Core MVC 應用程式的核心部分。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="f1d4b-110">因此，您應該確信其行為符合應用程式的預期。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="f1d4b-111">自動化的測試可建立您這方面的信心，並可在錯誤到達生產環境之前就偵測到錯誤。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="f1d4b-112">請務必避免對您的控制器加諸不必要的職責，並確保您的測試只會著重於控制器職責。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="f1d4b-113">控制器邏輯應該是最小，且不著重於商務邏輯或基礎結構考量 (例如資料存取)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="f1d4b-114">測試控制器邏輯，而不是架構。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="f1d4b-115">根據輸入有效或無效，測試控制器的「行為」方式。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="f1d4b-116">根據控制器執行的商務作業結果，測試控制器回應。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="f1d4b-117">一般控制器職責如下：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="f1d4b-118">驗證 `ModelState.IsValid`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="f1d4b-119">如果 `ModelState` 無效，則傳回錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="f1d4b-120">從持續性儲存區擷取商務實體。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="f1d4b-121">在商務實體上執行動作。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="f1d4b-122">將商務實體儲存至持續性儲存區。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="f1d4b-123">傳回適當的 `IActionResult`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="f1d4b-124">單元測試</span><span class="sxs-lookup"><span data-stu-id="f1d4b-124">Unit testing</span></span>

<span data-ttu-id="f1d4b-125">[單元測試](/dotnet/articles/core/testing/unit-testing-with-dotnet-test)包括將應用程式的一部分與其基礎結構和相依性隔離測試。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-125">[Unit testing](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="f1d4b-126">對控制器邏輯進行單元測試時，只會測試單一動作的內容，而不會測試其相依性或架構本身的行為。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="f1d4b-127">當您對控制器動作進行單元測試時，請務必只著重於其行為。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="f1d4b-128">控制器單元測試會避開[篩選](filters.md)、[路由](../../fundamentals/routing.md)或[模型繫結](../models/model-binding.md)等作業。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="f1d4b-129">由於測試的焦點只有一個，因此單元測試通常很容易撰寫，而且執行速度很快。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="f1d4b-130">一組編寫完善的單元測試可以經常執行，而不會造成太多額外負荷。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="f1d4b-131">不過，單元測試不會偵測元件之間的互動問題，這需要使用[整合測試](xref:mvc/controllers/testing#integration-testing)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="f1d4b-132">如果您想要撰寫自訂篩選、路由等，您應該對其進行單元測試，而不是當作特定控制器動作測試的一部分。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="f1d4b-133">這些項目應該隔離測試。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="f1d4b-134">[使用 Visual Studio 建立和執行單元測試](/visualstudio/test/unit-test-your-code)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-134">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="f1d4b-135">若要示範單元測試，請檢閱下列控制器。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="f1d4b-136">它顯示一份腦力激盪工作階段清單，並允許使用 POST 建立新的腦力激盪工作階段：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="f1d4b-137">此控制器遵循 [Explicit Dependencies Principle](http://deviq.com/explicit-dependencies-principle/) (明確的相依性原則)，預期會插入相依性以提供 `IBrainstormSessionRepository` 的執行個體。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="f1d4b-138">因此可讓您使用模擬物件架構 (例如 [Moq](https://www.nuget.org/packages/Moq/)) 輕鬆進行測試。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="f1d4b-139">`HTTP GET Index` 方法有沒有迴圈或分支，而且只會呼叫一個方法。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="f1d4b-140">若要測試此 `Index` 方法，我們需要驗證透過儲存機制的 `List` 方法可傳回 `ViewResult` 和 `ViewModel`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="f1d4b-141">`HomeController` `HTTP POST Index` 方法 (如上所示) 應該會驗證：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="f1d4b-142">當 `ModelState.IsValid` 為 `false` 時，動作方法會傳回不正確的要求 `ViewResult` 及適當的資料</span><span class="sxs-lookup"><span data-stu-id="f1d4b-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="f1d4b-143">當 `ModelState.IsValid` 為 true 時，會呼叫儲存機制的 `Add` 方法，並傳回具有正確引數的 `RedirectToActionResult`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="f1d4b-144">您可以使用 `AddModelError` 新增錯誤，來測試無效的模型狀態，如下列第一項測試中所示。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="f1d4b-145">第一項測試會驗證當 `ModelState` 無效時，會傳回與 `GET` 要求相同的 `ViewResult`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="f1d4b-146">請注意，此測試不會嘗試傳入無效的模型。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="f1d4b-147">即使傳入也沒有作用，因為模型繫結並未執行 (但[整合測試](xref:mvc/controllers/testing#integration-testing)會使用練習模型繫結)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="f1d4b-148">在此情況下，不會測試模型繫結。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="f1d4b-149">這些單元測試只會測試動作方法中的程式碼功能。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="f1d4b-150">第二項測試會驗證當 `ModelState` 有效時，會新增新的 `BrainstormSession` (透過儲存機制)，而且方法會傳回具有預期屬性的 `RedirectToActionResult`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="f1d4b-151">通常會忽略未呼叫的模擬呼叫，但在安裝程式呼叫結束時呼叫 `Verifiable` 即可在測試中對其進行驗證。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="f1d4b-152">這會透過呼叫 `mockRepo.Verify` 來完成，如果未呼叫預期的方法，則測試會失敗。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d4b-153">此範例中所使用的 Moq 程式庫可讓您輕鬆混合可驗證 (或「嚴格」) 的模擬與無法驗證的模擬 (也稱為「鬆散」的模擬或虛設常式)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="f1d4b-154">如需詳細資訊，請參閱 [Customizing Mock Behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior) (使用 Moq 自訂模擬行為)。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="f1d4b-155">應用程式中的另一個控制器會顯示與特定腦力激盪工作階段相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="f1d4b-156">其中包含一些可處理無效識別碼值的邏輯：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="f1d4b-157">此控制器動作有三個待測試案例，每個 `return` 陳述式各代表一個案例：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="f1d4b-158">此應用程式會以 Web API 形式公開功能 (一份與腦力激盪工作階段建立關聯的想法清單，以及一個將新的想法新增工作清單的方法)：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="f1d4b-159">`ForSession` 方法會傳回 `IdeaDTO` 類型清單。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="f1d4b-160">請避免直接透過 API 呼叫來傳回公司領域實體，因為這些實體通常包含比 API 用戶端所需更多的資料，而且會不必要地結合您應用程式的內部領域模型與您對外公開的 API。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="f1d4b-161">您可以手動 (使用此處所示的 LINQ `Select`) 或使用 [AutoMapper](https://github.com/AutoMapper/AutoMapper) 等程式庫，來對應領域實體與您將透過網路傳回的類型</span><span class="sxs-lookup"><span data-stu-id="f1d4b-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="f1d4b-162">`Create` 和 `ForSession` API 方法的單元測試為：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="f1d4b-163">如前所述，若要測試當 `ModelState` 無效時的方法行為，請將模型錯誤新增控制器作為測試的一部分。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="f1d4b-164">請勿嘗試在您的單元測試中測試模型驗證或模型繫結，只要測試當遇到特定 `ModelState` 值時的動作方法行為即可。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="f1d4b-165">第二項測試需要儲存機制傳回 Null，因此會設定模擬儲存機制傳回 Null。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="f1d4b-166">不需要建立測試資料庫 (在記憶體中或其他位置)，也不需要建構傳回此結果的查詢，這會透過上述的單一陳述式來完成。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="f1d4b-167">最後一項測試會驗證是否呼叫儲存機制的 `Update` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="f1d4b-168">如前所述，先使用 `Verifiable` 呼叫模擬，再呼叫模擬儲存機制的 `Verify` 方法，確認是否已執行可驗證的方法。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="f1d4b-169">單元測試無須負責確保 `Update` 方法已儲存資料，這會透過整合測試來完成。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="f1d4b-170">整合測試</span><span class="sxs-lookup"><span data-stu-id="f1d4b-170">Integration testing</span></span>

<span data-ttu-id="f1d4b-171">[整合測試](xref:test/integration-tests)的目的是為了確保應用程式中的個別模組可正常搭配運作。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-171">[Integration tests](xref:test/integration-tests) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="f1d4b-172">一般而言，您可以使用單元測試進行測試的任何情節，也可以使用整合測試進行測試，但反之則不然。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="f1d4b-173">不過，整合測試通常比單元測試慢。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="f1d4b-174">因此，最好使用單元測試來測試任何情節，再針對涉及多個共同作業者的情節使用整合測試。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="f1d4b-175">雖然模擬物件仍然有用，但很少會用於整合測試中。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="f1d4b-176">在單元測試中，模擬物件可有效地控制單元外待測試的共同作業者針對測試目的應該有的行為方式。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="f1d4b-177">在整合測試中，會使用實際的共同作業者來確認整個子系統可正常搭配運作。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="f1d4b-178">應用程式狀態</span><span class="sxs-lookup"><span data-stu-id="f1d4b-178">Application state</span></span>

<span data-ttu-id="f1d4b-179">執行整合測試時的一個重要考量是如何設定應用程式狀態。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="f1d4b-180">測試需要彼此獨立執行，因此每項測試應該從已知狀態的應用程式開始。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="f1d4b-181">如果您的應用程式未使用資料庫或沒有任何持續性儲存區，這可能不是問題。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="f1d4b-182">不過，大部分真實世界應用程式會將其狀態保存到某種資料存放區，因此除非重設資料存放區，否則某項測試所做的任何修改都可能影響另一項測試。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="f1d4b-183">透過內建 `TestServer`，輕鬆就可在整合測試中裝載 ASP.NET Core 應用程式，但這不一定會授權存取它將使用的資料。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="f1d4b-184">如果您使用實際資料庫，一個方法是讓應用程式連線到您的測試可存取的測試資料庫，並確保在每項測試執行之前都已重設為已知狀態。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="f1d4b-185">在此範例應用程式中，我將使用 Entity Framework Core 的 InMemoryDatabase 支援，因此無法直接從測試專案連線到資料庫。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="f1d4b-186">相反地，我會公開應用程式之 `Startup` 類別中的 `InitializeDatabase` 方法，當應用程式啟動時，若在 `Development` 環境中，就會呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="f1d4b-187">只要我的整合測試將環境設定為`Development`，就會自動從中獲益。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="f1d4b-188">我不必擔心重設資料庫，因為每次應用程式重新啟動，都會重設 InMemoryDatabase。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="f1d4b-189">`Startup` 類別：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-189">The `Startup` class:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="f1d4b-190">您會在下列整合測試中看到經常使用 `GetTestSession` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="f1d4b-191">存取檢視</span><span class="sxs-lookup"><span data-stu-id="f1d4b-191">Accessing views</span></span>

<span data-ttu-id="f1d4b-192">每個整合測試類別會設定將執行 ASP.NET Core 應用程式的 `TestServer`。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="f1d4b-193">根據預設，`TestServer` 會在執行所在的資料夾中裝載 Web 應用程式，在本例中會是測試專案資料夾。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="f1d4b-194">因此，當您嘗試測試傳回 `ViewResult` 的控制器動作時，您可能會看到此錯誤：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="f1d4b-195">若要更正此問題，您需要設定伺服器的內容根目錄，讓它可以找到受測專案的檢視。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="f1d4b-196">這會透過呼叫 `TestFixture` 類別中的 `UseContentRoot` 來完成，如下所示：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="f1d4b-197">`TestFixture` 類別負責設定及建立 `TestServer`，並設定 `HttpClient` 與 `TestServer` 通訊。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="f1d4b-198">每項整合測試都會使用 `Client` 屬性來連線到測試伺服器並提出要求。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="f1d4b-199">在上述第一項測試中，`responseString` 會保存檢視中實際轉譯的 HTML，您可以檢查此 HTML 確認它包含預期的結果。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="f1d4b-200">第二項測試使用唯一的工作階段名稱建構表單 POST 並將它張貼至應用程式，然後驗證是否傳回預期的重新導向。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="f1d4b-201">API 方法</span><span class="sxs-lookup"><span data-stu-id="f1d4b-201">API methods</span></span>

<span data-ttu-id="f1d4b-202">如果您的應用程式公開 Web API，建議使用自動化的測試來確認這些 API 如預期般執行。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="f1d4b-203">內建 `TestServer` 可讓您輕鬆測試 Web API。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="f1d4b-204">如果您的 API 方法使用模型繫結，請務必檢查 `ModelState.IsValid`，而整合測試是確認模型驗證是否正常運作的理想位置。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="f1d4b-205">下列一組測試是以上述 [IdeasController](xref:mvc/controllers/testing#ideas-controller) 類別中的 `Create` 方法為目標：</span><span class="sxs-lookup"><span data-stu-id="f1d4b-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="f1d4b-206">不同於動作的整合測試會傳回 HTML 檢視，Web API 方法會傳回結果，您通常可以將這些結果還原序列化為強型別物件，如上面最後一項測試所示。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="f1d4b-207">在本例中，測試會將結果還原序列化為 `BrainstormSession` 執行個體，並確認此想法已正確新增其想法集合。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="f1d4b-208">您可以在本文的[範例專案](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)中，找到整合測試的其他範例。</span><span class="sxs-lookup"><span data-stu-id="f1d4b-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
