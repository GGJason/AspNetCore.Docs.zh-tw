---
title: ASP.NET Core 資料保護
author: rick-anderson
description: 了解資料保護的概念和 ASP.NET Core 資料保護應用程式開發介面的設計原則。
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: security/data-protection/introduction
ms.openlocfilehash: 56876f43ed48b577f4d870825fd9230f526baec3
ms.sourcegitcommit: 9a35906446af7ffd4ccfc18daec38874b5abbef7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/18/2018
ms.locfileid: "35725948"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="34c32-103">ASP.NET Core 資料保護</span><span class="sxs-lookup"><span data-stu-id="34c32-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="34c32-104">Web 應用程式通常需要儲存機密資料。</span><span class="sxs-lookup"><span data-stu-id="34c32-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="34c32-105">Windows 桌面應用程式提供 DPAPI，但這並不適合 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="34c32-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="34c32-106">ASP.NET Core 資料保護堆疊提供簡單、 更容易使用密碼編譯 API 為開發人員可用來保護資料，包括金鑰管理和旋轉。</span><span class="sxs-lookup"><span data-stu-id="34c32-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="34c32-107">ASP.NET Core 資料保護堆疊設計來做為長期取代&lt;machineKey&gt; ASP.NET 中的項目 1.x-4.x。</span><span class="sxs-lookup"><span data-stu-id="34c32-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="34c32-108">它被設計成同時提供適用於大部分的現代應用程式都可能會遇到的使用案例的全新解決方案可以提供許多舊的密碼編譯堆疊的缺點。</span><span class="sxs-lookup"><span data-stu-id="34c32-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="34c32-109">問題陳述式</span><span class="sxs-lookup"><span data-stu-id="34c32-109">Problem statement</span></span>

<span data-ttu-id="34c32-110">整體問題陳述式可以簡潔說明中的單一句子： 我需要保存可靠的資訊供日後擷取，但是我不信任的持續性機制。</span><span class="sxs-lookup"><span data-stu-id="34c32-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="34c32-111">在 web 詞彙中，這可能會寫入如 「 我需要透過不受信任的用戶端的來回行程信任狀態 」。</span><span class="sxs-lookup"><span data-stu-id="34c32-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="34c32-112">標準範例是驗證 cookie 或持有人權杖。</span><span class="sxs-lookup"><span data-stu-id="34c32-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="34c32-113">伺服器會產生 「 我 Groot 而且的使用權限 xyz"語彙基元，並將它交付給用戶端。</span><span class="sxs-lookup"><span data-stu-id="34c32-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="34c32-114">在未來的某個日期，用戶端會出示該權杖至伺服器，但伺服器需要某種保證用戶端尚未偽造 token。</span><span class="sxs-lookup"><span data-stu-id="34c32-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="34c32-115">因此第一項需求： 真實性 （也稱為</span><span class="sxs-lookup"><span data-stu-id="34c32-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="34c32-116">完整性、 竄改）。</span><span class="sxs-lookup"><span data-stu-id="34c32-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="34c32-117">因為伺服器所信任的保存的狀態，我們預期此狀態可能包含作業系統的環境特有的資訊。</span><span class="sxs-lookup"><span data-stu-id="34c32-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="34c32-118">這可能是格式的檔案路徑、 權限，控制代碼或其他的間接參考，或其他一些伺服器特定資料。</span><span class="sxs-lookup"><span data-stu-id="34c32-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="34c32-119">這類資訊應該通常不會透露給未受信任的用戶端。</span><span class="sxs-lookup"><span data-stu-id="34c32-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="34c32-120">因此第二項需求： 機密性。</span><span class="sxs-lookup"><span data-stu-id="34c32-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="34c32-121">最後，在現代應用程式元件化，因為我們已經看到是個別的元件會想要在系統中充分利用此系統，而不考慮其他元件。</span><span class="sxs-lookup"><span data-stu-id="34c32-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="34c32-122">比方說，如果承載語彙基元的元件會使用此堆疊，它應該作業不受干擾，從一種反 CSRF 機制，也可能使用相同的堆疊。</span><span class="sxs-lookup"><span data-stu-id="34c32-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="34c32-123">因此最後的需求： 隔離。</span><span class="sxs-lookup"><span data-stu-id="34c32-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="34c32-124">我們可以提供進一步的條件約束以縮小範圍我們的需求。</span><span class="sxs-lookup"><span data-stu-id="34c32-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="34c32-125">我們假設內加密系統都運作的所有服務都都同樣地受到信任，並產生或取用我們直接控制權服務之外，不需要資料。</span><span class="sxs-lookup"><span data-stu-id="34c32-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="34c32-126">此外，我們需要作業會盡快，因為每個要求至 web 服務可能會加密系統都有一或多次。</span><span class="sxs-lookup"><span data-stu-id="34c32-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="34c32-127">這會使得對稱式密碼編譯適合我們的案例中，與我們可以折扣非對稱密碼編譯直到例如所需的時間。</span><span class="sxs-lookup"><span data-stu-id="34c32-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="34c32-128">設計原理</span><span class="sxs-lookup"><span data-stu-id="34c32-128">Design philosophy</span></span>

<span data-ttu-id="34c32-129">我們已開始藉由識別現有的堆疊中的問題。</span><span class="sxs-lookup"><span data-stu-id="34c32-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="34c32-130">一旦我們必須的我們會接受問卷調查現有解決方案的橫向，卻沒有現有的方案會相當有我們要在其中搜尋的功能。</span><span class="sxs-lookup"><span data-stu-id="34c32-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="34c32-131">然後，我們工程數個指導原則為基礎的解決方案。</span><span class="sxs-lookup"><span data-stu-id="34c32-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="34c32-132">系統應該提供簡化的組態。</span><span class="sxs-lookup"><span data-stu-id="34c32-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="34c32-133">在理想情況下會是零組態系統和開發人員無法叫用地面執行。</span><span class="sxs-lookup"><span data-stu-id="34c32-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="34c32-134">在開發人員必須設定的特定層面 （例如金鑰的儲存機制） 的情況下，應該給予考量進行簡單的這些特定的設定。</span><span class="sxs-lookup"><span data-stu-id="34c32-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="34c32-135">提供一個簡單的消費者導向 API。</span><span class="sxs-lookup"><span data-stu-id="34c32-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="34c32-136">應用程式開發介面應該可以輕鬆地使用正確的而且難以使用方式不正確。</span><span class="sxs-lookup"><span data-stu-id="34c32-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="34c32-137">開發人員不應該了解金鑰管理原則。</span><span class="sxs-lookup"><span data-stu-id="34c32-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="34c32-138">系統應該處理演算法選取項目和開發人員的代表金鑰存留期。</span><span class="sxs-lookup"><span data-stu-id="34c32-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="34c32-139">在理想情況下開發人員應該永遠不會甚至需要存取原始的金鑰內容。</span><span class="sxs-lookup"><span data-stu-id="34c32-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="34c32-140">索引鍵都應該在靜止時可能受到保護。</span><span class="sxs-lookup"><span data-stu-id="34c32-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="34c32-141">系統應該找出適當的預設保護機制，並將它自動套用。</span><span class="sxs-lookup"><span data-stu-id="34c32-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="34c32-142">這些原則，請注意，我們開發簡單、[易用](xref:security/data-protection/using-data-protection)資料保護堆疊。</span><span class="sxs-lookup"><span data-stu-id="34c32-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="34c32-143">ASP.NET Core 資料保護 Api 主要被不適用於機密裝載的無限期持續性。</span><span class="sxs-lookup"><span data-stu-id="34c32-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="34c32-144">其他技術喜歡[Windows CNG api，DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx)和[Azure Rights Management](https://docs.microsoft.com/rights-management/)更適合的案例是無限期的儲存體，而且必須跟著強式金鑰的管理功能。</span><span class="sxs-lookup"><span data-stu-id="34c32-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](https://docs.microsoft.com/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="34c32-145">話雖如此，沒有任何開發人員會禁止從 ASP.NET Core 資料保護應用程式開發介面使用的長期保護的機密資料。</span><span class="sxs-lookup"><span data-stu-id="34c32-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="34c32-146">適用對象</span><span class="sxs-lookup"><span data-stu-id="34c32-146">Audience</span></span>

<span data-ttu-id="34c32-147">資料保護系統分為五個主要的封裝。</span><span class="sxs-lookup"><span data-stu-id="34c32-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="34c32-148">這些 Api 的各個層面目標三個主要對象。</span><span class="sxs-lookup"><span data-stu-id="34c32-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="34c32-149">[取用者應用程式開發介面概觀](xref:security/data-protection/consumer-apis/overview)目標應用程式和 framework 開發人員。</span><span class="sxs-lookup"><span data-stu-id="34c32-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="34c32-150">「 我不想要了解有關堆疊的運作方式或其設定方式。</span><span class="sxs-lookup"><span data-stu-id="34c32-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="34c32-151">我只想要執行中做為簡單的某些作業的方式盡可能高機率的成功使用應用程式開發介面。 」</span><span class="sxs-lookup"><span data-stu-id="34c32-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="34c32-152">[組態 Api](xref:security/data-protection/configuration/overview)目標應用程式開發人員和系統管理員。</span><span class="sxs-lookup"><span data-stu-id="34c32-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="34c32-153">「 我需要告訴我的環境需要非預設路徑或設定資料保護系統 」。</span><span class="sxs-lookup"><span data-stu-id="34c32-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="34c32-154">擴充性 Api 目標開發人員負責實作自訂原則。</span><span class="sxs-lookup"><span data-stu-id="34c32-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="34c32-155">使用這些 Api 會限制為罕見的情況下，發生，安全性知道開發人員。</span><span class="sxs-lookup"><span data-stu-id="34c32-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="34c32-156">「 我需要取代系統內的整個元件，因為有唯一真正的行為需求。</span><span class="sxs-lookup"><span data-stu-id="34c32-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="34c32-157">我願意將了解 uncommonly 使用的 API 介面的組件，才能建立外掛程式，可滿足我的需求。 」</span><span class="sxs-lookup"><span data-stu-id="34c32-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="34c32-158">封裝配置</span><span class="sxs-lookup"><span data-stu-id="34c32-158">Package Layout</span></span>

<span data-ttu-id="34c32-159">資料保護堆疊包含五個封裝。</span><span class="sxs-lookup"><span data-stu-id="34c32-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="34c32-160">Microsoft.AspNetCore.DataProtection.Abstractions 包含基本 IDataProtectionProvider 和 IDataProtector 的介面。</span><span class="sxs-lookup"><span data-stu-id="34c32-160">Microsoft.AspNetCore.DataProtection.Abstractions contains the basic IDataProtectionProvider and IDataProtector interfaces.</span></span> <span data-ttu-id="34c32-161">它也包含實用的擴充方法，可協助處理這些類型 （例如，多載的 IDataProtector.Protect）。</span><span class="sxs-lookup"><span data-stu-id="34c32-161">It also contains useful extension methods that can assist working with these types (e.g., overloads of IDataProtector.Protect).</span></span> <span data-ttu-id="34c32-162">請參閱取用者介面 > 一節，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="34c32-162">See the consumer interfaces section for more information.</span></span> <span data-ttu-id="34c32-163">如果其他人負責具現化的資料保護系統，而且您只需使用應用程式開發介面，您會想要參考 Microsoft.AspNetCore.DataProtection.Abstractions。</span><span class="sxs-lookup"><span data-stu-id="34c32-163">If somebody else is responsible for instantiating the data protection system and you are simply consuming the APIs, you'll want to reference Microsoft.AspNetCore.DataProtection.Abstractions.</span></span>

* <span data-ttu-id="34c32-164">Microsoft.AspNetCore.DataProtection 包含包括核心密碼編譯作業、 金鑰管理、 組態和擴充性的資料保護系統的核心實作。</span><span class="sxs-lookup"><span data-stu-id="34c32-164">Microsoft.AspNetCore.DataProtection contains the core implementation of the data protection system, including the core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="34c32-165">如果您負責具現化的資料保護系統 （例如，將它加入 IServiceCollection） 或修改或擴充其行為，您會想要參考 Microsoft.AspNetCore.DataProtection。</span><span class="sxs-lookup"><span data-stu-id="34c32-165">If you're responsible for instantiating the data protection system (e.g., adding it to an IServiceCollection) or modifying or extending its behavior, you'll want to reference Microsoft.AspNetCore.DataProtection.</span></span>

* <span data-ttu-id="34c32-166">Microsoft.AspNetCore.DataProtection.Extensions 包含其他應用程式開發介面，開發人員會很有用，但其不屬於此核心套件中。</span><span class="sxs-lookup"><span data-stu-id="34c32-166">Microsoft.AspNetCore.DataProtection.Extensions contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="34c32-167">比方說，此套件包含簡單"具現化的系統沒有相依性資料隱碼安裝程式的特定金鑰的儲存目錄指向 「 應用程式開發介面 （詳細資訊）。</span><span class="sxs-lookup"><span data-stu-id="34c32-167">For instance, this package contains a simple "instantiate the system pointing at a specific key storage directory with no dependency injection setup" API (more info).</span></span> <span data-ttu-id="34c32-168">它也包含擴充方法，來限制受保護的內容 （詳細資訊） 的存留期。</span><span class="sxs-lookup"><span data-stu-id="34c32-168">It also contains extension methods for limiting the lifetime of protected payloads (more info).</span></span>

* <span data-ttu-id="34c32-169">Microsoft.AspNetCore.DataProtection.SystemWeb 可以安裝到現有的 ASP.NET 4.x 應用程式重新導向其&lt;machineKey&gt;改為使用新的資料保護堆疊的作業。</span><span class="sxs-lookup"><span data-stu-id="34c32-169">Microsoft.AspNetCore.DataProtection.SystemWeb can be installed into an existing ASP.NET 4.x application to redirect its &lt;machineKey&gt; operations to instead use the new data protection stack.</span></span> <span data-ttu-id="34c32-170">請參閱[相容性](xref:security/data-protection/compatibility/replacing-machinekey#compatibility-replacing-machinekey)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="34c32-170">See [compatibility](xref:security/data-protection/compatibility/replacing-machinekey#compatibility-replacing-machinekey) for more information.</span></span>

* <span data-ttu-id="34c32-171">Microsoft.AspNetCore.Cryptography.KeyDerivation 提供 PBKDF2 密碼雜湊常式的實作，並可供系統需要安全地處理使用者密碼。</span><span class="sxs-lookup"><span data-stu-id="34c32-171">Microsoft.AspNetCore.Cryptography.KeyDerivation provides an implementation of the PBKDF2 password hashing routine and can be used by systems which need to handle user passwords securely.</span></span> <span data-ttu-id="34c32-172">請參閱[雜湊密碼](xref:security/data-protection/consumer-apis/password-hashing)如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="34c32-172">See [Hash passwords](xref:security/data-protection/consumer-apis/password-hashing) for more information.</span></span>
