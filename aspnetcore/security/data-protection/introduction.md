---
title: ASP.NET Core 資料保護
author: rick-anderson
description: 瞭解資料保護的概念，以及 ASP.NET Core 資料保護 Api 的設計原則。
ms.author: riande
ms.custom: mvc
ms.date: 10/24/2018
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/introduction
ms.openlocfilehash: 60cf659c720012d05bb2a6f1433c18d347469462
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/26/2020
ms.locfileid: "85399526"
---
# <a name="aspnet-core-data-protection"></a><span data-ttu-id="408be-103">ASP.NET Core 資料保護</span><span class="sxs-lookup"><span data-stu-id="408be-103">ASP.NET Core Data Protection</span></span>

<span data-ttu-id="408be-104">Web 應用程式通常需要儲存安全性敏感的資料。</span><span class="sxs-lookup"><span data-stu-id="408be-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="408be-105">Windows 為傳統型應用程式提供 DPAPI，但這不適用於 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="408be-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="408be-106">ASP.NET Core 資料保護堆疊提供簡單、容易使用的密碼編譯 API，開發人員可用來保護資料，包括金鑰管理和輪替。</span><span class="sxs-lookup"><span data-stu-id="408be-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="408be-107">ASP.NET Core 資料保護堆疊的設計，是用來做為 &lt; ASP.NET 1.x-4.x 中 machineKey 元素的長期取代 &gt; 。</span><span class="sxs-lookup"><span data-stu-id="408be-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the &lt;machineKey&gt; element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="408be-108">其設計目的是要解決舊版密碼編譯堆疊的許多缺點，同時為現代應用程式可能遇到的大多數使用案例提供現成的解決方案。</span><span class="sxs-lookup"><span data-stu-id="408be-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="408be-109">問題陳述</span><span class="sxs-lookup"><span data-stu-id="408be-109">Problem statement</span></span>

<span data-ttu-id="408be-110">整體問題聲明可以在單一句子中簡潔地陳述：我需要保存信任的資訊以供日後抓取，但我不信任持續性機制。</span><span class="sxs-lookup"><span data-stu-id="408be-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="408be-111">在 web 詞彙中，這可能會撰寫為「我需要透過不受信任的用戶端來回存取受信任的狀態」。</span><span class="sxs-lookup"><span data-stu-id="408be-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="408be-112">這是驗證 cookie 或持有人權杖的標準範例。</span><span class="sxs-lookup"><span data-stu-id="408be-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="408be-113">伺服器會產生「我的 Groot，並擁有 xyz 許可權」權杖，並將其交給用戶端。</span><span class="sxs-lookup"><span data-stu-id="408be-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="408be-114">在未來的某個日期，用戶端會將該權杖呈現給伺服器，但伺服器需要某種程度的保證，讓用戶端無法偽造權杖。</span><span class="sxs-lookup"><span data-stu-id="408be-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="408be-115">因此，第一項需求：真實性（也稱為</span><span class="sxs-lookup"><span data-stu-id="408be-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="408be-116">完整性、篡改檢查）。</span><span class="sxs-lookup"><span data-stu-id="408be-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="408be-117">由於伺服器會信任保存的狀態，因此我們預期此狀態可能包含作業環境的特定資訊。</span><span class="sxs-lookup"><span data-stu-id="408be-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="408be-118">這可能是檔案路徑的形式、許可權、控制碼或其他間接參考，或是伺服器特定資料的其他部分。</span><span class="sxs-lookup"><span data-stu-id="408be-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="408be-119">這類資訊通常不會洩漏給不受信任的用戶端。</span><span class="sxs-lookup"><span data-stu-id="408be-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="408be-120">因此第二個需求：機密性。</span><span class="sxs-lookup"><span data-stu-id="408be-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="408be-121">最後，由於現代化應用程式是元件化的，我們看到的是個別元件會想要利用此系統，而不考慮系統中的其他元件。</span><span class="sxs-lookup"><span data-stu-id="408be-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="408be-122">例如，如果持有人權杖元件使用此堆疊，它應該不會干擾可能也會使用相同堆疊的防 CSRF 機制。</span><span class="sxs-lookup"><span data-stu-id="408be-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="408be-123">因此，最終的需求如下：隔離。</span><span class="sxs-lookup"><span data-stu-id="408be-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="408be-124">我們可以提供進一步的條件約束，以便縮小需求的範圍。</span><span class="sxs-lookup"><span data-stu-id="408be-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="408be-125">我們假設在 cryptosystem 內運作的所有服務都同樣受到信任，而且不需要在直接控制下的服務以外產生或使用資料。</span><span class="sxs-lookup"><span data-stu-id="408be-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="408be-126">此外，因為每個 web 服務要求可能會經歷 cryptosystem 一次或多次，所以我們需要盡可能快速地執行作業。</span><span class="sxs-lookup"><span data-stu-id="408be-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="408be-127">這讓對稱式密碼編譯非常適合我們的案例，我們可以在需要的時間之前，為非對稱式密碼編譯提供折扣。</span><span class="sxs-lookup"><span data-stu-id="408be-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="408be-128">設計原理</span><span class="sxs-lookup"><span data-stu-id="408be-128">Design philosophy</span></span>

<span data-ttu-id="408be-129">我們從找出現有堆疊的問題開始。</span><span class="sxs-lookup"><span data-stu-id="408be-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="408be-130">一旦這麼做，我們會對現有解決方案的發展進行調查，並結束現有的解決方案並不具備我們所尋求的功能。</span><span class="sxs-lookup"><span data-stu-id="408be-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="408be-131">然後，我們會根據數個指導原則來設計解決方案。</span><span class="sxs-lookup"><span data-stu-id="408be-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="408be-132">系統應該提供簡單的設定。</span><span class="sxs-lookup"><span data-stu-id="408be-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="408be-133">在理想的情況下，系統會是零設定，而開發人員可能會遇到執行的基礎。</span><span class="sxs-lookup"><span data-stu-id="408be-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="408be-134">在開發人員需要設定特定方面（例如金鑰存放庫）的情況下，應提供考慮，讓這些特定設定變得簡單。</span><span class="sxs-lookup"><span data-stu-id="408be-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="408be-135">提供簡單取用者面向的 API。</span><span class="sxs-lookup"><span data-stu-id="408be-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="408be-136">Api 應該很容易使用，而且很難正確使用。</span><span class="sxs-lookup"><span data-stu-id="408be-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="408be-137">開發人員不應該學習金鑰管理原則。</span><span class="sxs-lookup"><span data-stu-id="408be-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="408be-138">系統應代表開發人員處理演算法選取和金鑰存留期。</span><span class="sxs-lookup"><span data-stu-id="408be-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="408be-139">在理想的情況下，開發人員永遠都不能存取未經處理的金鑰內容。</span><span class="sxs-lookup"><span data-stu-id="408be-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="408be-140">金鑰應盡可能在待用時受到保護。</span><span class="sxs-lookup"><span data-stu-id="408be-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="408be-141">系統應找出適當的預設保護機制，並自動套用。</span><span class="sxs-lookup"><span data-stu-id="408be-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="408be-142">考慮這些原則之後，我們開發了簡單、[容易使用](xref:security/data-protection/using-data-protection)的資料保護堆疊。</span><span class="sxs-lookup"><span data-stu-id="408be-142">With these principles in mind we developed a simple, [easy to use](xref:security/data-protection/using-data-protection) data protection stack.</span></span>

<span data-ttu-id="408be-143">ASP.NET Core 的資料保護 Api 主要不適用於機密承載的無限持續性。</span><span class="sxs-lookup"><span data-stu-id="408be-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="408be-144">其他技術（如[WINDOWS CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx)和[Azure Rights Management](/rights-management/) ）更適用于不限數量的儲存體案例，而且它們已有更強的金鑰管理功能。</span><span class="sxs-lookup"><span data-stu-id="408be-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="408be-145">話雖如此，開發人員也不會使用 ASP.NET Core 的資料保護 Api 來長期保護機密資料。</span><span class="sxs-lookup"><span data-stu-id="408be-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="408be-146">適用對象</span><span class="sxs-lookup"><span data-stu-id="408be-146">Audience</span></span>

<span data-ttu-id="408be-147">資料保護系統分成五個主要的封裝。</span><span class="sxs-lookup"><span data-stu-id="408be-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="408be-148">這些 Api 的各個層面都是以三個主要的物件為目標;</span><span class="sxs-lookup"><span data-stu-id="408be-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="408be-149">取用[者 Api 概述](xref:security/data-protection/consumer-apis/overview)目標應用程式和架構開發人員。</span><span class="sxs-lookup"><span data-stu-id="408be-149">The [Consumer APIs Overview](xref:security/data-protection/consumer-apis/overview) target application and framework developers.</span></span>

   <span data-ttu-id="408be-150">「我不想要瞭解堆疊的運作方式，或是它的設定方式。</span><span class="sxs-lookup"><span data-stu-id="408be-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="408be-151">我只是想要以簡單的方式在中執行一些作業，以成功使用 Api 的機率很高。」</span><span class="sxs-lookup"><span data-stu-id="408be-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="408be-152">設定[api](xref:security/data-protection/configuration/overview)會以應用程式開發人員和系統管理員為目標。</span><span class="sxs-lookup"><span data-stu-id="408be-152">The [configuration APIs](xref:security/data-protection/configuration/overview) target application developers and system administrators.</span></span>

   <span data-ttu-id="408be-153">「我需要告訴資料保護系統，我的環境需要非預設的路徑或設定。」</span><span class="sxs-lookup"><span data-stu-id="408be-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="408be-154">擴充性 Api 是以開發人員為目標，負責執行自訂原則。</span><span class="sxs-lookup"><span data-stu-id="408be-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="408be-155">這些 Api 的使用方式僅限於少數情況，以及經驗豐富的安全性感知開發人員。</span><span class="sxs-lookup"><span data-stu-id="408be-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="408be-156">「我需要更換系統內的整個元件，因為我有真正獨特的行為需求。</span><span class="sxs-lookup"><span data-stu-id="408be-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="408be-157">我願意學習 API 介面的不常用使用部分，以建立可滿足我的需求的外掛程式。」</span><span class="sxs-lookup"><span data-stu-id="408be-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="408be-158">封裝版面配置</span><span class="sxs-lookup"><span data-stu-id="408be-158">Package layout</span></span>

<span data-ttu-id="408be-159">資料保護堆疊是由五個封裝所組成。</span><span class="sxs-lookup"><span data-stu-id="408be-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="408be-160">[AspNetCore. DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/)包含 <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> 建立資料保護服務的和介面。</span><span class="sxs-lookup"><span data-stu-id="408be-160">[Microsoft.AspNetCore.DataProtection.Abstractions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/) contains the <xref:Microsoft.AspNetCore.DataProtection.IDataProtectionProvider> and <xref:Microsoft.AspNetCore.DataProtection.IDataProtector> interfaces to create data protection services.</span></span> <span data-ttu-id="408be-161">它也包含有用的擴充方法來使用這些類型（例如， [idataprotector 加密](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)）。</span><span class="sxs-lookup"><span data-stu-id="408be-161">It also contains useful extension methods for working with these types (for example, [IDataProtector.Protect](xref:Microsoft.AspNetCore.DataProtection.DataProtectionCommonExtensions.Protect*)).</span></span> <span data-ttu-id="408be-162">如果資料保護系統在別處具現化，而且您正在使用 API，請參考 `Microsoft.AspNetCore.DataProtection.Abstractions` 。</span><span class="sxs-lookup"><span data-stu-id="408be-162">If the data protection system is instantiated elsewhere and you're consuming the API, reference `Microsoft.AspNetCore.DataProtection.Abstractions`.</span></span>

* <span data-ttu-id="408be-163">[AspNetCore. DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/)包含資料保護系統的核心實行，包括核心密碼編譯作業、金鑰管理、設定和擴充性。</span><span class="sxs-lookup"><span data-stu-id="408be-163">[Microsoft.AspNetCore.DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection/) contains the core implementation of the data protection system, including core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="408be-164">若要具現化資料保護系統（例如，將其新增至 <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection> ），或修改或擴充其行為，請參考 `Microsoft.AspNetCore.DataProtection` 。</span><span class="sxs-lookup"><span data-stu-id="408be-164">To instantiate the data protection system (for example, adding it to an <xref:Microsoft.Extensions.DependencyInjection.IServiceCollection>) or modifying or extending its behavior, reference `Microsoft.AspNetCore.DataProtection`.</span></span>

* <span data-ttu-id="408be-165">[AspNetCore. DataProtection](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/)包含額外的 api，開發人員可能會發現有用但不屬於核心套件。</span><span class="sxs-lookup"><span data-stu-id="408be-165">[Microsoft.AspNetCore.DataProtection.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Extensions/) contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="408be-166">例如，此套件包含 factory 方法，可將資料保護系統具現化，以將金鑰儲存在檔案系統上的位置，而不需要相依性插入（請參閱 <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider> ）。</span><span class="sxs-lookup"><span data-stu-id="408be-166">For instance, this package contains factory methods to instantiate the data protection system to store keys at a location on the file system without dependency injection (see <xref:Microsoft.AspNetCore.DataProtection.DataProtectionProvider>).</span></span> <span data-ttu-id="408be-167">它也包含限制受保護裝載之存留期的擴充方法（請參閱 <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector> ）。</span><span class="sxs-lookup"><span data-stu-id="408be-167">It also contains extension methods for limiting the lifetime of protected payloads (see <xref:Microsoft.AspNetCore.DataProtection.ITimeLimitedDataProtector>).</span></span>

* <span data-ttu-id="408be-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/)可以安裝在現有的 ASP.NET 4.x 應用程式中，以將其 `<machineKey>` 作業重新導向至使用新的 ASP.NET Core 資料保護堆疊。</span><span class="sxs-lookup"><span data-stu-id="408be-168">[Microsoft.AspNetCore.DataProtection.SystemWeb](https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.SystemWeb/) can be installed into an existing ASP.NET 4.x app to redirect its `<machineKey>` operations to use the new ASP.NET Core data protection stack.</span></span> <span data-ttu-id="408be-169">如需詳細資訊，請參閱 <xref:security/data-protection/compatibility/replacing-machinekey> 。</span><span class="sxs-lookup"><span data-stu-id="408be-169">For more information, see <xref:security/data-protection/compatibility/replacing-machinekey>.</span></span>

* <span data-ttu-id="408be-170">[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/)會提供 PBKDF2 密碼雜湊常式的執行，並可供必須安全處理使用者密碼的系統使用。</span><span class="sxs-lookup"><span data-stu-id="408be-170">[Microsoft.AspNetCore.Cryptography.KeyDerivation](https://www.nuget.org/packages/Microsoft.AspNetCore.Cryptography.KeyDerivation/) provides an implementation of the PBKDF2 password hashing routine and can be used by systems that must handle user passwords securely.</span></span> <span data-ttu-id="408be-171">如需詳細資訊，請參閱 <xref:security/data-protection/consumer-apis/password-hashing> 。</span><span class="sxs-lookup"><span data-stu-id="408be-171">For more information, see <xref:security/data-protection/consumer-apis/password-hashing>.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="408be-172">其他資源</span><span class="sxs-lookup"><span data-stu-id="408be-172">Additional resources</span></span>

<xref:host-and-deploy/web-farm>
