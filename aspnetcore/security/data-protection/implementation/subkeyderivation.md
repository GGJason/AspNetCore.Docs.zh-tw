---
title: 子機碼衍生和 ASP.NET Core 中已驗證的加密
author: rick-anderson
description: 了解 ASP.NET Core 資料保護的實作詳細資料子機碼衍生和驗證加密。
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: a1afd04758e663d7062a5bfa8a0d4dca38f42afc
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/20/2018
ms.locfileid: "36275719"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="1bede-103">子機碼衍生和 ASP.NET Core 中已驗證的加密</span><span class="sxs-lookup"><span data-stu-id="1bede-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="1bede-104">會包含某種形式的 entropy 鑰匙圈中大部分的索引鍵，而且必須演算資訊指出"CBC 模式加密 + HMAC 驗證 」 或 「 GCM 加密 + 驗證 」。</span><span class="sxs-lookup"><span data-stu-id="1bede-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="1bede-105">在這些情況下，我們將內嵌的 entropy 稱為主要金鑰處理內容 （或金鑰管理），此索引鍵，和我們執行金鑰衍生功能來衍生金鑰會用於實際的密碼編譯作業。</span><span class="sxs-lookup"><span data-stu-id="1bede-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="1bede-106">索引鍵是抽象類別，並自訂實作可能無法運作，如下所示。</span><span class="sxs-lookup"><span data-stu-id="1bede-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="1bede-107">如果索引鍵提供自己的實作`IAuthenticatedEncryptor`而不是使用我們的內建處理站的其中一個，這一節所述的機制就不再適用。</span><span class="sxs-lookup"><span data-stu-id="1bede-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="1bede-108">其他的已驗證的資料和子機碼衍生</span><span class="sxs-lookup"><span data-stu-id="1bede-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="1bede-109">`IAuthenticatedEncryptor`介面做為所有已驗證的加密作業的核心介面。</span><span class="sxs-lookup"><span data-stu-id="1bede-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="1bede-110">其`Encrypt`方法會採用兩個緩衝區： 純文字和 additionalAuthenticatedData (AAD)。</span><span class="sxs-lookup"><span data-stu-id="1bede-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="1bede-111">純文字內容流量未變更的呼叫`IDataProtector.Protect`，但 AAD 由系統產生，並包含三個元件：</span><span class="sxs-lookup"><span data-stu-id="1bede-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="1bede-112">32 位元 magic 標頭 09 F0 C9 F0 可識別此版本的資料保護系統。</span><span class="sxs-lookup"><span data-stu-id="1bede-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="1bede-113">128 位元的金鑰識別碼。</span><span class="sxs-lookup"><span data-stu-id="1bede-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="1bede-114">可變長度字串所組成的用途鏈結建立`IDataProtector`，正在執行此作業。</span><span class="sxs-lookup"><span data-stu-id="1bede-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="1bede-115">因為 AAD 都是唯一的所有三個元件的 tuple，我們可以用它來衍生自金鑰管理的新機碼，而不是使用金鑰管理本身在所有的密碼編譯作業。</span><span class="sxs-lookup"><span data-stu-id="1bede-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="1bede-116">若要每次呼叫`IAuthenticatedEncryptor.Encrypt`，下列的金鑰衍生處理序會發生：</span><span class="sxs-lookup"><span data-stu-id="1bede-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="1bede-117">（K_E、 K_H） = SP800_108_CTR_HMACSHA512 (K_M，AAD，contextHeader | | keyModifier)</span><span class="sxs-lookup"><span data-stu-id="1bede-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="1bede-118">在這裡，我們正在撥打 NIST SP800 108 KDF 計數器模式中 (請參閱[NIST SP800 108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)，秒 5.1) 使用下列參數：</span><span class="sxs-lookup"><span data-stu-id="1bede-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="1bede-119">金鑰衍生金鑰 (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="1bede-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="1bede-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="1bede-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="1bede-121">標籤 = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="1bede-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="1bede-122">內容 = contextHeader | |keyModifier</span><span class="sxs-lookup"><span data-stu-id="1bede-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="1bede-123">內容標頭是可變長度，基本上是我們要為其衍生 K_E 與 K_H 演算法的憑證指紋。</span><span class="sxs-lookup"><span data-stu-id="1bede-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="1bede-124">索引鍵的修飾詞是隨機產生的每個呼叫的 128 位元字串`Encrypt`，並提供服務，以確保與過度機率，KE 和 KH 是唯一的這項特定的驗證加密作業，即使所有其他輸入 KDF 是常數。</span><span class="sxs-lookup"><span data-stu-id="1bede-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="1bede-125">CBC 模式加密 + HMAC 驗證作業，|K_E |這是對稱的區塊加密金鑰的長度和 |K_H |是摘要的大小 HMAC 常式。</span><span class="sxs-lookup"><span data-stu-id="1bede-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="1bede-126">GCM 加密 + 驗證作業 |K_H |= 0。</span><span class="sxs-lookup"><span data-stu-id="1bede-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="1bede-127">CBC 模式加密 + HMAC 驗證</span><span class="sxs-lookup"><span data-stu-id="1bede-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="1bede-128">一旦 K_E 透過上述的機制來產生，我們會產生隨機初始化向量，並執行 encipher 純文字的對稱的區塊加密演算法。</span><span class="sxs-lookup"><span data-stu-id="1bede-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="1bede-129">初始化向量和加密文字然後透過具有索引鍵來產生 MAC K_H 初始化 HMAC 常式執行</span><span class="sxs-lookup"><span data-stu-id="1bede-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="1bede-130">此程序以及傳回值會以圖形方式以下表示。</span><span class="sxs-lookup"><span data-stu-id="1bede-130">This process and the return value is represented graphically below.</span></span>

![CBC 模式的程序，並傳回](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="1bede-132">*輸出: = keyModifier | |iv | |E_cbc （K_E，iv，資料） | |HMAC (K_H、 iv | |E_cbc （K_E，iv，資料）)*</span><span class="sxs-lookup"><span data-stu-id="1bede-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="1bede-133">`IDataProtector.Protect`實作將[magic 標頭和索引鍵的識別碼，前面加上](xref:security/data-protection/implementation/authenticated-encryption-details)輸出傳回給呼叫者之前。</span><span class="sxs-lookup"><span data-stu-id="1bede-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="1bede-134">因為 magic 標頭和索引鍵識別碼是隱含的一部分[AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)，因為索引鍵的修飾詞做為輸入至 KDF 回饋，這也表示，每個單一位元組的最後一個傳回的內容由 MAC 驗證</span><span class="sxs-lookup"><span data-stu-id="1bede-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="1bede-135">Galois/計數器模式加密 + 驗證</span><span class="sxs-lookup"><span data-stu-id="1bede-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="1bede-136">一旦 K_E 透過上述的機制來產生，我們會產生隨機的 96 位元 nonce，並執行 encipher 純文字，並產生 128 位元的驗證標記對稱的區塊加密演算法。</span><span class="sxs-lookup"><span data-stu-id="1bede-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM 模式程序，並傳回](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="1bede-138">*輸出: = keyModifier | |nonce | |E_gcm （K_E，nonce，資料） | |authTag*</span><span class="sxs-lookup"><span data-stu-id="1bede-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="1bede-139">即使 GCM 原生支援 AAD 的概念，我們正在仍饋送 AAD 只以原始 KDF，選擇將其 AAD 參數，傳遞至 GCM 的空字串。</span><span class="sxs-lookup"><span data-stu-id="1bede-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="1bede-140">這是一體兩面。</span><span class="sxs-lookup"><span data-stu-id="1bede-140">The reason for this is two-fold.</span></span> <span data-ttu-id="1bede-141">首先，[支援靈活度](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers)我們永遠不會想要直接將 K_M 作為加密金鑰。</span><span class="sxs-lookup"><span data-stu-id="1bede-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="1bede-142">此外，GCM 會加諸其輸入上非常嚴格的唯一性。</span><span class="sxs-lookup"><span data-stu-id="1bede-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="1bede-143">GCM 加密常式為曾經叫用在兩個或更多相異的可能性設定具有相同 （金鑰、 nonce） 的輸入資料組不能超過 2 ^32。</span><span class="sxs-lookup"><span data-stu-id="1bede-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="1bede-144">如果我們修正 K_E 我們無法執行超過 2 ^32 的加密作業之前，我們執行與的 2 ^-32 限制。</span><span class="sxs-lookup"><span data-stu-id="1bede-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="1bede-145">這看起來像是非常大量的作業，但高流量的網頁伺服器可以透過 4 10 億個要求，這些機碼正常的存留期間內只天數。</span><span class="sxs-lookup"><span data-stu-id="1bede-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="1bede-146">若要保持相容的 2 ^-32 機率限制，我們將繼續使用 128 位元金鑰的修飾詞和 96 位元 nonce，徹底擴充任何給定 K_M 的可用作業計數。</span><span class="sxs-lookup"><span data-stu-id="1bede-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="1bede-147">我們在設計的簡易性共用 CBC 及 GCM 作業之間的 KDF 程式碼路徑，因為 AAD KDF 中已被視為不是需要將其轉寄給 GCM 常式。</span><span class="sxs-lookup"><span data-stu-id="1bede-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
