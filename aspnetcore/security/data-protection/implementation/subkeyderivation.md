---
title: ASP.NET Core 中的子機碼衍生和驗證加密
author: rick-anderson
description: 瞭解 ASP.NET Core 資料保護子機碼衍生和驗證加密的執行詳細資料。
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: d8038142ccb2597eb1c98738307b8b9a842dae5a
ms.sourcegitcommit: 65add17f74a29a647d812b04517e46cbc78258f9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/19/2020
ms.locfileid: "88630116"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="b462a-103">ASP.NET Core 中的子機碼衍生和驗證加密</span><span class="sxs-lookup"><span data-stu-id="b462a-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="b462a-104">金鑰通道中的大部分金鑰都會包含某種形式的熵，而且會有說明「CBC 模式加密 + HMAC 驗證」或「GCM 加密 + 驗證」的演算法資訊。</span><span class="sxs-lookup"><span data-stu-id="b462a-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="b462a-105">在這些情況下，我們會將內嵌的熵稱為此金鑰的主要金鑰處理 (或公里) ，我們會執行金鑰衍生函式，以衍生將用於實際密碼編譯作業的金鑰。</span><span class="sxs-lookup"><span data-stu-id="b462a-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="b462a-106">索引鍵為抽象，自訂執行的行為可能不會如下所示。</span><span class="sxs-lookup"><span data-stu-id="b462a-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="b462a-107">如果金鑰提供自己的執行 `IAuthenticatedEncryptor` ，而不是使用其中一個內建 factory，則本節所述的機制不再適用。</span><span class="sxs-lookup"><span data-stu-id="b462a-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="b462a-108">其他已驗證的資料和子機碼衍生</span><span class="sxs-lookup"><span data-stu-id="b462a-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="b462a-109">`IAuthenticatedEncryptor`介面會作為所有已驗證加密作業的核心介面。</span><span class="sxs-lookup"><span data-stu-id="b462a-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="b462a-110">其 `Encrypt` 方法採用兩個緩衝區：純文字和 additionalAuthenticatedData (AAD) 。</span><span class="sxs-lookup"><span data-stu-id="b462a-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="b462a-111">純文字內容的流程未變更為 `IDataProtector.Protect` ，但 AAD 是由系統產生，並且包含三個元件：</span><span class="sxs-lookup"><span data-stu-id="b462a-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="b462a-112">指出此版本資料保護系統的32位魔術標頭 09 F0 C9 F0。</span><span class="sxs-lookup"><span data-stu-id="b462a-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="b462a-113">128位金鑰識別碼。</span><span class="sxs-lookup"><span data-stu-id="b462a-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="b462a-114">從建立執行此作業之的目的鏈所形成的可變長度字串 `IDataProtector` 。</span><span class="sxs-lookup"><span data-stu-id="b462a-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="b462a-115">由於 AAD 對於這三個元件的元組而言是唯一的，因此我們可以使用它來從公里衍生新的金鑰，而不是在我們的所有密碼編譯作業中使用公里本身。</span><span class="sxs-lookup"><span data-stu-id="b462a-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="b462a-116">每次呼叫時 `IAuthenticatedEncryptor.Encrypt` ，都會發生下列金鑰衍生程式：</span><span class="sxs-lookup"><span data-stu-id="b462a-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

`( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)`

<span data-ttu-id="b462a-117">在此，我們會在計數器模式中呼叫 NIST SP800-108 KDF (查看 [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf)，Sec. 5.1) 具有下列參數：</span><span class="sxs-lookup"><span data-stu-id="b462a-117">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="b462a-118">金鑰衍生金鑰 (KDK) = `K_M`</span><span class="sxs-lookup"><span data-stu-id="b462a-118">Key derivation key (KDK) = `K_M`</span></span>

* <span data-ttu-id="b462a-119">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="b462a-119">PRF = HMACSHA512</span></span>

* <span data-ttu-id="b462a-120">標籤 = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="b462a-120">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="b462a-121">coNtext = coNtextHeader | |keyModifier</span><span class="sxs-lookup"><span data-stu-id="b462a-121">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="b462a-122">內容標頭的長度是可變的，基本上是作為我們所衍生的演算法的指紋 `K_E` `K_H` 。</span><span class="sxs-lookup"><span data-stu-id="b462a-122">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving `K_E` and `K_H`.</span></span> <span data-ttu-id="b462a-123">Key 修飾詞是針對的每個呼叫隨機產生的128位字串 `Encrypt` ，可確保在此特定驗證加密作業中，KE 和 KH 是唯一的機率，即使 KDF 的所有其他輸入都是常數。</span><span class="sxs-lookup"><span data-stu-id="b462a-123">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="b462a-124">在 CBC 模式加密 + HMAC 驗證作業中， `| K_E |` 是對稱區塊加密金鑰的長度，而且 `| K_H |` 是 HMAC 常式的摘要大小。</span><span class="sxs-lookup"><span data-stu-id="b462a-124">For CBC-mode encryption + HMAC validation operations, `| K_E |` is the length of the symmetric block cipher key, and `| K_H |` is the digest size of the HMAC routine.</span></span> <span data-ttu-id="b462a-125">適用于 GCM 加密 + 驗證作業 `| K_H | = 0` 。</span><span class="sxs-lookup"><span data-stu-id="b462a-125">For GCM encryption + validation operations, `| K_H | = 0`.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="b462a-126">CBC 模式加密 + HMAC 驗證</span><span class="sxs-lookup"><span data-stu-id="b462a-126">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="b462a-127">一旦透過 `K_E` 上述機制產生，我們會產生隨機的初始化向量並執行對稱封鎖密碼演算法，以加密純文字。</span><span class="sxs-lookup"><span data-stu-id="b462a-127">Once `K_E` is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="b462a-128">初始化向量和加密文字接著會透過以金鑰初始化的 HMAC 常式來執行， `K_H` 以產生 MAC。</span><span class="sxs-lookup"><span data-stu-id="b462a-128">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key `K_H` to produce the MAC.</span></span> <span data-ttu-id="b462a-129">此進程和傳回值以圖形方式呈現。</span><span class="sxs-lookup"><span data-stu-id="b462a-129">This process and the return value is represented graphically below.</span></span>

![CBC 模式進程和傳回](subkeyderivation/_static/cbcprocess.png)

`output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))`

> [!NOTE]
> <span data-ttu-id="b462a-131">在 `IDataProtector.Protect` 將 [魔術標頭和金鑰識別碼](xref:security/data-protection/implementation/authenticated-encryption-details) 傳回給呼叫者之前，會先在其上加上此實作為輸出。</span><span class="sxs-lookup"><span data-stu-id="b462a-131">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="b462a-132">由於魔術標頭和金鑰識別碼是 [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad)的一部分，而且因為金鑰修飾詞會以輸入的形式饋送至 KDF，這表示最後傳回的承載的每個位元組都是由 MAC 進行驗證。</span><span class="sxs-lookup"><span data-stu-id="b462a-132">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="b462a-133">Galois/計數器模式加密 + 驗證</span><span class="sxs-lookup"><span data-stu-id="b462a-133">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="b462a-134">一旦透過 `K_E` 上述機制產生，我們會產生隨機的96位 nonce 並執行對稱封鎖密碼演算法，以加密純文字並產生128位驗證標記。</span><span class="sxs-lookup"><span data-stu-id="b462a-134">Once `K_E` is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM 模式的進程和退貨](subkeyderivation/_static/galoisprocess.png)

`output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag`

> [!NOTE]
> <span data-ttu-id="b462a-136">雖然 GCM 原生支援 AAD 的概念，但我們還是只會將 AAD 饋送至原始 KDF，選擇將空字串傳遞至 GCM 以取得其 AAD 參數。</span><span class="sxs-lookup"><span data-stu-id="b462a-136">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="b462a-137">這是兩個折迭的原因。</span><span class="sxs-lookup"><span data-stu-id="b462a-137">The reason for this is two-fold.</span></span> <span data-ttu-id="b462a-138">首先， [為了支援靈活性](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) ，我們絕對不想要 `K_M` 直接使用加密金鑰。</span><span class="sxs-lookup"><span data-stu-id="b462a-138">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use `K_M` directly as the encryption key.</span></span> <span data-ttu-id="b462a-139">此外，GCM 對其輸入強加嚴格的唯一性需求。</span><span class="sxs-lookup"><span data-stu-id="b462a-139">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="b462a-140">在兩個或多個不同的輸入資料集上，使用相同的 (機碼來叫用 GCM 加密常式的機率，nonce) 組不得超過 2 ^ 32。</span><span class="sxs-lookup"><span data-stu-id="b462a-140">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="b462a-141">如果我們修正了我們在執行 `K_E` 2 ^-32 限制的 afoul 之前，無法執行超過 2 ^ 32 個加密作業。</span><span class="sxs-lookup"><span data-stu-id="b462a-141">If we fix `K_E` we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="b462a-142">這看起來可能像是非常大量的作業，但高流量的 web 伺服器可以只在這些金鑰的正常存留期內，在單純的天數內進行4000000000的要求。</span><span class="sxs-lookup"><span data-stu-id="b462a-142">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="b462a-143">為了維持符合 2 ^-32 機率限制的規範，我們會繼續使用128位金鑰修飾詞和96位 nonce，以大幅擴充任何給定的可用作業計數 `K_M` 。</span><span class="sxs-lookup"><span data-stu-id="b462a-143">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given `K_M`.</span></span> <span data-ttu-id="b462a-144">為了簡化設計，我們會在 CBC 與 GCM 作業之間共用 KDF 程式碼路徑，而且因為 KDF 中已考慮 AAD，所以不需要將它轉寄到 GCM 常式。</span><span class="sxs-lookup"><span data-stu-id="b462a-144">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
