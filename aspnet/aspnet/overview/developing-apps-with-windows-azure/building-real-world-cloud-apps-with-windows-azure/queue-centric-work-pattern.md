---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: 佇列為主的工作模式 （使用 Azure 建置實際的雲端應用程式） |Microsoft 文件
author: MikeWasson
description: Scott Guthrie 所開發的簡報是以基礎建置真實世界雲端應用程式與 Azure 的電子書。 它說明 13 模式和做法，他可以...
ms.author: aspnetcontent
manager: wpickett
ms.date: 06/12/2014
ms.topic: article
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
ms.technology: ''
ms.prod: .net-framework
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: 124e673206ecea2eac5efb8c2802a32a690fa104
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2018
ms.locfileid: "30875431"
---
<a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="76949-104">佇列為主的工作模式 （使用 Azure 建置實際的雲端應用程式）</span><span class="sxs-lookup"><span data-stu-id="76949-104">Queue-Centric Work Pattern (Building Real-World Cloud Apps with Azure)</span></span>
====================
<span data-ttu-id="76949-105">由[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson](https://github.com/Rick-Anderson)， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="76949-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://github.com/Rick-Anderson), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="76949-106">[下載修正專案](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下載電子書](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="76949-106">[Download Fix It Project](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="76949-107">**建置真實世界雲端應用程式與 Azure**電子書根據 Scott Guthrie 所開發的簡報。</span><span class="sxs-lookup"><span data-stu-id="76949-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="76949-108">它說明 13 模式，並可協助您的作法是成功開發雲端的 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="76949-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="76949-109">E 書籍的相關資訊，請參閱[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="76949-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>


<span data-ttu-id="76949-110">舊版中，我們所見，使用多個服務可能會導致 「 複合"SLA、 應用程式的有效 SLA 所在*產品*的個別的 Sla。</span><span class="sxs-lookup"><span data-stu-id="76949-110">Earlier, we saw that using multiple services can result in a "composite" SLA, where the app's effective SLA is the *product* of the individual SLAs.</span></span> <span data-ttu-id="76949-111">例如，它修正應用程式所使用的網站、 儲存和 SQL Database。</span><span class="sxs-lookup"><span data-stu-id="76949-111">For example, the Fix It app uses Web Sites, Storage, and SQL Database.</span></span> <span data-ttu-id="76949-112">如果這些服務的任何一個失敗時，應用程式會傳回錯誤給使用者。</span><span class="sxs-lookup"><span data-stu-id="76949-112">If any one of these services fails, the app will return an error to the user.</span></span>

<span data-ttu-id="76949-113">快取是好的方法來處理暫時性失敗的唯讀內容。</span><span class="sxs-lookup"><span data-stu-id="76949-113">Caching is a good way to handle transient failures for read-only content.</span></span> <span data-ttu-id="76949-114">但如果您的應用程式需要來執行工作？</span><span class="sxs-lookup"><span data-stu-id="76949-114">But what if your application needs to do work?</span></span> <span data-ttu-id="76949-115">比方說，當使用者提交新修正它的工作，應用程式無法只將工作放入快取。</span><span class="sxs-lookup"><span data-stu-id="76949-115">For example, when the user submits a new Fix It task, the app can't just put the task into the cache.</span></span> <span data-ttu-id="76949-116">應用程式需要修正它工作寫入至永續性資料存放區，因此可處理。</span><span class="sxs-lookup"><span data-stu-id="76949-116">The app needs to write the Fix It task into a persistent data store, so it can be processed.</span></span>

<span data-ttu-id="76949-117">是以佇列為中心的工作模式的運作方式。</span><span class="sxs-lookup"><span data-stu-id="76949-117">That's where the queue-centric work pattern comes in.</span></span> <span data-ttu-id="76949-118">此模式可讓 web 層和後端服務之間的鬆散偶合。</span><span class="sxs-lookup"><span data-stu-id="76949-118">This pattern enables loose coupling between a web tier and a backend service.</span></span>

<span data-ttu-id="76949-119">模式的運作方式如下。</span><span class="sxs-lookup"><span data-stu-id="76949-119">Here's how the pattern works.</span></span> <span data-ttu-id="76949-120">當應用程式取得要求時，它會將工作項目放入佇列，並立即傳回回應。</span><span class="sxs-lookup"><span data-stu-id="76949-120">When the application gets a request, it puts a work item onto a queue and immediately returns the response.</span></span> <span data-ttu-id="76949-121">然後個別的後端程序提取從佇列的工作項目，並執行這項工作。</span><span class="sxs-lookup"><span data-stu-id="76949-121">Then a separate backend process pulls work items from the queue and does the work.</span></span>

<span data-ttu-id="76949-122">佇列為主的工作模式可用於：</span><span class="sxs-lookup"><span data-stu-id="76949-122">The queue-centric work pattern is useful for:</span></span>

- <span data-ttu-id="76949-123">工作所耗用的時間 （高延遲）。</span><span class="sxs-lookup"><span data-stu-id="76949-123">Work that is time consuming (high latency).</span></span>
- <span data-ttu-id="76949-124">需要的工作，可能永遠無法使用的外部服務。</span><span class="sxs-lookup"><span data-stu-id="76949-124">Work that requires an external service that might not always be available.</span></span>
- <span data-ttu-id="76949-125">也就是使用大量的資源 (CPU 高)。</span><span class="sxs-lookup"><span data-stu-id="76949-125">Work that is resource-intensive (high CPU).</span></span>
- <span data-ttu-id="76949-126">而獲益率調節 （受限於突然負載暴增） 的工作。</span><span class="sxs-lookup"><span data-stu-id="76949-126">Work that would benefit from rate leveling (subject to sudden load bursts).</span></span>

## <a name="reduced-latency"></a><span data-ttu-id="76949-127">減少的延遲</span><span class="sxs-lookup"><span data-stu-id="76949-127">Reduced Latency</span></span>

<span data-ttu-id="76949-128">佇列是的每當您在進行耗時的工作很有用。</span><span class="sxs-lookup"><span data-stu-id="76949-128">Queues are useful any time you are doing time-consuming work.</span></span> <span data-ttu-id="76949-129">如果工作需要幾秒鐘，或更久，而不會封鎖使用者，將工作項目放入佇列。</span><span class="sxs-lookup"><span data-stu-id="76949-129">If a task takes a few seconds or longer, instead of blocking the end user, put the work item into a queue.</span></span> <span data-ttu-id="76949-130">告訴使用者 「 我們正努力，"，然後處理在背景工作使用的佇列接聽程式。</span><span class="sxs-lookup"><span data-stu-id="76949-130">Tell the user "We're working on it," and then use a queue listener to process the task in the background.</span></span>

<span data-ttu-id="76949-131">例如，某項目在線上零售店購買之後，網站會確認您的訂單立即。</span><span class="sxs-lookup"><span data-stu-id="76949-131">For example, when you purchase something at an online retailer, the web site confirms your order immediately.</span></span> <span data-ttu-id="76949-132">但並不表示您的資料已經傳遞中。</span><span class="sxs-lookup"><span data-stu-id="76949-132">But that doesn't mean your stuff is already in a truck being delivered.</span></span> <span data-ttu-id="76949-133">他們將工作放在佇列中，以及在背景中進行信用查核，準備用於出貨，您的項目和這些等。</span><span class="sxs-lookup"><span data-stu-id="76949-133">They put a task in a queue, and in the background they are doing the credit check, preparing your items for shipping, and so forth.</span></span>

<span data-ttu-id="76949-134">短延遲的情況下，端對端時間總計可能較長的使用佇列，相較於以同步方式執行該工作。</span><span class="sxs-lookup"><span data-stu-id="76949-134">For scenarios with short latency, the total end-to-end time might be longer using a queue, compared with doing the task synchronously.</span></span> <span data-ttu-id="76949-135">但即使如此，其他好處可能會超過該缺點。</span><span class="sxs-lookup"><span data-stu-id="76949-135">But even then, the other benefits can outweigh that disadvantage.</span></span>

## <a name="increased-reliability"></a><span data-ttu-id="76949-136">增加的可靠性</span><span class="sxs-lookup"><span data-stu-id="76949-136">Increased Reliability</span></span>

<span data-ttu-id="76949-137">修正它，我們探討了到目前為止的版本，在與 SQL 資料庫後端緊密結合的 web 前端。</span><span class="sxs-lookup"><span data-stu-id="76949-137">In the version of Fix It that we've been looking at so far, the web front-end is tightly coupled with the SQL Database back-end.</span></span> <span data-ttu-id="76949-138">如果 SQL database 服務無法使用，使用者會收到錯誤。</span><span class="sxs-lookup"><span data-stu-id="76949-138">If the SQL database service is unavailable, the user gets an error.</span></span> <span data-ttu-id="76949-139">如果重試無法運作 （也就是失敗是多個暫時性），的唯一可以執行的是顯示錯誤，並要求使用者再試一次。</span><span class="sxs-lookup"><span data-stu-id="76949-139">If retries don't work (that is, the failure is more than transient), the only thing you can do is show an error and ask the user to try again later.</span></span>

![圖表顯示的 web 前端失敗的 SQL 資料庫後端失敗時](queue-centric-work-pattern/_static/image1.png)

<span data-ttu-id="76949-141">使用者提交修正其工作時，請使用佇列，應用程式可以將訊息寫入佇列。</span><span class="sxs-lookup"><span data-stu-id="76949-141">Using queues, when a user submits a Fix It task, the app writes a message to the queue.</span></span> <span data-ttu-id="76949-142">訊息內容是[JSON](http://json.org/)工作的表示法。</span><span class="sxs-lookup"><span data-stu-id="76949-142">The message payload is a [JSON](http://json.org/) representation of the task.</span></span> <span data-ttu-id="76949-143">將訊息寫入至佇列，因為應用程式會傳回，並立即向使用者顯示成功訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-143">As soon as the message is written to the queue, the app returns and immediately shows a success message to the user.</span></span>

<span data-ttu-id="76949-144">如果任何 – 例如，SQL database 或佇列接聽程式--後端服務都離線時，使用者仍然可以提交新修正它的工作。</span><span class="sxs-lookup"><span data-stu-id="76949-144">If any of the backend services – such as the SQL database or the queue listener -- go offline, users can still submit new Fix It tasks.</span></span> <span data-ttu-id="76949-145">直到後端服務再度變成可用，只會將佇列訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-145">The messages will just queue up until the backend services are available again.</span></span> <span data-ttu-id="76949-146">此時後, 端服務會跟上待處理項目。</span><span class="sxs-lookup"><span data-stu-id="76949-146">At that point, the backend services will catch up on the backlog.</span></span>

![Web 前端繼續運作，SQL Database 錯誤時所顯示的圖表](queue-centric-work-pattern/_static/image2.png)

<span data-ttu-id="76949-148">此外，現在您可以新增更多的後端邏輯而不需擔心前端的恢復功能。</span><span class="sxs-lookup"><span data-stu-id="76949-148">Moreover, now you can add more backend logic without worrying about the resiliency of the front end.</span></span> <span data-ttu-id="76949-149">例如，您可以將電子郵件或 SMS 訊息傳送至擁有者，每當新修正它被指派。</span><span class="sxs-lookup"><span data-stu-id="76949-149">For example, you might want to send an email or SMS message to the owner whenever a new Fix It is assigned.</span></span> <span data-ttu-id="76949-150">如果電子郵件或 SMS 服務變成無法使用，可處理其他所有項目，然後再將訊息放入不同的佇列來傳送電子郵件/SMS 訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-150">If the email or SMS service becomes unavailable, you can process everything else, and then put a message into a separate queue for sending email/SMS messages.</span></span>

<span data-ttu-id="76949-151">之前，我們有效的 SLA 是 Web 應用程式&times;儲存體&times;SQL Database = 99.7%。</span><span class="sxs-lookup"><span data-stu-id="76949-151">Previously, our effective SLA was Web Apps &times; Storage &times; SQL Database = 99.7%.</span></span> <span data-ttu-id="76949-152">(請參閱[存留失敗設計](design-to-survive-failures.md)。)</span><span class="sxs-lookup"><span data-stu-id="76949-152">(See [Design to Survive Failures](design-to-survive-failures.md).)</span></span>

<span data-ttu-id="76949-153">當我們變更應用程式使用的佇列時，web 前端只依賴 Web 應用程式和儲存體，複合應用 99.8%的 SLA。</span><span class="sxs-lookup"><span data-stu-id="76949-153">When we change the app to use a queue, the web front end depends only on Web Apps and Storage, for a composite SLA of 99.8%.</span></span> <span data-ttu-id="76949-154">（請注意佇列是 Azure 儲存體服務的一部分，因此它們會包含在相同的 SLA 為 blob 儲存體）。</span><span class="sxs-lookup"><span data-stu-id="76949-154">(Note that queues are part of the Azure storage service, so they are included in the same SLA as blob storage.)</span></span>

<span data-ttu-id="76949-155">如果您需要比 99.8%甚至更好，您可以在兩個不同區域中建立兩個佇列。</span><span class="sxs-lookup"><span data-stu-id="76949-155">If you need even better than 99.8%, you can create two queues in two different regions.</span></span> <span data-ttu-id="76949-156">將一個當做主要資料庫，而另一個指定為次要資料庫。</span><span class="sxs-lookup"><span data-stu-id="76949-156">Designate one as the primary, and the other as the secondary.</span></span> <span data-ttu-id="76949-157">在您的應用程式容錯移轉至次要佇列如果主要佇列無法使用。</span><span class="sxs-lookup"><span data-stu-id="76949-157">In your app, fail over to the secondary queue if the primary queue is not available.</span></span> <span data-ttu-id="76949-158">這兩個無法在同一時間的機會便相當小。</span><span class="sxs-lookup"><span data-stu-id="76949-158">The chance of both being unavailable at the same time is very small.</span></span>

## <a name="rate-leveling-and-independent-scaling"></a><span data-ttu-id="76949-159">速率均衡，以及獨立縮放比例</span><span class="sxs-lookup"><span data-stu-id="76949-159">Rate Leveling and Independent Scaling</span></span>

<span data-ttu-id="76949-160">佇列也可用於所謂*速率調節*或*負載調節*。</span><span class="sxs-lookup"><span data-stu-id="76949-160">Queues are also useful for something called *rate leveling* or *load leveling*.</span></span>

<span data-ttu-id="76949-161">Web 應用程式通常是容易量突然暴增的流量。</span><span class="sxs-lookup"><span data-stu-id="76949-161">Web apps are often susceptible to sudden bursts in traffic.</span></span> <span data-ttu-id="76949-162">雖然您可以使用自動調整，以自動新增 web 伺服器來處理增加的 web 流量，自動調整可能無法迅速做出反應，來處理負載中的突然暴增。</span><span class="sxs-lookup"><span data-stu-id="76949-162">While you can use autoscaling to automatically add web servers to handle increased web traffic, autoscaling might not be able to react quickly enough to handle abrupt spikes in load.</span></span> <span data-ttu-id="76949-163">如果網頁伺服器可以卸載部分他們必須將訊息寫入佇列所做的工作，他們可以處理更多流量。</span><span class="sxs-lookup"><span data-stu-id="76949-163">If the web servers can offload some of the work they have to do by writing a message to a queue, they can handle more traffic.</span></span> <span data-ttu-id="76949-164">後端服務可以從佇列讀取訊息並處理它們。</span><span class="sxs-lookup"><span data-stu-id="76949-164">A backend service can then read messages from the queue and process them.</span></span> <span data-ttu-id="76949-165">佇列的深度會擴張或縮小，連入負載而改變。</span><span class="sxs-lookup"><span data-stu-id="76949-165">The depth of the queue will grow or shrink as the incoming load varies.</span></span>

<span data-ttu-id="76949-166">與大部分的耗時工作卸載至後端服務，web 層能更輕鬆地回應流量中突然出現尖峰。</span><span class="sxs-lookup"><span data-stu-id="76949-166">With much of its time-consuming work off-loaded to a backend service, the web tier can more easily respond to sudden spikes in traffic.</span></span> <span data-ttu-id="76949-167">和您節省成本，因為較少的 web 伺服器可以處理任何指定的數量的流量。</span><span class="sxs-lookup"><span data-stu-id="76949-167">And you save money because any given amount of traffic can be handled by fewer web servers.</span></span>

<span data-ttu-id="76949-168">您可以獨立擴充，web 層和後端服務。</span><span class="sxs-lookup"><span data-stu-id="76949-168">You can scale the web tier and backend service independently.</span></span> <span data-ttu-id="76949-169">例如，您可能需要三個 web 伺服器，但只有一個伺服器處理佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-169">For example, you might need three web servers but only one server processing queue messages.</span></span> <span data-ttu-id="76949-170">或者，如果您在背景中執行需要大量計算工作，您可能需要更多的後端伺服器。</span><span class="sxs-lookup"><span data-stu-id="76949-170">Or if you're running a compute-intensive task in the background, you might need more backend servers.</span></span>

![](queue-centric-work-pattern/_static/image3.png)

<span data-ttu-id="76949-171">自動調整的運作方式的後端服務和 web 層。</span><span class="sxs-lookup"><span data-stu-id="76949-171">Autoscaling works with backend services as well as with the web tier.</span></span> <span data-ttu-id="76949-172">您可以向上延展或縮小正在處理的工作在佇列中後, 端 Vm 的 CPU 使用量為基礎的 Vm 數目。</span><span class="sxs-lookup"><span data-stu-id="76949-172">You can scale up or scale down the number of VMs that are processing the tasks in the queue, based on the CPU usage of the backend VMs.</span></span> <span data-ttu-id="76949-173">或者，您可以在佇列中有多少項目為基礎的自動調整規模。</span><span class="sxs-lookup"><span data-stu-id="76949-173">Or, you can autoscale based on how many items are in a queue.</span></span> <span data-ttu-id="76949-174">例如，您可以分辨自動調整規模並再試一次在佇列中保留最多 10 個項目。</span><span class="sxs-lookup"><span data-stu-id="76949-174">For example, you can tell autoscale to try to keep no more than 10 items in the queue.</span></span> <span data-ttu-id="76949-175">如果佇列擁有 10 個以上的項目，自動調整規模將會加入 Vm。</span><span class="sxs-lookup"><span data-stu-id="76949-175">If the queue has more than 10 items, autoscale will add VMs.</span></span> <span data-ttu-id="76949-176">當它們趕上時，自動調整規模將會終止額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="76949-176">When they catch up, autoscale will tear down the extra VMs.</span></span>

## <a name="adding-queues-to-the-fix-it-application"></a><span data-ttu-id="76949-177">新增的修正會將它佇列應用程式</span><span class="sxs-lookup"><span data-stu-id="76949-177">Adding Queues to the Fix It Application</span></span>

<span data-ttu-id="76949-178">若要實作的佇列模式，我們需要修正它應用程式的兩個變更。</span><span class="sxs-lookup"><span data-stu-id="76949-178">To implement the queue pattern, we need to make two changes to the Fix It app.</span></span>

- <span data-ttu-id="76949-179">當使用者提交新修正它的工作時，請將工作放在佇列中，而不是寫入至資料庫。</span><span class="sxs-lookup"><span data-stu-id="76949-179">When a user submits a new Fix It task, put the task in the queue, instead of writing it to the database.</span></span>
- <span data-ttu-id="76949-180">建立後端服務處理之訊息佇列中。</span><span class="sxs-lookup"><span data-stu-id="76949-180">Create a back-end service that processes messages in the queue.</span></span>

<span data-ttu-id="76949-181">佇列中，我們將使用[Azure 佇列儲存體服務](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/)。</span><span class="sxs-lookup"><span data-stu-id="76949-181">For the queue, we'll use the [Azure Queue Storage Service](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/).</span></span> <span data-ttu-id="76949-182">另一個選項是使用[Azure 服務匯流排](https://docs.microsoft.com/azure/service-bus/)。</span><span class="sxs-lookup"><span data-stu-id="76949-182">Another option is to use [Azure Service Bus](https://docs.microsoft.com/azure/service-bus/).</span></span>

<span data-ttu-id="76949-183">若要決定要使用的佇列服務，請考慮您的應用程式需要的方式傳送和接收訊息佇列中：</span><span class="sxs-lookup"><span data-stu-id="76949-183">To decide which queue service to use, consider how your app needs to send and receive the messages in the queue:</span></span>

- <span data-ttu-id="76949-184">如果您有合作的產生者和競爭取用者，請考慮使用 Azure 佇列儲存體服務。</span><span class="sxs-lookup"><span data-stu-id="76949-184">If you have cooperating producers and competing consumers, consider using Azure Queue Storage Service.</span></span> <span data-ttu-id="76949-185">「 Cooperating 生產者"表示多個處理序會加入佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-185">"Cooperating producers" means multiple processes are adding messages to a queue.</span></span> <span data-ttu-id="76949-186">「 競爭取用者 」 表示多個處理序提取訊息從佇列處理它們，但任何指定的訊息只能處理一個 「 取用者。 」</span><span class="sxs-lookup"><span data-stu-id="76949-186">"Competing consumers" means multiple processes are pulling messages off the queue to process them, but any given message can only be processed by one "consumer."</span></span> <span data-ttu-id="76949-187">如果您需要更多的輸送量比就可以單一佇列，請使用其他的佇列和/或其他儲存體帳戶。</span><span class="sxs-lookup"><span data-stu-id="76949-187">If you need more throughput than you can get with a single queue, use additional queues and/or additional storage accounts.</span></span>
- <span data-ttu-id="76949-188">如果您需要[發佈/訂閱模型](http://en.wikipedia.org/wiki/Publish/subscribe)，請考慮使用 Azure 服務匯流排佇列。</span><span class="sxs-lookup"><span data-stu-id="76949-188">If you need a [publish/subscribe model](http://en.wikipedia.org/wiki/Publish/subscribe), consider using Azure Service Bus Queues.</span></span>

<span data-ttu-id="76949-189">修正它應用程式非常適合合作的產生者和競爭消費者模型。</span><span class="sxs-lookup"><span data-stu-id="76949-189">The Fix It app fits the cooperating producers and competing consumers model.</span></span>

<span data-ttu-id="76949-190">另一個考量是應用程式的可用性。</span><span class="sxs-lookup"><span data-stu-id="76949-190">Another consideration is application availability.</span></span> <span data-ttu-id="76949-191">佇列儲存體服務是我們會使用 blob 儲存體，因此使用它不會影響我們的 SLA 的相同服務的一部分。</span><span class="sxs-lookup"><span data-stu-id="76949-191">The Queue Storage Service is part of the same service that we're using for blob storage, so using it has no effect on our SLA.</span></span> <span data-ttu-id="76949-192">Azure Service Bus 是個別的服務，與它自己的 SLA。</span><span class="sxs-lookup"><span data-stu-id="76949-192">Azure Service Bus is a separate service with its own SLA.</span></span> <span data-ttu-id="76949-193">如果使用 Service Bus 佇列，我們必須將納入其他的 SLA 百分比，並且我們複合 SLA 會是較低。</span><span class="sxs-lookup"><span data-stu-id="76949-193">If we used Service Bus Queues, we would have to factor in an additional SLA percentage, and our composite SLA would be lower.</span></span> <span data-ttu-id="76949-194">當您選擇的佇列服務時，請確定您了解您所選擇的應用程式可用性的影響。</span><span class="sxs-lookup"><span data-stu-id="76949-194">When you're choosing a queue service, make sure you understand the impact of your choice on application availability.</span></span> <span data-ttu-id="76949-195">如需詳細資訊，請參閱[資源](#resources)> 一節。</span><span class="sxs-lookup"><span data-stu-id="76949-195">For more information, see the [Resources](#resources) section.</span></span>

## <a name="creating-queue-messages"></a><span data-ttu-id="76949-196">正在建立 「 訊息佇列</span><span class="sxs-lookup"><span data-stu-id="76949-196">Creating Queue Messages</span></span>

<span data-ttu-id="76949-197">若要修正該工作放入佇列中，web 前端，請執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="76949-197">To put a Fix It task on the queue, the web front end performs the following steps:</span></span>

1. <span data-ttu-id="76949-198">建立[CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx)執行個體。</span><span class="sxs-lookup"><span data-stu-id="76949-198">Create a [CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) instance.</span></span> <span data-ttu-id="76949-199">`CloudQueueClient`執行個體用來執行對佇列服務的要求。</span><span class="sxs-lookup"><span data-stu-id="76949-199">The `CloudQueueClient` instance is used to execute requests against the Queue Service.</span></span>
2. <span data-ttu-id="76949-200">如果尚未存在，請建立佇列。</span><span class="sxs-lookup"><span data-stu-id="76949-200">Create the queue, if it doesn't exist yet.</span></span>
3. <span data-ttu-id="76949-201">序列化修正其工作。</span><span class="sxs-lookup"><span data-stu-id="76949-201">Serialize the Fix It task.</span></span>
4. <span data-ttu-id="76949-202">呼叫[CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx)將放在佇列的訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-202">Call [CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) to put the message onto the queue.</span></span>

<span data-ttu-id="76949-203">我們將會執行這項工作中建構函式和`SendMessageAsync`方法的新`FixItQueueManager`類別。</span><span class="sxs-lookup"><span data-stu-id="76949-203">We'll do this work in the constructor and `SendMessageAsync` method of a new `FixItQueueManager` class.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

<span data-ttu-id="76949-204">這裡我們使用[Json.NET](https://github.com/JamesNK/Newtonsoft.Json)序列化為 JSON 格式 fixit 的程式庫。</span><span class="sxs-lookup"><span data-stu-id="76949-204">Here we are using the [Json.NET](https://github.com/JamesNK/Newtonsoft.Json) library to serialize the fixit to JSON format.</span></span> <span data-ttu-id="76949-205">您可以使用任何您偏好的序列化方法。</span><span class="sxs-lookup"><span data-stu-id="76949-205">You can use whatever serialization approach you prefer.</span></span> <span data-ttu-id="76949-206">JSON 的優點是能夠被人類看得懂，同時會比 XML。</span><span class="sxs-lookup"><span data-stu-id="76949-206">JSON has the advantage of being human-readable, while being less verbose than XML.</span></span>

<span data-ttu-id="76949-207">生產環境品質的程式碼會加入錯誤處理邏輯、 暫停如果資料庫變成無法使用，更完全地處理復原、 應用程式啟動時建立佇列和管理 「[有害 」 訊息](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx)。</span><span class="sxs-lookup"><span data-stu-id="76949-207">Production-quality code would add error handling logic, pause if the database became unavailable, handle recovery more cleanly, create the queue on application start-up, and manage "[poison" messages](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx).</span></span> <span data-ttu-id="76949-208">（有害訊息是因為某些原因無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-208">(A poison message is a message that cannot be processed for some reason.</span></span> <span data-ttu-id="76949-209">您不想成放置在佇列中，其中背景工作角色會持續嘗試進行處理、 失敗、 再試一次、 失敗，等等的有害訊息。）</span><span class="sxs-lookup"><span data-stu-id="76949-209">You don't want poison messages to sit in the queue, where the worker role will continually try to process them, fail, try again, fail, and so on.)</span></span>

<span data-ttu-id="76949-210">在前端的 MVC 應用程式中，我們需要更新建立新工作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="76949-210">In the front-end MVC application, we need to update the code that creates a new task.</span></span> <span data-ttu-id="76949-211">而不是將工作放到儲存機制中，呼叫`SendMessageAsync`方法如上所示。</span><span class="sxs-lookup"><span data-stu-id="76949-211">Instead of putting the task into the repository, call the `SendMessageAsync` method shown above.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a><span data-ttu-id="76949-212">處理佇列的訊息</span><span class="sxs-lookup"><span data-stu-id="76949-212">Processing Queue Messages</span></span>

<span data-ttu-id="76949-213">若要處理佇列中的訊息，我們將建立後端服務。</span><span class="sxs-lookup"><span data-stu-id="76949-213">To process messages in the queue, we'll create a backend service.</span></span> <span data-ttu-id="76949-214">後端服務將會執行無限迴圈，執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="76949-214">The backend service will run an infinite loop that performs the following steps:</span></span>

1. <span data-ttu-id="76949-215">從佇列取得下一個訊息。</span><span class="sxs-lookup"><span data-stu-id="76949-215">Get the next message from the queue.</span></span>
2. <span data-ttu-id="76949-216">還原序列化訊息至修正其工作。</span><span class="sxs-lookup"><span data-stu-id="76949-216">Deserialize the message to a Fix It task.</span></span>
3. <span data-ttu-id="76949-217">寫入資料庫中修正該工作。</span><span class="sxs-lookup"><span data-stu-id="76949-217">Write the Fix It task to the database.</span></span>

<span data-ttu-id="76949-218">若要裝載後端服務，我們將建立 Azure 雲端服務，其中包含*背景工作角色*。</span><span class="sxs-lookup"><span data-stu-id="76949-218">To host the backend service, we'll create an Azure Cloud Service that contains a *worker role*.</span></span> <span data-ttu-id="76949-219">背景工作角色可以執行後端處理的一或多個 Vm 所組成。</span><span class="sxs-lookup"><span data-stu-id="76949-219">A worker role consists of one or more VMs that can do backend processing.</span></span> <span data-ttu-id="76949-220">在這些 Vm 中執行的程式碼會以提取訊息從佇列可用時。</span><span class="sxs-lookup"><span data-stu-id="76949-220">The code that runs in these VMs will pull messages from the queue as they become available.</span></span> <span data-ttu-id="76949-221">對於每個訊息，我們將會還原序列化 JSON 承載，修正它工作實體的執行個體寫入資料庫，使用我們稍早在 web 層中使用的相同儲存機制。</span><span class="sxs-lookup"><span data-stu-id="76949-221">For each message, we'll deserialize the JSON payload and write an instance of the Fix It Task entity to the database, using the same repository that we used earlier in the web tier.</span></span>

<span data-ttu-id="76949-222">下列步驟顯示如何加入背景工作角色專案，以具有標準的 web 專案的方案。</span><span class="sxs-lookup"><span data-stu-id="76949-222">The following steps show how to add a worker role project to a solution that has a standard web project.</span></span> <span data-ttu-id="76949-223">已修正它在專案中，您可以下載完成這些步驟。</span><span class="sxs-lookup"><span data-stu-id="76949-223">These steps have already been done in the Fix It project that you can download.</span></span>

<span data-ttu-id="76949-224">先將雲端服務專案加入 Visual Studio 方案。</span><span class="sxs-lookup"><span data-stu-id="76949-224">First add a Cloud Service project to the Visual Studio solution.</span></span> <span data-ttu-id="76949-225">以滑鼠右鍵按一下方案，然後選取**新增**，然後**新專案**。</span><span class="sxs-lookup"><span data-stu-id="76949-225">Right-click the solution and select **Add**, then **New Project**.</span></span> <span data-ttu-id="76949-226">在左窗格中，依序展開**Visual C#** 選取**雲端**。</span><span class="sxs-lookup"><span data-stu-id="76949-226">In the left pane, expand **Visual C#** and select **Cloud**.</span></span>

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

<span data-ttu-id="76949-227">在**新的 Azure 雲端服務**] 對話方塊中，展開 [ **Visual C#** 在左窗格中的節點。</span><span class="sxs-lookup"><span data-stu-id="76949-227">In the **New Azure Cloud Service** dialog, expand the **Visual C#** node on the left pane.</span></span> <span data-ttu-id="76949-228">選取**背景工作角色**，然後按一下向右箭號圖示。</span><span class="sxs-lookup"><span data-stu-id="76949-228">Select **Worker Role** and click the right-arrow icon.</span></span>

![](queue-centric-work-pattern/_static/image6.png)

<span data-ttu-id="76949-229">(請注意，您也可以加入*web 角色*。</span><span class="sxs-lookup"><span data-stu-id="76949-229">(Notice that you can also add a *web role*.</span></span> <span data-ttu-id="76949-230">我們無法執行修正它在相同的雲端服務，而非 Azure 網站中執行的前端。</span><span class="sxs-lookup"><span data-stu-id="76949-230">We could run the Fix It front-end in the same Cloud Service instead of running it in an Azure Web Site.</span></span> <span data-ttu-id="76949-231">有一些優點，讓您更輕鬆地協調前端與後端之間的連線。</span><span class="sxs-lookup"><span data-stu-id="76949-231">That has some advantages in making connections between front-end and back-end easier to coordinate.</span></span> <span data-ttu-id="76949-232">不過，為了簡化此示範中，我們要保持前端在 Azure App Service Web 應用程式和只有在雲端服務中執行後端。）</span><span class="sxs-lookup"><span data-stu-id="76949-232">However, to keep this demo simple, we're keeping the front-end in an Azure App Service Web App and only running the back-end in a Cloud Service.)</span></span>

<span data-ttu-id="76949-233">將預設名稱被指派給背景工作角色。</span><span class="sxs-lookup"><span data-stu-id="76949-233">A default name is assigned to the worker role.</span></span> <span data-ttu-id="76949-234">若要變更名稱，將滑鼠放在右窗格中的背景工作角色，然後按一下鉛筆圖示。</span><span class="sxs-lookup"><span data-stu-id="76949-234">To change the name, hover the mouse over the worker role in the right pane, then click the pencil icon.</span></span>

![](queue-centric-work-pattern/_static/image7.png)

<span data-ttu-id="76949-235">按一下**確定**完成對話方塊。</span><span class="sxs-lookup"><span data-stu-id="76949-235">Click **OK** to complete the dialog.</span></span> <span data-ttu-id="76949-236">這會將兩個專案加入 Visual Studio 方案。</span><span class="sxs-lookup"><span data-stu-id="76949-236">This adds two projects to the Visual Studio solution.</span></span>

- <span data-ttu-id="76949-237">Azure 專案定義雲端服務，包括組態資訊。</span><span class="sxs-lookup"><span data-stu-id="76949-237">an Azure project that defines the cloud service, including configuration information.</span></span>
- <span data-ttu-id="76949-238">定義背景工作角色的背景工作角色專案。</span><span class="sxs-lookup"><span data-stu-id="76949-238">A worker role project that defines the worker role.</span></span>

![](queue-centric-work-pattern/_static/image8.png)

<span data-ttu-id="76949-239">如需詳細資訊，請參閱[使用 Visual Studio 建立 Azure 專案。](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span><span class="sxs-lookup"><span data-stu-id="76949-239">For more information, see [Creating an Azure Project with Visual Studio.](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)</span></span>

<span data-ttu-id="76949-240">在背景工作角色中，我們輪詢訊息藉由呼叫`ProcessMessageAsync`方法`FixItQueueManager`我們之前看到的類別。</span><span class="sxs-lookup"><span data-stu-id="76949-240">Inside the worker role, we poll for messages by calling the `ProcessMessageAsync` method of the `FixItQueueManager` class that we saw earlier.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

<span data-ttu-id="76949-241">`ProcessMessagesAsync`方法會檢查是否有訊息等待。</span><span class="sxs-lookup"><span data-stu-id="76949-241">The `ProcessMessagesAsync` method checks if there's a message waiting.</span></span> <span data-ttu-id="76949-242">如果有的話，它會還原序列化成訊息`FixItTask`實體，並將實體儲存在資料庫中。</span><span class="sxs-lookup"><span data-stu-id="76949-242">If there is one, it deserializes the message into a `FixItTask` entity and saves the entity in the database.</span></span> <span data-ttu-id="76949-243">它會迴圈直到佇列是空的。</span><span class="sxs-lookup"><span data-stu-id="76949-243">It loops until the queue is empty.</span></span>

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

<span data-ttu-id="76949-244">輪詢佇列訊息會產生小型的交易收費，所以沒有任何訊息等待處理，在背景工作角色的`RunAsync`方法會等候第二個輪詢之前再次呼叫`Task.Delay(1000)`。</span><span class="sxs-lookup"><span data-stu-id="76949-244">Polling for queue messages incurs a small transaction charge, so when there's no message waiting to be processed, the worker role's `RunAsync` method waits a second before polling again by calling `Task.Delay(1000)`.</span></span>

<span data-ttu-id="76949-245">在 web 專案中，新增非同步程式碼可以自動改善效能，因為 IIS 管理有限的執行緒集區。</span><span class="sxs-lookup"><span data-stu-id="76949-245">In a web project, adding asynchronous code can automatically improve performance because IIS manages a limited thread pool.</span></span> <span data-ttu-id="76949-246">這不是背景工作角色專案中的案例。</span><span class="sxs-lookup"><span data-stu-id="76949-246">That is not the case in a worker role project.</span></span> <span data-ttu-id="76949-247">若要改善延展性的背景工作角色，您可以撰寫多執行緒程式碼，或使用非同步程式碼來實作[平行程式設計](https://msdn.microsoft.com/library/ff963553.aspx)。</span><span class="sxs-lookup"><span data-stu-id="76949-247">To improve scalability of the worker role, you can write multi-threaded code or use asynchronous code to implement [parallel programming](https://msdn.microsoft.com/library/ff963553.aspx).</span></span> <span data-ttu-id="76949-248">此範例不會實作平行程式設計，但會示範如何讓程式碼非同步，因此您可以實作平行程式設計。</span><span class="sxs-lookup"><span data-stu-id="76949-248">The sample doesn't implement parallel programming but shows how to make the code asynchronous so you can implement parallel programming.</span></span>

## <a name="summary"></a><span data-ttu-id="76949-249">總結</span><span class="sxs-lookup"><span data-stu-id="76949-249">Summary</span></span>

<span data-ttu-id="76949-250">在本章中，您已經看到如何改善應用程式回應性、 可靠性和延展性，藉由實作佇列為主的工作模式。</span><span class="sxs-lookup"><span data-stu-id="76949-250">In this chapter you've seen how to improve application responsiveness, reliability, and scalability by implementing the queue-centric work pattern.</span></span>

<span data-ttu-id="76949-251">這是在此電子書，涵蓋的 13 模式的最後一個，但當然有許多其他的模式和作法，可協助您建置成功的雲端應用程式。</span><span class="sxs-lookup"><span data-stu-id="76949-251">This is the last of the 13 patterns covered in this e-book, but there are of course many other patterns and practices that can help you build successful cloud apps.</span></span> <span data-ttu-id="76949-252">[最後一章](more-patterns-and-guidance.md)您尚未已涵蓋這些 13 模式中的主題提供資源的連結。</span><span class="sxs-lookup"><span data-stu-id="76949-252">The [final chapter](more-patterns-and-guidance.md) provides links to resources for topics that haven't been covered in these 13 patterns.</span></span>

<a id="resources"></a>
## <a name="resources"></a><span data-ttu-id="76949-253">資源</span><span class="sxs-lookup"><span data-stu-id="76949-253">Resources</span></span>

<span data-ttu-id="76949-254">如需有關佇列的詳細資訊，請參閱下列資源。</span><span class="sxs-lookup"><span data-stu-id="76949-254">For more information about queues, see the following resources.</span></span>

<span data-ttu-id="76949-255">文件集：</span><span class="sxs-lookup"><span data-stu-id="76949-255">Documentation:</span></span>

- <span data-ttu-id="76949-256">[Microsoft Azure 儲存體佇列第 1 部： 入門](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/)。</span><span class="sxs-lookup"><span data-stu-id="76949-256">[Microsoft Azure Storage Queues Part 1: Getting Started](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/).</span></span> <span data-ttu-id="76949-257">細明體 Schacherl 的文章。</span><span class="sxs-lookup"><span data-stu-id="76949-257">Article by Roman Schacherl.</span></span>
- <span data-ttu-id="76949-258">[執行背景工作](https://msdn.microsoft.com/library/ff803365.aspx)，第 5 章[應用程式移至雲端，第 3 版](https://msdn.microsoft.com/library/ff728592.aspx)從 Microsoft Patterns and Practices。</span><span class="sxs-lookup"><span data-stu-id="76949-258">[Executing Background Tasks](https://msdn.microsoft.com/library/ff803365.aspx), chapter 5 of [Moving Applications to the Cloud, 3rd Edition](https://msdn.microsoft.com/library/ff728592.aspx) from Microsoft Patterns and Practices.</span></span> <span data-ttu-id="76949-259">(特別是，區段[」 使用 Azure 儲存體佇列 」](https://msdn.microsoft.com/library/ff803365.aspx#sec7)。)</span><span class="sxs-lookup"><span data-stu-id="76949-259">(In particular, the section ["Using Azure Storage Queues"](https://msdn.microsoft.com/library/ff803365.aspx#sec7).)</span></span>
- <span data-ttu-id="76949-260">[延展性和 Azure 上的佇列架構傳訊解決方案的成本的效益最大化的最佳作法](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="76949-260">[Best Practices for Maximizing Scalability and Cost Effectiveness of Queue-Based Messaging Solutions on Azure](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx).</span></span> <span data-ttu-id="76949-261">由 Valery Mizonov 詘躩裛。</span><span class="sxs-lookup"><span data-stu-id="76949-261">White paper by Valery Mizonov.</span></span>
- <span data-ttu-id="76949-262">[比較 Azure 佇列和服務匯流排佇列](https://msdn.microsoft.com/magazine/jj159884.aspx)。</span><span class="sxs-lookup"><span data-stu-id="76949-262">[Comparing Azure Queues and Service Bus Queues](https://msdn.microsoft.com/magazine/jj159884.aspx).</span></span> <span data-ttu-id="76949-263">MSDN Magazine 文件，提供可協助您選擇要使用的佇列服務的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="76949-263">MSDN Magazine article, provides additional information that can help you choose which queue service to use.</span></span> <span data-ttu-id="76949-264">本文提及 Service Bus 是依存於 ACS 進行驗證，這表示無法使用 ACS 時 SB 佇列將無法再使用。</span><span class="sxs-lookup"><span data-stu-id="76949-264">The article mentions that Service Bus is dependent on ACS for authentication, which means your SB queues would be unavailable when ACS is unavailable.</span></span> <span data-ttu-id="76949-265">不過，因為發行項所撰寫，SB 已變更，您可以使用[SAS 權杖](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx)作為 ACS 的替代方案。</span><span class="sxs-lookup"><span data-stu-id="76949-265">However, since the article was written, SB was changed to enable you to use [SAS tokens](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx) as an alternative to ACS.</span></span>
- <span data-ttu-id="76949-266">[Microsoft Patterns and Practices-Azure 指引](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="76949-266">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="76949-267">請參閱非同步傳訊入門、 管線和篩選模式中，補償的交易模式、 競爭取用者模式、 CQRS 模式。</span><span class="sxs-lookup"><span data-stu-id="76949-267">See Asynchronous Messaging primer, Pipes and Filters pattern, Compensating Transaction pattern, Competing Consumers pattern, CQRS pattern.</span></span>
- <span data-ttu-id="76949-268">[CQRS 旅程](https://msdn.microsoft.com/library/jj554200)。</span><span class="sxs-lookup"><span data-stu-id="76949-268">[CQRS Journey](https://msdn.microsoft.com/library/jj554200).</span></span> <span data-ttu-id="76949-269">由 Microsoft Patterns and Practices CQRS 相關的電子書。</span><span class="sxs-lookup"><span data-stu-id="76949-269">E-book about CQRS by Microsoft Patterns and Practices.</span></span>

<span data-ttu-id="76949-270">影片：</span><span class="sxs-lookup"><span data-stu-id="76949-270">Video:</span></span>

- <span data-ttu-id="76949-271">[FailSafe： 建置可擴充、 彈性的雲端服務](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="76949-271">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="76949-272">Ulrich Homann、 Marc Mercuri 和 Mark Simms 九部影片系列。</span><span class="sxs-lookup"><span data-stu-id="76949-272">Nine-part video series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="76949-273">高層級概念與架構原則非常可存取且有趣的方式，呈現劇本取自與實際客戶的 Microsoft 客戶諮詢團隊 (CAT) 體驗。</span><span class="sxs-lookup"><span data-stu-id="76949-273">Presents high-level concepts and architectural principles in a very accessible and interesting way, with stories drawn from Microsoft Customer Advisory Team (CAT) experience with actual customers.</span></span> <span data-ttu-id="76949-274">如需 Azure 儲存體服務和佇列的簡介，請參閱時段 5 開始 35:13。</span><span class="sxs-lookup"><span data-stu-id="76949-274">For an introduction to the Azure Storage service and queues, see episode 5 starting at 35:13.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="76949-275">[上一頁](distributed-caching.md)
> [下一頁](more-patterns-and-guidance.md)</span><span class="sxs-lookup"><span data-stu-id="76949-275">[Previous](distributed-caching.md)
[Next](more-patterns-and-guidance.md)</span></span>
