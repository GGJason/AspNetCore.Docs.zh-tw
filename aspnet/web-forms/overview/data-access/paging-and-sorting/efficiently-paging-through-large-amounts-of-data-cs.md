---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: 有效率地進行大量的資料 (C#) 的分頁 |Microsoft 文件
author: rick-anderson
description: 使用大量的資料，做為其基礎資料來源控制項 retriev 時，不適合資料簡報控制項之預設分頁選項...
ms.author: aspnetcontent
manager: wpickett
ms.date: 08/15/2006
ms.topic: article
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: ea1fd06f8eb7c53c3e9e7fb10c46974eb2af2acd
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2018
ms.locfileid: "30889653"
---
<a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="20b95-103">有效率地進行大量的資料 (C#) 的分頁</span><span class="sxs-lookup"><span data-stu-id="20b95-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>
====================
<span data-ttu-id="20b95-104">由[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="20b95-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="20b95-105">[下載範例應用程式](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe)或[下載 PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="20b95-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="20b95-106">呈現控制項的預設分頁選項時，不適合處理大量的資料，當其基礎資料來源控制項擷取所有的記錄，即使在顯示的資料子集。</span><span class="sxs-lookup"><span data-stu-id="20b95-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="20b95-107">必須在這種情況下，我們開啟自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-107">In such circumstances, we must turn to custom paging.</span></span>


## <a name="introduction"></a><span data-ttu-id="20b95-108">簡介</span><span class="sxs-lookup"><span data-stu-id="20b95-108">Introduction</span></span>

<span data-ttu-id="20b95-109">如我們所討論前述教學課程中，可以實作分頁在兩種方式之一：</span><span class="sxs-lookup"><span data-stu-id="20b95-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="20b95-110">**預設分頁**可以只檢查啟用分頁 選項來實作資料 Web 控制項 s 中的智慧標籤; 不過，只要檢視的資料頁面，ObjectDataSource 擷取*所有*的記錄，即使雖然它們的子集也會顯示在頁面</span><span class="sxs-lookup"><span data-stu-id="20b95-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="20b95-111">**自訂分頁**可改善效能的預設值，藉由擷取只需要特定的使用者; 要求的資料頁面會顯示資料庫中的分頁不過，自訂分頁牽涉到更多工作來實作比預設分頁</span><span class="sxs-lookup"><span data-stu-id="20b95-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="20b95-112">由於實作只核取核取方塊，並且重新輕鬆完成 ！</span><span class="sxs-lookup"><span data-stu-id="20b95-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="20b95-113">預設分頁是理想的選擇。</span><span class="sxs-lookup"><span data-stu-id="20b95-113">default paging is an attractive option.</span></span> <span data-ttu-id="20b95-114">在擷取的所有記錄，其 na ve 方法，可讓 implausible 選擇夠大的資料或站台的數量進行分頁具有許多並行使用者時。</span><span class="sxs-lookup"><span data-stu-id="20b95-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="20b95-115">在這種情況下，我們必須開啟自訂分頁才能提供回應的系統。</span><span class="sxs-lookup"><span data-stu-id="20b95-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="20b95-116">自訂分頁的挑戰能夠撰寫查詢以傳回精確的記錄所需的特定頁面的資料集。</span><span class="sxs-lookup"><span data-stu-id="20b95-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="20b95-117">幸運的是，Microsoft SQL Server 2005 提供新的關鍵字，排序結果，可讓我們來撰寫查詢，可以有效率地擷取記錄的適當子集合。</span><span class="sxs-lookup"><span data-stu-id="20b95-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="20b95-118">在本教學課程中，我們會看到如何使用這個新的 SQL Server 2005 關鍵字 GridView 控制項中實作自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="20b95-119">由於自訂分頁的使用者介面是相同的預設分頁時，逐步執行各個頁面間到下一步 時使用自訂分頁可能的差距速度比預設分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="20b95-120">自訂分頁所展現的精確的效能改善取決於正在透過呼叫記錄並放在資料庫伺服器上的負載的總數。</span><span class="sxs-lookup"><span data-stu-id="20b95-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="20b95-121">在本教學課程結尾處我們會探討展示透過自訂分頁所獲得的效能優點某些概略度量資訊。</span><span class="sxs-lookup"><span data-stu-id="20b95-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>


## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="20b95-122">步驟 1： 了解自訂分頁程序</span><span class="sxs-lookup"><span data-stu-id="20b95-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="20b95-123">若資料進行分頁，頁面中顯示的精確記錄取決於所要求的資料頁，以及每頁顯示的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="20b95-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="20b95-124">例如，想像一下，我們想要透過 81 產品頁面上顯示每個分頁 10 項產品。</span><span class="sxs-lookup"><span data-stu-id="20b95-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="20b95-125">檢視時的第一頁，d 我們想要產品 1 到 10。檢視第二個頁面時，我們 d 興趣產品 11 到 20，依此類推。</span><span class="sxs-lookup"><span data-stu-id="20b95-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="20b95-126">有三個變數，指定要擷取需要的記錄和應該用來呈現分頁介面的方式：</span><span class="sxs-lookup"><span data-stu-id="20b95-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="20b95-127">**啟動 資料列索引**要顯示的資料頁面中的第一列的索引; 這個索引的頁面索引乘以每頁顯示的記錄，並新增一個計算。</span><span class="sxs-lookup"><span data-stu-id="20b95-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="20b95-128">例如，若 10 一次第一個頁面記錄 （其頁面索引為 0） 進行分頁，開始的資料列索引為 0 \* 10 + 1 或 1; 第二個頁面 （頁面索引為 1），開始的資料列索引為 1 \* 10 + 1或為 11。</span><span class="sxs-lookup"><span data-stu-id="20b95-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="20b95-129">**最大資料列**每頁顯示的記錄數目上限。</span><span class="sxs-lookup"><span data-stu-id="20b95-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="20b95-130">此變數被指最大資料列因為最後一個頁面有可能是較少的記錄傳回超過頁面大小。</span><span class="sxs-lookup"><span data-stu-id="20b95-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="20b95-131">比方說，當透過 81 產品 10 記錄，每個分頁的分頁，第九個和最後一個頁面必須只有一項記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="20b95-132">不過，任何頁面上，會不顯示超出最大資料列的值更多的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="20b95-133">**總記錄計數**透過正在呼叫的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="20b95-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="20b95-134">雖然這個變數的目前 t 需要決定哪些記錄來擷取指定的頁面，它沒有指示分頁介面。</span><span class="sxs-lookup"><span data-stu-id="20b95-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="20b95-135">比方說，如果正在呼叫透過 81 產品，分頁介面知道在分頁 UI 中顯示九個頁碼。</span><span class="sxs-lookup"><span data-stu-id="20b95-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="20b95-136">使用預設分頁開始的資料列索引計算方式的頁面索引和頁面大小加上一個項目，產品而最大資料列，則只是頁面大小。</span><span class="sxs-lookup"><span data-stu-id="20b95-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="20b95-137">因為預設分頁，擷取所有記錄的資料庫呈現資料，每個資料列索引的任何頁面時已知，進而讓 移至啟動的資料列索引資料列是簡單的工作。</span><span class="sxs-lookup"><span data-stu-id="20b95-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="20b95-138">此外，記錄總數是立即可用，因為它 s DataTable （或保留資料庫結果使用的任何物件） 中的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="20b95-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="20b95-139">指定開始的資料列索引和最大資料列的變數，自訂分頁實作必須只傳回記錄之後，開始啟動資料列索引和記錄的最大資料列數目最精確的子集。</span><span class="sxs-lookup"><span data-stu-id="20b95-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="20b95-140">自訂分頁提供兩個挑戰：</span><span class="sxs-lookup"><span data-stu-id="20b95-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="20b95-141">我們必須要能夠有效率地將資料列索引與正在透過分頁，好讓我們能夠開始傳回指定的開始資料列索引處的記錄之整體資料中的每個資料列產生關聯</span><span class="sxs-lookup"><span data-stu-id="20b95-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="20b95-142">我們需要提供透過正在呼叫的記錄總數</span><span class="sxs-lookup"><span data-stu-id="20b95-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="20b95-143">在下面兩個步驟中，我們將檢驗這些兩個挑戰回應所需的 SQL 指令碼。</span><span class="sxs-lookup"><span data-stu-id="20b95-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="20b95-144">除了 SQL 指令碼中，我們也要 DAL 和 BLL 中實作方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="20b95-145">步驟 2： 傳回透過正在呼叫的記錄總數</span><span class="sxs-lookup"><span data-stu-id="20b95-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="20b95-146">我們檢驗如何擷取精確的頁面不會再顯示記錄子集時，可讓 s 先看看如何傳回透過正在呼叫的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="20b95-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="20b95-147">需要這項資訊才能正確地設定 [分頁] 使用者介面。</span><span class="sxs-lookup"><span data-stu-id="20b95-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="20b95-148">可以使用來取得特定的 SQL 查詢所傳回的記錄總數[`COUNT`彙總函式](https://msdn.microsoft.com/library/ms175997.aspx)。</span><span class="sxs-lookup"><span data-stu-id="20b95-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="20b95-149">例如，若要判斷中記錄的總數`Products`資料表中，我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="20b95-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="20b95-150">將方法加入傳回這項資訊我們 DAL 的 s。</span><span class="sxs-lookup"><span data-stu-id="20b95-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="20b95-151">特別是，我們將建立呼叫 DAL 方法`TotalNumberOfProducts()`執行`SELECT`如上所示的陳述式。</span><span class="sxs-lookup"><span data-stu-id="20b95-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="20b95-152">先開啟`Northwind.xsd`中的型別資料集檔案`App_Code/DAL`資料夾。</span><span class="sxs-lookup"><span data-stu-id="20b95-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="20b95-153">接下來，以滑鼠右鍵按一下`ProductsTableAdapter`設計工具中，然後選擇 加入查詢。</span><span class="sxs-lookup"><span data-stu-id="20b95-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="20b95-154">當我們先前的教學課程中所見過這可讓我們加入 DAL 的新方法，叫用時，會執行特定 SQL 陳述式或預存程序。</span><span class="sxs-lookup"><span data-stu-id="20b95-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="20b95-155">如同先前的教學課程中我們 TableAdapter 方法，這其中一個選擇使用特定 SQL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="20b95-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>


![使用特定 SQL 陳述式](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="20b95-157">**圖 1**： 使用特定 SQL 陳述式</span><span class="sxs-lookup"><span data-stu-id="20b95-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>


<span data-ttu-id="20b95-158">在下一個畫面中，我們可以指定何種查詢來建立。</span><span class="sxs-lookup"><span data-stu-id="20b95-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="20b95-159">因為此查詢會傳回單一純量值中的記錄總數`Products`資料表選擇`SELECT`傳回單一值選項。</span><span class="sxs-lookup"><span data-stu-id="20b95-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>


![設定使用的 SELECT 陳述式會傳回單一值的查詢](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="20b95-161">**圖 2**： 設定使用的 SELECT 陳述式會傳回單一值的查詢</span><span class="sxs-lookup"><span data-stu-id="20b95-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>


<span data-ttu-id="20b95-162">指出要使用查詢的類型之後, 我們接下來必須指定查詢。</span><span class="sxs-lookup"><span data-stu-id="20b95-162">After indicating the type of query to use, we must next specify the query.</span></span>


![使用選取的 COUNT(\*) 從產品的查詢](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="20b95-164">**圖 3**： 使用 SELECT COUNT (\*) FROM 產品查詢</span><span class="sxs-lookup"><span data-stu-id="20b95-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>


<span data-ttu-id="20b95-165">最後，指定方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="20b95-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="20b95-166">使用上述，讓 s `TotalNumberOfProducts`。</span><span class="sxs-lookup"><span data-stu-id="20b95-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>


![命名 DAL 方法 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="20b95-168">**圖 4**： 命名 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="20b95-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>


<span data-ttu-id="20b95-169">之後按一下 [完成]，精靈會將`TotalNumberOfProducts`dal 的方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="20b95-170">DAL 中的純量傳回方法會傳回可為 null 的類型，從 SQL 查詢的結果是`NULL`。</span><span class="sxs-lookup"><span data-stu-id="20b95-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="20b95-171">我們`COUNT`查詢，不過，一律會傳回非`NULL`值; 不過，DAL 方法會傳回可為 null 的整數。</span><span class="sxs-lookup"><span data-stu-id="20b95-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="20b95-172">除了 DAL 方法中，我們也會需要 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="20b95-173">開啟`ProductsBLL`類別檔案，然後將`TotalNumberOfProducts`方法只會呼叫向下到 DAL 的`TotalNumberOfProducts`方法：</span><span class="sxs-lookup"><span data-stu-id="20b95-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="20b95-174">DAL s`TotalNumberOfProducts`方法會傳回可為 null 的整數; 不過，我們建立 ve`ProductsBLL`類別的`TotalNumberOfProducts`方法，使它傳回標準的整數。</span><span class="sxs-lookup"><span data-stu-id="20b95-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="20b95-175">因此，我們必須將`ProductsBLL`類別 s`TotalNumberOfProducts`方法傳回的可為 null 整數 DAL s 所傳回的值部分`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="20b95-176">若要呼叫`GetValueOrDefault()`傳回的值可為 null 的整數，如果它存在時，是否可為 null 整數`null`，不過，它會傳回預設的整數值為 0。</span><span class="sxs-lookup"><span data-stu-id="20b95-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="20b95-177">步驟 3： 傳回記錄的精確子集</span><span class="sxs-lookup"><span data-stu-id="20b95-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="20b95-178">下一步是建立 DAL 和 BLL 接受開始的資料列索引中的方法和最大資料列變數先前討論過，並傳回適當的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="20b95-179">這樣做之前，可讓 s 先來看的所需的 SQL 指令碼。</span><span class="sxs-lookup"><span data-stu-id="20b95-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="20b95-180">我們面對的挑戰是，我們必須能夠有效率地將索引指派給正在透過分頁，因此，我們可以傳回啟動開始的資料列索引 （和最多為最大記錄數目的記錄） 只記錄整個結果中的每個資料列。</span><span class="sxs-lookup"><span data-stu-id="20b95-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="20b95-181">如果已經有資料行做為資料列索引的資料庫資料表中，這是不一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="20b95-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="20b95-182">第一眼看起來我們可能會認為`Products`資料表 s`ProductID`欄位即已足夠，因為第一項產品有`ProductID`為 1，2，第二個，依此類推。</span><span class="sxs-lookup"><span data-stu-id="20b95-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="20b95-183">不過，刪除產品會保留在順序中，這種方式取消現有的間距。</span><span class="sxs-lookup"><span data-stu-id="20b95-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="20b95-184">有兩個一般使用的技術來有效地將資料列索引關聯的資料進行分頁，藉此讓要擷取的記錄的精確子集：</span><span class="sxs-lookup"><span data-stu-id="20b95-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="20b95-185">**使用 SQL Server 2005 s`ROW_NUMBER()`關鍵字**新增至 SQL Server 2005、`ROW_NUMBER()`關鍵字關聯每個傳回的記錄，取決於一些排序次序。</span><span class="sxs-lookup"><span data-stu-id="20b95-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="20b95-186">這個等級可以作為每個資料列的資料列索引。</span><span class="sxs-lookup"><span data-stu-id="20b95-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="20b95-187">**使用資料表變數和`SET ROWCOUNT`**  SQL Server s [ `SET ROWCOUNT`陳述式](https://msdn.microsoft.com/library/ms188774.aspx)可以用來指定查詢應該處理終止; 之前的總記錄數[資料表變數](http://www.sqlteam.com/item.asp?ItemID=9454)是本機 T-SQL 變數可以儲存表格式資料、 akin[暫存資料表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="20b95-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="20b95-188">這種方法同樣適用於 Microsoft SQL Server 2005 和 SQL Server 2000 (而`ROW_NUMBER()`方法只適用於 SQL Server 2005)。</span><span class="sxs-lookup"><span data-stu-id="20b95-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="20b95-189">這裡的做法是建立資料表變數，其中包含`IDENTITY`資料行和資料行的主索引鍵的資料表正在透過呼叫其資料。</span><span class="sxs-lookup"><span data-stu-id="20b95-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="20b95-190">正在透過呼叫其資料的資料表的內容放入資料表變數中，藉此建立關聯的循序資料列索引接下來，傾印 (透過`IDENTITY`資料行) 資料表中的每一筆記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="20b95-191">尚未擴展資料表變數，一旦`SELECT`陳述式在資料表變數中，可以執行與基礎資料表聯結，提取出特定的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="20b95-192">`SET ROWCOUNT`陳述式用來以聰明的方式限制需要可傾印以放入資料表變數中的記錄數目。</span><span class="sxs-lookup"><span data-stu-id="20b95-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="20b95-193">這種方法的效率根據所要求的頁面數目為`SET ROWCOUNT`開始的資料列索引，再加上最大資料列的值指派給值。</span><span class="sxs-lookup"><span data-stu-id="20b95-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="20b95-194">當透過低編號的頁面，例如第一個分頁的資料幾個頁面則這個方法是非常有效率。</span><span class="sxs-lookup"><span data-stu-id="20b95-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="20b95-195">不過，它會表現預設分頁類似效能擷取頁面即將結束時。</span><span class="sxs-lookup"><span data-stu-id="20b95-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="20b95-196">本教學課程中實作自訂分頁使用`ROW_NUMBER()`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="20b95-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="20b95-197">如需有關使用資料表變數和`SET ROWCOUNT`技術，請參閱[詳細有效率的方法之分頁透過大型結果集](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="20b95-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="20b95-198">`ROW_NUMBER()`關鍵字聯透過使用下列語法的特定順序傳回每一筆記錄等級：</span><span class="sxs-lookup"><span data-stu-id="20b95-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="20b95-199">`ROW_NUMBER()` 傳回數值，指定每一筆記錄與指定的排序次序。</span><span class="sxs-lookup"><span data-stu-id="20b95-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="20b95-200">例如，若要查看每項產品，從最排序次序成本最低，我們可以使用下列查詢：</span><span class="sxs-lookup"><span data-stu-id="20b95-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="20b95-201">圖 5 顯示這項查詢 s 透過 Visual Studio 中的 [查詢] 視窗中執行時的結果。</span><span class="sxs-lookup"><span data-stu-id="20b95-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="20b95-202">請注意，排序產品的價格，以及每個資料列的價格陣序規範。</span><span class="sxs-lookup"><span data-stu-id="20b95-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>


![價格等級包括的每個傳回的記錄](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="20b95-204">**圖 5**: 價格陣序規範包括的每個傳回的記錄</span><span class="sxs-lookup"><span data-stu-id="20b95-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>


> [!NOTE]
> <span data-ttu-id="20b95-205">`ROW_NUMBER()` 其中許多新的排名函數是用於 SQL Server 2005。</span><span class="sxs-lookup"><span data-stu-id="20b95-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="20b95-206">如需的更完整討論`ROW_NUMBER()`，以及其他排名函數讀取[傳回等級結果與 Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="20b95-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>


<span data-ttu-id="20b95-207">當藉由指定排名結果`ORDER BY`中的資料行`OVER`子句 (`UnitPrice`，在上述範例中)，SQL Server 必須排序結果。</span><span class="sxs-lookup"><span data-stu-id="20b95-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="20b95-208">這是快速的作業，如果沒有叢集的索引上的結果，所排序的資料行，或者沒有涵蓋索引，但是可以否則成本更高。</span><span class="sxs-lookup"><span data-stu-id="20b95-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="20b95-209">若要協助提升夠大的查詢的效能，請考慮加入非叢集索引的結果依排序的資料行。</span><span class="sxs-lookup"><span data-stu-id="20b95-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="20b95-210">請參閱[排名函式和 SQL Server 2005 中的效能](http://www.sql-server-performance.com/ak_ranking_functions.asp)如查看更詳細的效能考量。</span><span class="sxs-lookup"><span data-stu-id="20b95-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="20b95-211">所傳回的等級資訊`ROW_NUMBER()`無法直接用於`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="20b95-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="20b95-212">然而，衍生的資料表可以用來傳回`ROW_NUMBER()`結果，然後可以出現在`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="20b95-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="20b95-213">例如，下列查詢會使用衍生的資料表傳回產品名稱和單價的資料行，連同`ROW_NUMBER()`結果，然後再使用`WHERE`子句只傳回這些產品的價格陣序規範為 11 到 20 之間：</span><span class="sxs-lookup"><span data-stu-id="20b95-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="20b95-214">擴充此概念一點，我們可以利用這種方法來擷取指定想要啟動的資料列索引和最大資料列的值資料的特定頁面：</span><span class="sxs-lookup"><span data-stu-id="20b95-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="20b95-215">我們將會在本教學課程稍後看到*`StartRowIndex`* 所提供的 ObjectDataSource 編製索引零處開始而`ROW_NUMBER()`SQL Server 2005 所傳回的值從 1 開始索引。</span><span class="sxs-lookup"><span data-stu-id="20b95-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="20b95-216">因此，`WHERE`子句傳回的記錄位置`PriceRank`必定大於*`StartRowIndex`* 且小於或等於*`StartRowIndex`*  + *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="20b95-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>


<span data-ttu-id="20b95-217">現在我們已討論過如何`ROW_NUMBER()`可以是用來擷取特定的頁面上的啟動的資料列索引和資料列的上限值的資料，我們現在必須實作此邏輯為 DAL 和 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="20b95-218">建立這個我們必須決定排序的查詢時，結果排列次序;可讓其名稱的字母順序來排序產品的 s。</span><span class="sxs-lookup"><span data-stu-id="20b95-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="20b95-219">這表示，使用自訂分頁實作本教學課程中我們將無法建立自訂分頁的報表，也可以儲存比。</span><span class="sxs-lookup"><span data-stu-id="20b95-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="20b95-220">在下一個教學課程中，不過，我們會看到如何可以提供這類功能。</span><span class="sxs-lookup"><span data-stu-id="20b95-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="20b95-221">上一節中，我們會建立 DAL 方法當成特定 SQL 陳述式。</span><span class="sxs-lookup"><span data-stu-id="20b95-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="20b95-222">不幸的是，使用 TableAdapter 精靈規定 t，像是 Visual Studio 中的 T-SQL 剖析`OVER`所使用的語法`ROW_NUMBER()`函式。</span><span class="sxs-lookup"><span data-stu-id="20b95-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="20b95-223">因此，我們必須建立這個 DAL 方法做為預存程序。</span><span class="sxs-lookup"><span data-stu-id="20b95-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="20b95-224">選取 [伺服器總管] 從 [檢視] 功能表 （或叫用的 Ctrl + Alt + S），然後展開`NORTHWND.MDF`節點。</span><span class="sxs-lookup"><span data-stu-id="20b95-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="20b95-225">若要加入新的預存程序，以滑鼠右鍵按一下 預存程序 節點，並選擇 加入新的預存程序 （請參閱圖 6）。</span><span class="sxs-lookup"><span data-stu-id="20b95-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>


![分頁的產品加入新的預存程序](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="20b95-227">**圖 6**： 分頁的產品加入新的預存程序</span><span class="sxs-lookup"><span data-stu-id="20b95-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>


<span data-ttu-id="20b95-228">這個預存程序應該接受兩個整數輸入的參數-`@startRowIndex`和`@maximumRows`並用`ROW_NUMBER()`函式依`ProductName` 欄位中，僅傳回那些資料列大於指定`@startRowIndex`和小於或等於`@startRowIndex`  +  `@maximumRow` s。</span><span class="sxs-lookup"><span data-stu-id="20b95-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="20b95-229">輸入下列指令碼至新的預存程序，然後按一下 [儲存] 圖示，將預存程序新增至資料庫。</span><span class="sxs-lookup"><span data-stu-id="20b95-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="20b95-230">建立預存程序之後, 花點時間進行測試。以滑鼠右鍵按一下`GetProductsPaged`預存程序 [伺服器總管] 中的名稱，然後選擇 [執行] 選項。</span><span class="sxs-lookup"><span data-stu-id="20b95-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="20b95-231">Visual Studio 會提示您輸入的參數，`@startRowIndex`和`@maximumRow`s （請參閱圖 7）。</span><span class="sxs-lookup"><span data-stu-id="20b95-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="20b95-232">請嘗試不同的值，並檢查結果。</span><span class="sxs-lookup"><span data-stu-id="20b95-232">Try different values and examine the results.</span></span>


![輸入一個值@startRowIndex和@maximumRows參數](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="20b95-234"><strong>圖 7</strong>： 輸入的值@startRowIndex和@maximumRows參數</span><span class="sxs-lookup"><span data-stu-id="20b95-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>


<span data-ttu-id="20b95-235">在之後選擇這些輸入參數值時，[輸出] 視窗會顯示結果。</span><span class="sxs-lookup"><span data-stu-id="20b95-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="20b95-236">圖 8 顯示兩個 10 中傳遞時的結果`@startRowIndex`和`@maximumRows`參數。</span><span class="sxs-lookup"><span data-stu-id="20b95-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>


<span data-ttu-id="20b95-237">[![會傳回記錄，就會出現在第二個頁面的資料](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="20b95-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="20b95-238">**圖 8**: 記錄，就會出現在第二個頁面的資料會傳回 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="20b95-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>


<span data-ttu-id="20b95-239">與這個預存程序建立，我們來建立準備好`ProductsTableAdapter`方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="20b95-240">開啟`Northwind.xsd`具類型的資料集，以滑鼠右鍵按一下在`ProductsTableAdapter`，並選擇 加入查詢選項。</span><span class="sxs-lookup"><span data-stu-id="20b95-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="20b95-241">而不是建立使用特定 SQL 陳述式的查詢，建立使用現有的預存程序。</span><span class="sxs-lookup"><span data-stu-id="20b95-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>


![建立使用現有的預存程序的 DAL 方法](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="20b95-243">**圖 9**： 建立使用現有的預存程序的 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="20b95-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>


<span data-ttu-id="20b95-244">接下來，我們會提示您選取要叫用的預存程序。</span><span class="sxs-lookup"><span data-stu-id="20b95-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="20b95-245">挑選`GetProductsPaged`預存程序，從下拉式清單。</span><span class="sxs-lookup"><span data-stu-id="20b95-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>


![選擇 GetProductsPaged 預存程序，從下拉式清單](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="20b95-247">**圖 10**： 選擇 GetProductsPaged 預存程序，從下拉式清單</span><span class="sxs-lookup"><span data-stu-id="20b95-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>


<span data-ttu-id="20b95-248">下一個畫面中再會要求您的資料類型由預存程序： 表格式資料、 單一值或沒有值。</span><span class="sxs-lookup"><span data-stu-id="20b95-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="20b95-249">因為`GetProductsPaged`預存程序可以傳回多筆記錄，表示它會傳回表格式資料。</span><span class="sxs-lookup"><span data-stu-id="20b95-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>


![指出預存程序傳回表格式資料](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="20b95-251">**圖 11**： 指出預存程序傳回表格式資料</span><span class="sxs-lookup"><span data-stu-id="20b95-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>


<span data-ttu-id="20b95-252">最後，表示您想要建立方法的名稱。</span><span class="sxs-lookup"><span data-stu-id="20b95-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="20b95-253">如同我們先前的教學課程，請繼續建立方法使用的填滿 DataTable 和傳回 DataTable。</span><span class="sxs-lookup"><span data-stu-id="20b95-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="20b95-254">將第一個方法`FillPaged`，第二個`GetProductsPaged`。</span><span class="sxs-lookup"><span data-stu-id="20b95-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>


![名稱方法 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="20b95-256">**圖 12**： 名稱方法 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="20b95-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>


<span data-ttu-id="20b95-257">除了建立 DAL 方法傳回的產品的特定頁面，我們也要提供給 BLL 中的這類功能。</span><span class="sxs-lookup"><span data-stu-id="20b95-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="20b95-258">DAL 與方法一樣，BLL 的 GetProductsPaged 方法必須接受兩個整數輸入用來指定開始的資料列索引和最大資料列，而且必須傳回只在指定範圍內的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="20b95-259">這種 BLL 方法在類別中建立 ProductsBLL 只呼叫向下的 DAL 的 GetProductsPaged 方法，就像這樣：</span><span class="sxs-lookup"><span data-stu-id="20b95-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="20b95-260">您可以使用任何名稱 BLL 方法 s 輸入參數，但是，我們將會看到在短時間內，選擇使用`startRowIndex`和`maximumRows`我們將額外的設定才能使用此方法 ObjectDataSource 時的工作。</span><span class="sxs-lookup"><span data-stu-id="20b95-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="20b95-261">步驟 4： 設定要使用自訂分頁 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="20b95-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="20b95-262">BLL 和 DAL 方法存取完整的記錄的特定子集，我們已備妥可建立 GridView re 控制該頁面，透過其基礎使用自訂分頁的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="20b95-263">先開啟`EfficientPaging.aspx`頁面`PagingAndSorting`資料夾中，將 GridView 加入至頁面上，並將它設定為使用新的 ObjectDataSource 控制項。</span><span class="sxs-lookup"><span data-stu-id="20b95-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="20b95-264">在我們過去教學課程中，我們通常必須設定為使用 ObjectDataSource`ProductsBLL`類別的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="20b95-265">此時，不過，我們想要使用`GetProductsPaged`方法相反地，因為`GetProducts`方法會傳回*所有*資料庫中的產品而`GetProductsPaged`傳回只記錄的特定子集。</span><span class="sxs-lookup"><span data-stu-id="20b95-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>


![設定為使用 ProductsBLL 類別的 GetProductsPaged 方法 ObjectDataSource](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="20b95-267">**圖 13**： 設定為使用 ProductsBLL 類別的 GetProductsPaged 方法 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="20b95-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>


<span data-ttu-id="20b95-268">因為我們重新建立唯讀的 GridView，花一點時間來設定 [方法] 下拉式清單中插入、 更新和刪除索引標籤，以 （無）。</span><span class="sxs-lookup"><span data-stu-id="20b95-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="20b95-269">接下來，ObjectDataSource 精靈會提示輸入我們的來源`GetProductsPaged`方法 s`startRowIndex`和`maximumRows`輸入參數值。</span><span class="sxs-lookup"><span data-stu-id="20b95-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="20b95-270">這些輸入的參數實際上為 GridView 自動只要保留來源設定為 None，按一下 [完成]。</span><span class="sxs-lookup"><span data-stu-id="20b95-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>


![保留為 無的輸入的參數來源](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="20b95-272">**圖 14**： 保留為 無的輸入的參數來源</span><span class="sxs-lookup"><span data-stu-id="20b95-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>


<span data-ttu-id="20b95-273">完成 ObjectDataSource 精靈之後，GridView 會包含 BoundField 或 CheckBoxField 每個產品資料欄位。</span><span class="sxs-lookup"><span data-stu-id="20b95-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="20b95-274">請隨意適當地調整 GridView 的外觀。</span><span class="sxs-lookup"><span data-stu-id="20b95-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="20b95-275">我已選擇只顯示`ProductName`， `CategoryName`， `SupplierName`， `QuantityPerUnit`，和`UnitPrice`BoundFields。</span><span class="sxs-lookup"><span data-stu-id="20b95-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="20b95-276">此外，設定以支援分頁，藉由檢查其智慧標籤中的啟用分頁 核取方塊 GridView。</span><span class="sxs-lookup"><span data-stu-id="20b95-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="20b95-277">這些變更之後，請 GridView 和 ObjectDataSource 宣告式標記看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="20b95-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="20b95-278">如果您瀏覽透過瀏覽器頁面，不過，GridView 是位置可以找到。</span><span class="sxs-lookup"><span data-stu-id="20b95-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>


![在 GridView 是不顯示](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="20b95-280">**圖 15**: GridView 是不顯示</span><span class="sxs-lookup"><span data-stu-id="20b95-280">**Figure 15**: The GridView is Not Displayed</span></span>


<span data-ttu-id="20b95-281">在 GridView 因遺漏 ObjectDataSource 目前使用 0 做為值的兩個`GetProductsPaged``startRowIndex`和`maximumRows`輸入參數。</span><span class="sxs-lookup"><span data-stu-id="20b95-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="20b95-282">因此，產生的 SQL 查詢會傳回任何記錄，因此不會顯示在 GridView。</span><span class="sxs-lookup"><span data-stu-id="20b95-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="20b95-283">若要補救這種情況，我們需要設定要使用自訂分頁 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="20b95-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="20b95-284">這可以透過完成下列步驟：</span><span class="sxs-lookup"><span data-stu-id="20b95-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="20b95-285">**設定 ObjectDataSource s`EnablePaging`屬性`true`** 這表示它必須將它傳遞給 ObjectDataSource`SelectMethod`另外兩個參數： 一個用來指定開始的資料列索引 ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx))，和一個用來指定最大資料列 ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx))。</span><span class="sxs-lookup"><span data-stu-id="20b95-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="20b95-286">**設定 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`據以屬性**`StartRowIndexParameterName`和`MaximumRowsParameterName`屬性會指出傳入輸入參數的名稱`SelectMethod`進行自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="20b95-287">根據預設，這些參數名稱為`startIndexRow`和`maximumRows`，這是原因、 建立時`GetProductsPaged`方法在 BLL 我用於這些值的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="20b95-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="20b95-288">如果您選擇要使用不同的參數名稱 BLL s`GetProductsPaged`方法，例如`startIndex`和`maxRows`的範例，您就必須設定 ObjectDataSource s`StartRowIndexParameterName`和`MaximumRowsParameterName`屬性據以 （例如 startIndex 為`StartRowIndexParameterName`和為 maxRows `MaximumRowsParameterName`)。</span><span class="sxs-lookup"><span data-stu-id="20b95-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="20b95-289">**設定 ObjectDataSource s [ `SelectCountMethod`屬性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)的總數目的記錄正在分頁透過傳回的方法名稱 (`TotalNumberOfProducts`)** 請記得，`ProductsBLL`類別的`TotalNumberOfProducts`方法會傳回透過使用 DAL 方法執行正在呼叫的記錄總數`SELECT COUNT(*) FROM Products`查詢。</span><span class="sxs-lookup"><span data-stu-id="20b95-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="20b95-290">Objectdatasource 需要這項資訊才能正確地呈現分頁介面。</span><span class="sxs-lookup"><span data-stu-id="20b95-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="20b95-291">**移除`startRowIndex`和`maximumRows``<asp:Parameter>`從 ObjectDataSource s 宣告式標記項目**設定時透過精靈 ObjectDataSource，Visual Studio 會自動加入兩個`<asp:Parameter>`項目如`GetProductsPaged`方法 s 輸入參數。</span><span class="sxs-lookup"><span data-stu-id="20b95-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="20b95-292">藉由設定`EnablePaging`至`true`，這些參數會自動傳遞給; ObjectDataSource 如果他們也會出現在宣告式語法，將會嘗試傳遞*四個*參數`GetProductsPaged`方法與兩個參數來`TotalNumberOfProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="20b95-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="20b95-293">如果您忘記要移除這些`<asp:Parameter>`項目，瀏覽頁面透過瀏覽器，您會取得如下的錯誤訊息： *ObjectDataSource 'ObjectDataSource1' 找不到非泛型方法 'TotalNumberOfProducts' 具有參數： startRowIndex、 maximumRows*。</span><span class="sxs-lookup"><span data-stu-id="20b95-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="20b95-294">進行這些變更之後，ObjectDataSource s 宣告式語法看起來應該如下所示：</span><span class="sxs-lookup"><span data-stu-id="20b95-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="20b95-295">請注意，`EnablePaging`和`SelectCountMethod`內容已設定和`<asp:Parameter>`元素已經移除。</span><span class="sxs-lookup"><span data-stu-id="20b95-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="20b95-296">進行這些變更之後，圖 16 會顯示 [屬性] 視窗的螢幕擷取畫面。</span><span class="sxs-lookup"><span data-stu-id="20b95-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>


![若要使用自訂分頁，設定 ObjectDataSource 控制項](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="20b95-298">**圖 16**： 若要使用自訂分頁，設定 ObjectDataSource 控制項</span><span class="sxs-lookup"><span data-stu-id="20b95-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>


<span data-ttu-id="20b95-299">進行這些變更之後，請瀏覽此頁面，透過瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="20b95-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="20b95-300">您應該會看到 10 項產品列中，依字母順序排序。</span><span class="sxs-lookup"><span data-stu-id="20b95-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="20b95-301">請花一點時間逐步執行一個頁面的資料，一次。</span><span class="sxs-lookup"><span data-stu-id="20b95-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="20b95-302">自訂分頁更有效率地透過大量的資料頁面從使用者 s 觀點來看預設分頁和自訂分頁之間沒有視覺差異時，，因為它只會擷取需要為指定的頁面顯示這些記錄使用。</span><span class="sxs-lookup"><span data-stu-id="20b95-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>


<span data-ttu-id="20b95-303">[![資料、 Ordered 依產品名稱，是分頁使用自訂分頁](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="20b95-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="20b95-304">**圖 17**: 資料、 Ordered 依產品名稱，是分頁使用自訂分頁 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="20b95-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>


> [!NOTE]
> <span data-ttu-id="20b95-305">使用自訂分頁時，頁面計數值傳回 ObjectDataSource 的`SelectCountMethod`會儲存在 GridView 的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="20b95-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="20b95-306">其他的 GridView 變數`PageIndex`， `EditIndex`， `SelectedIndex`，`DataKeys`集合，以及其他會儲存在*控制狀態*，其中會保存 GridView s 的值為何`EnableViewState`屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="20b95-307">因為`PageCount`值保存在回傳時使用的分頁介面，包括帶您前往最後一頁的連結使用檢視狀態，請務必啟用 GridView 的檢視狀態。</span><span class="sxs-lookup"><span data-stu-id="20b95-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="20b95-308">（如果分頁介面沒有直接連結到最後一個頁面上，則您可能會停用檢視狀態）。</span><span class="sxs-lookup"><span data-stu-id="20b95-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>


<span data-ttu-id="20b95-309">按一下最後一個頁面連結導致回傳，並指示來更新 GridView 其`PageIndex`屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="20b95-310">按一下最後一個頁面連結時，會將指派 GridView 其`PageIndex`屬性設為其中一個值小於其`PageCount`屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="20b95-311">停用，檢視狀態`PageCount`值將會遺失在回傳而`PageIndex`改為指派的最大整數值。</span><span class="sxs-lookup"><span data-stu-id="20b95-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="20b95-312">GridView 接下來，會嘗試判斷資料列的起始索引乘以`PageSize`和`PageCount`屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="20b95-313">這會導致`OverflowException`因為產品超過允許的最大整數大小。</span><span class="sxs-lookup"><span data-stu-id="20b95-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="20b95-314">實作自訂分頁和排序</span><span class="sxs-lookup"><span data-stu-id="20b95-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="20b95-315">我們目前的自訂分頁實作需要的資料透過分頁的順序指定以靜態方式建立時`GetProductsPaged`預存程序。</span><span class="sxs-lookup"><span data-stu-id="20b95-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="20b95-316">不過，您可能已記下 GridView s 智慧標籤包含除了啟用分頁 選項之外，啟用排序核取方塊。</span><span class="sxs-lookup"><span data-stu-id="20b95-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="20b95-317">不幸的是，加入我們目前的自訂分頁實作 GridView 中排序支援時，只會排序資料的目前檢視頁面上的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="20b95-318">例如，如果您設定也支援分頁，並檢視資料，第一頁時，然後依產品名稱，依遞減順序排序 GridView 它會反轉產品的順序第 1 頁上。</span><span class="sxs-lookup"><span data-stu-id="20b95-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="20b95-319">如圖 18 所示，例如顯示初探為第一次的產品時以反向字母順序，會忽略 71 其他產品隨附之後初探，依字母順序，排序只有當記錄的第一頁會視為排序。</span><span class="sxs-lookup"><span data-stu-id="20b95-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>


<span data-ttu-id="20b95-320">[![只顯示資料目前頁面上進行排序](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="20b95-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="20b95-321">**圖 18**： 只顯示資料目前頁面上進行排序 ([按一下以檢視完整大小的影像](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="20b95-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>


<span data-ttu-id="20b95-322">因為排序從 BLL s 已擷取資料之後發生的排序只適用於目前頁面的資料項目`GetProductsPaged`方法，而且這個方法只會傳回特定網頁的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="20b95-323">若要實作正確排序，我們需要將排序運算式，以`GetProductsPaged`方法，以便可以適當地排名資料，再傳回特定的資料頁面。</span><span class="sxs-lookup"><span data-stu-id="20b95-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="20b95-324">我們會了解如何完成這項作業在教學課程中我們下一步。</span><span class="sxs-lookup"><span data-stu-id="20b95-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="20b95-325">實作自訂分頁並刪除</span><span class="sxs-lookup"><span data-stu-id="20b95-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="20b95-326">如果您啟用刪除功能的 GridView 的資料分頁使用自訂分頁技術，您會發現從最後一頁刪除最後一筆記錄時，GridView 消失而不是適當遞減 GridView 的`PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="20b95-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="20b95-327">若要重新產生這個 bug，啟用刪除只剛才所建立的教學課程。</span><span class="sxs-lookup"><span data-stu-id="20b95-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="20b95-328">移至最後一頁 （第 9 頁），其中您應該會看到單一產品因為我們分頁 81 產品，一次 10 項產品。</span><span class="sxs-lookup"><span data-stu-id="20b95-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="20b95-329">刪除此產品。</span><span class="sxs-lookup"><span data-stu-id="20b95-329">Delete this product.</span></span>

<span data-ttu-id="20b95-330">一旦刪除最後一個產品 GridView*應該*自動移至第八個頁面，以及這類功能使用預設分頁顯示。</span><span class="sxs-lookup"><span data-stu-id="20b95-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="20b95-331">使用自訂分頁時，不過，在刪除最後一個產品的最後一頁之後, GridView 只從畫面消失完全。</span><span class="sxs-lookup"><span data-stu-id="20b95-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="20b95-332">精確原因*為什麼*發生這種情況都是位元超出本教學課程的範圍，請參閱 <<c4> [ 刪除自訂分頁的 GridView 的最後一筆記錄的最後一頁](http://scottonwriting.net/sowblog/posts/7326.aspx)和來源的低層級的詳細資料這個問題。</span><span class="sxs-lookup"><span data-stu-id="20b95-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="20b95-333">在摘要它 s，因為下列一連串步驟，按一下 [刪除] 按鈕時執行的 GridView:</span><span class="sxs-lookup"><span data-stu-id="20b95-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="20b95-334">刪除記錄</span><span class="sxs-lookup"><span data-stu-id="20b95-334">Delete the record</span></span>
2. <span data-ttu-id="20b95-335">取得適當的記錄，以顯示所指定`PageIndex`和 `PageSize`</span><span class="sxs-lookup"><span data-stu-id="20b95-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="20b95-336">檢查以確定`PageIndex`不超過資料來源; 中的資料頁面的數目，如果它存在，會自動遞減 GridView 的`PageIndex`屬性</span><span class="sxs-lookup"><span data-stu-id="20b95-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="20b95-337">將適當的頁面資料的繫結至 GridView 使用在步驟 2 中取得的記錄</span><span class="sxs-lookup"><span data-stu-id="20b95-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="20b95-338">問題的起因是該中的步驟 2`PageIndex`時擷取要顯示的記錄仍在使用`PageIndex`已只會刪除其唯一記錄的最後一頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="20b95-339">因此，在步驟 2*沒有*會傳回記錄，因為該最後一頁的資料不再包含任何記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="20b95-340">然後，在步驟 3 中 GridView 實現，其`PageIndex`屬性大於資料來源中的頁面總數 （自我們 ve 已刪除最後一個記錄中的最後一頁），並因此遞減其`PageIndex`屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="20b95-341">步驟 4 中 GridView 會嘗試將本身繫結至在步驟 2; 擷取的資料不過，在步驟 2 中未傳回任何記錄，因此導致空的 GridView。</span><span class="sxs-lookup"><span data-stu-id="20b95-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="20b95-342">使用預設分頁時，此問題不 t 介面因為在步驟 2 中*所有*從資料來源擷取記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="20b95-343">若要修正此問題，我們有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="20b95-343">To fix this we have two options.</span></span> <span data-ttu-id="20b95-344">第一個是建立事件處理常式 GridView s`RowDeleted`決定只刪除網頁中顯示的多少筆記錄的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="20b95-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="20b95-345">如果發生只有一筆記錄，然後將它刪除的記錄必須已被的最後一個，我們要遞減的 GridView s `PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="20b95-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="20b95-346">當然，我們只想要更新`PageIndex`如果刪除作業實際上成功，這可藉由確保`e.Exception`屬性是`null`。</span><span class="sxs-lookup"><span data-stu-id="20b95-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="20b95-347">這種方式運作，因為它會更新`PageIndex`在步驟 1 之後但在之前步驟 2。</span><span class="sxs-lookup"><span data-stu-id="20b95-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="20b95-348">因此，在步驟 2 中，會傳回一組適當的記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="20b95-349">若要達成此目的，使用下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="20b95-349">To accomplish this, use code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="20b95-350">一種解決方法是建立事件處理常式 ObjectDataSource s`RowDeleted`事件，並設定`AffectedRows`屬性設為 1 的值。</span><span class="sxs-lookup"><span data-stu-id="20b95-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="20b95-351">在 GridView 更新之前刪除的記錄，在步驟 1 中 （但然後再重新擷取步驟 2 中的資料），其`PageIndex`如果一或多個資料列作業所影響的屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="20b95-352">不過， `AffectedRows` objectdatasource 未設定屬性，因此會省略此步驟。</span><span class="sxs-lookup"><span data-stu-id="20b95-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="20b95-353">具有執行此步驟的其中一種方式是手動設定`AffectedRows`如果順利完成刪除作業的屬性。</span><span class="sxs-lookup"><span data-stu-id="20b95-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="20b95-354">這可以使用下列程式碼來完成：</span><span class="sxs-lookup"><span data-stu-id="20b95-354">This can be accomplished using code like the following:</span></span>


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="20b95-355">這些事件處理常式的兩個程式碼可以在程式碼後置類別的`EfficientPaging.aspx`範例。</span><span class="sxs-lookup"><span data-stu-id="20b95-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="20b95-356">比較效能的預設和自訂分頁</span><span class="sxs-lookup"><span data-stu-id="20b95-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="20b95-357">因為自訂分頁只會擷取所需的記錄，則傳回預設分頁*所有*的檢視，每個頁面記錄它 s 清除自訂分頁會比預設分頁更有效率。</span><span class="sxs-lookup"><span data-stu-id="20b95-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="20b95-358">但是就是如何更有效率的作法是自訂分頁嗎？</span><span class="sxs-lookup"><span data-stu-id="20b95-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="20b95-359">從預設分頁移到自訂分頁，可以看到哪一種效能提升？</span><span class="sxs-lookup"><span data-stu-id="20b95-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="20b95-360">不幸的是，有 s 不適合大小所有這裡回答。</span><span class="sxs-lookup"><span data-stu-id="20b95-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="20b95-361">提升的效能取決於許多因素，最明顯正在透過正在呼叫的記錄和負載數目的兩個放在 web 伺服器和資料庫伺服器之間的資料庫伺服器和通訊通道。</span><span class="sxs-lookup"><span data-stu-id="20b95-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="20b95-362">用於具有少數的數十個記錄的小型資料表，效能差異會造成影響。</span><span class="sxs-lookup"><span data-stu-id="20b95-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="20b95-363">對於大型資料表，具有數千部數十萬個資料列，來使用的效能差異是，嚴重。</span><span class="sxs-lookup"><span data-stu-id="20b95-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="20b95-364">我，發行項[ASP.NET 2.0 與 SQL Server 2005 中的自訂分頁](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)，包含執行至展現中時包含的資料庫資料表進行分頁這兩種分頁技術之間的效能差異某些效能測試50,000 筆記錄。</span><span class="sxs-lookup"><span data-stu-id="20b95-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="20b95-365">我可以在這些測試中檢查這兩個執行 SQL Server 層級查詢的時間 (使用[SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) 和 ASP.NET 頁面使用[ASP.NET 的追蹤功能](https://msdn.microsoft.com/library/y13fw6we.aspx)。</span><span class="sxs-lookup"><span data-stu-id="20b95-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="20b95-366">請注意，這些測試是在單一的作用中使用者，我開發方塊上執行，因此科學而不會模擬一般網站的負載模式。</span><span class="sxs-lookup"><span data-stu-id="20b95-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="20b95-367">不論如何，結果會說明執行時間的預設和自訂分頁中的相對差異使用夠大的資料量時。</span><span class="sxs-lookup"><span data-stu-id="20b95-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>


|  | <span data-ttu-id="20b95-368">**Avg.持續時間 （秒）**</span><span class="sxs-lookup"><span data-stu-id="20b95-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="20b95-369">**讀取**</span><span class="sxs-lookup"><span data-stu-id="20b95-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="20b95-370">**預設分頁 SQL 程式碼剖析工具**</span><span class="sxs-lookup"><span data-stu-id="20b95-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="20b95-371">1.411</span><span class="sxs-lookup"><span data-stu-id="20b95-371">1.411</span></span> | <span data-ttu-id="20b95-372">383</span><span class="sxs-lookup"><span data-stu-id="20b95-372">383</span></span> |
| <span data-ttu-id="20b95-373">**自訂分頁 SQL 程式碼剖析工具**</span><span class="sxs-lookup"><span data-stu-id="20b95-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="20b95-374">0.002</span><span class="sxs-lookup"><span data-stu-id="20b95-374">0.002</span></span> | <span data-ttu-id="20b95-375">29</span><span class="sxs-lookup"><span data-stu-id="20b95-375">29</span></span> |
| <span data-ttu-id="20b95-376">**預設分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="20b95-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="20b95-377">2.379</span><span class="sxs-lookup"><span data-stu-id="20b95-377">2.379</span></span> | <span data-ttu-id="20b95-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="20b95-378">*N/A*</span></span> |
| <span data-ttu-id="20b95-379">**自訂分頁 ASP.NET 追蹤**</span><span class="sxs-lookup"><span data-stu-id="20b95-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="20b95-380">0.029</span><span class="sxs-lookup"><span data-stu-id="20b95-380">0.029</span></span> | <span data-ttu-id="20b95-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="20b95-381">*N/A*</span></span> |


<span data-ttu-id="20b95-382">如您所見，擷取資料的特定頁面需要較少讀取 354 平均，並在大部分的時間內完成。</span><span class="sxs-lookup"><span data-stu-id="20b95-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="20b95-383">ASP.NET 頁面中，在自訂頁面無法轉譯的 1/100 接近<sup>th</sup>所花費時間時使用的預設分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="20b95-384">請參閱[我文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)如需詳細資訊，對這些結果，以及程式碼和資料庫，您可以下載重現您自己的環境中的這些測試。</span><span class="sxs-lookup"><span data-stu-id="20b95-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="20b95-385">總結</span><span class="sxs-lookup"><span data-stu-id="20b95-385">Summary</span></span>

<span data-ttu-id="20b95-386">預設分頁是很簡單，在資料 Web 控制項 s 智慧標籤中實作只核取 啟用分頁的核取方塊，但是這類簡化代價效能。</span><span class="sxs-lookup"><span data-stu-id="20b95-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="20b95-387">使用預設分頁時，當使用者要求資料的任何頁面*所有*傳回記錄，即使只有極少數的它們可能會顯示。</span><span class="sxs-lookup"><span data-stu-id="20b95-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="20b95-388">為了打擊這樣的效能負荷，ObjectDataSource 提供替代分頁選項自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="20b95-389">雖然預設分頁 s 效能問題，只需要顯示，那些記錄中擷取自訂分頁做了改善它 s 更為複雜，若要實作自訂分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="20b95-390">首先，您必須，用來正確 （且有效地） 存取要求的記錄的特定子集是撰寫查詢。</span><span class="sxs-lookup"><span data-stu-id="20b95-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="20b95-391">這可以透過完成許多種;我們檢查本教學課程中的一個是使用新的 SQL Server 2005 的`ROW_NUMBER()`為 rank 函數結果，並再返回只會產生其次序落在指定範圍內。</span><span class="sxs-lookup"><span data-stu-id="20b95-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="20b95-392">此外，我們需要加入方法來判斷正在透過呼叫的記錄總數。</span><span class="sxs-lookup"><span data-stu-id="20b95-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="20b95-393">在建立之後這些 DAL 和 BLL 方法，我們也需要設定 ObjectDataSource，讓它可以決定總記錄數需分頁處理透過以及可以正確啟動的資料列索引和最大資料列將值傳遞至 BLL。</span><span class="sxs-lookup"><span data-stu-id="20b95-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="20b95-394">在實作自訂分頁並需要幾個步驟並不幾乎只要預設分頁時，自訂分頁時，必須夠大的資料量進行分頁。</span><span class="sxs-lookup"><span data-stu-id="20b95-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="20b95-395">檢查結果顯示、 自訂分頁可以剖析從 ASP.NET 頁面呈現時間的秒數，而且可以由一或多個的數量級淡化資料庫伺服器上的負載。</span><span class="sxs-lookup"><span data-stu-id="20b95-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="20b95-396">祝您程式設計 ！</span><span class="sxs-lookup"><span data-stu-id="20b95-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="20b95-397">關於作者</span><span class="sxs-lookup"><span data-stu-id="20b95-397">About the Author</span></span>

<span data-ttu-id="20b95-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的七個 ASP/ASP.NET 書籍和的創辦[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已從 1998 年使用 Microsoft Web 技術。</span><span class="sxs-lookup"><span data-stu-id="20b95-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="20b95-399">Scott 可做為獨立顧問、 訓練和寫入器。</span><span class="sxs-lookup"><span data-stu-id="20b95-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="20b95-400">他最新的活頁簿[ *Sam 教導您自己 ASP.NET 2.0 24 小時內*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="20b95-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="20b95-401">他可以在達到[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)或透過他的部落格，這可以在找到[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="20b95-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="20b95-402">[上一頁](paging-and-sorting-report-data-cs.md)
> [下一頁](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="20b95-402">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
