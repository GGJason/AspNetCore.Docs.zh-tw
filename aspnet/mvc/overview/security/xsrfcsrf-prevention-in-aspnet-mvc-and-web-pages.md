---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: 在 ASP.NET MVC 和網頁的 XSRF/CSRF 防護 |Microsoft 文件
author: Rick-Anderson
description: 跨站台要求偽造 （也稱為 XSRF 或 CSRF） 是 web 裝載的應用程式讓惡意網站可能會影響 interacti 攻擊...
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/10/2018
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="5a574-103">在 ASP.NET MVC 和網頁的 XSRF/CSRF 防護</span><span class="sxs-lookup"><span data-stu-id="5a574-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="5a574-104">由[Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="5a574-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="5a574-105">跨網站要求偽造 （也稱為 XSRF 或 CSRF） 是對 web 裝載的應用程式讓惡意網站可能會影響用戶端瀏覽器與該瀏覽器的受信任的網站之間的互動的攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="5a574-106">這些攻擊都可能因為網頁瀏覽器將會傳送給網站的自動與每個要求的驗證權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="5a574-107">標準範例是驗證 cookie，例如 ASP。網路的表單驗證票證。</span><span class="sxs-lookup"><span data-stu-id="5a574-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="5a574-108">不過，這些攻擊可以目標網站使用任何持續性驗證機制 （例如 Windows 驗證、 基本和其他等等）。</span><span class="sxs-lookup"><span data-stu-id="5a574-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="5a574-109">XSRF 攻擊是不同的網路釣魚攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="5a574-110">網路釣魚攻擊需要犧牲者。</span><span class="sxs-lookup"><span data-stu-id="5a574-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="5a574-111">在詐騙攻擊中，惡意網站會模仿目標網站，和受害者騙到提供給攻擊者的機密資訊。</span><span class="sxs-lookup"><span data-stu-id="5a574-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="5a574-112">在 XSRF 攻擊中，通常會沒有互動的必要。</span><span class="sxs-lookup"><span data-stu-id="5a574-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="5a574-113">相反地，攻擊者信賴憑證者會自動將所有相關的 cookie 傳送至目的地網站的瀏覽器上。</span><span class="sxs-lookup"><span data-stu-id="5a574-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="5a574-114">如需詳細資訊，請參閱[開啟 Web 應用程式安全性專案](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。</span><span class="sxs-lookup"><span data-stu-id="5a574-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="5a574-115">攻擊的剖析</span><span class="sxs-lookup"><span data-stu-id="5a574-115">Anatomy of an attack</span></span>

<span data-ttu-id="5a574-116">若要逐步解說 XSRF 攻擊，請考慮使用者想要執行某些線上銀行交易。</span><span class="sxs-lookup"><span data-stu-id="5a574-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="5a574-117">此使用者第一次造訪 WoodgroveBank.com 和記錄檔中，此時回應標頭將包含驗證 cookie:</span><span class="sxs-lookup"><span data-stu-id="5a574-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="5a574-118">驗證 cookie 會以工作階段 cookie，因為它將會自動清除瀏覽器瀏覽器處理序結束時。</span><span class="sxs-lookup"><span data-stu-id="5a574-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="5a574-119">不過，這段時間，直到瀏覽器會自動包含與每個要求 WoodgroveBank.com cookie。使用者現在想要傳送到另一個帳戶，$1000，因此她填寫表單，銀行網站上，並在瀏覽器對伺服器提出此要求：</span><span class="sxs-lookup"><span data-stu-id="5a574-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="5a574-120">這項作業具有副作用 （啟始貨幣交易），因為已選擇銀行網站，若要起始這項作業需要 HTTP POST。</span><span class="sxs-lookup"><span data-stu-id="5a574-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="5a574-121">伺服器會讀取要求的驗證權杖、 查閱目前使用者的帳戶號碼、 驗證足夠資金存在，而且就會起始到目的地帳戶交易。</span><span class="sxs-lookup"><span data-stu-id="5a574-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="5a574-122">她的線上銀行完成，使用者移動離開銀行網站，造訪網站上的其他位置。</span><span class="sxs-lookup"><span data-stu-id="5a574-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="5a574-123">其中一個這些站台 – fabrikam.com – 包括內嵌在頁面上的下列標記&lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="5a574-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="5a574-124">這會將會導致瀏覽器以進行這項要求：</span><span class="sxs-lookup"><span data-stu-id="5a574-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="5a574-125">攻擊者會利用的事實以及使用者可能仍然有有效的驗證權杖的目標網站，她會導致瀏覽器將 HTTP POST 到目標站台會自動使用 Javascript 的小型程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="5a574-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="5a574-126">如果仍然有效驗證權杖，銀行網站將會起始將 $250 傳入攻擊者所選擇的帳戶。</span><span class="sxs-lookup"><span data-stu-id="5a574-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="5a574-127">無效的補救措施</span><span class="sxs-lookup"><span data-stu-id="5a574-127">Ineffective mitigations</span></span>

<span data-ttu-id="5a574-128">值得注意在上述案例中，WoodgroveBank.com 已透過 SSL 存取，而且有 SSL 驗證 cookie 已不足以防止攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="5a574-129">攻擊者就可以指定[URI 配置](http://en.wikipedia.org/wiki/URI_scheme)(https) 在她&lt;表單&gt;項目，並在瀏覽器會繼續，只要這些 cookie 是一致的 uri，將會過期的 cookie 傳送到目標站台預期的目標的配置。</span><span class="sxs-lookup"><span data-stu-id="5a574-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="5a574-130">其中一個可以說，使用者應該不請瀏覽受信任的網站，為只有受信任的網站是協助仍然可以保持安全線上瀏覽。</span><span class="sxs-lookup"><span data-stu-id="5a574-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="5a574-131">某些真資料，但不幸的是這項建議不一定實用。</span><span class="sxs-lookup"><span data-stu-id="5a574-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="5a574-132">可能是使用者 「 信任 」 當地新聞網站 ConsolidatedMessenger。</span><span class="sxs-lookup"><span data-stu-id="5a574-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="5a574-133">ConsolidatedMessenger.com 和會移至網站，請瀏覽但該站台都有 XSS 弱點可能會讓攻擊者將 fabrikam.com 執行的程式碼中的相同程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="5a574-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="5a574-134">您可以確認傳入要求可以[推薦者標頭](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)參考您的網域。</span><span class="sxs-lookup"><span data-stu-id="5a574-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="5a574-135">這樣會停止從協力廠商網域不知情的狀況下提交要求。</span><span class="sxs-lookup"><span data-stu-id="5a574-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="5a574-136">不過，有些人停用其瀏覽器推薦者標頭，基於隱私原因，而且如果犧牲者已安裝特定安全軟體攻擊者可以有時假冒該標頭。</span><span class="sxs-lookup"><span data-stu-id="5a574-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="5a574-137">正在驗證[推薦者標頭](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)不會被視為安全的方法，以防止 XSRF 攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="5a574-138">Web 堆疊執行階段 XSRF 補救措施</span><span class="sxs-lookup"><span data-stu-id="5a574-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="5a574-139">ASP.NET Web 堆疊執行階段使用的變數[同步器 token 模式](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)防禦 XSRF 攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="5a574-140">一般表單的 同步器 token 模式是伺服器 （除了驗證語彙基元） 的每個 HTTP POST 送出兩個防 XSRF 權杖： 當做 cookie，而表單值為另一個權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="5a574-141">ASP.NET 執行階段所產生的語彙基元值不具決定性或可預測的攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="5a574-142">當提交語彙基元時，伺服器會允許兩個語彙基元傳遞比較核取時，才進行處理的要求。</span><span class="sxs-lookup"><span data-stu-id="5a574-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="5a574-143">XSRF 要求驗證*工作階段權杖*會儲存為 HTTP cookie，而且目前包含其裝載中的下列資訊：</span><span class="sxs-lookup"><span data-stu-id="5a574-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="5a574-144">安全性權杖，隨機的 128 位元識別碼所組成。</span><span class="sxs-lookup"><span data-stu-id="5a574-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="5a574-145">下圖顯示使用 Internet Explorer F12 開發人員工具所顯示的 XSRF 要求驗證工作階段權杖: (注意，這是目前的實作，而且主體，甚至可能，變更。)</span><span class="sxs-lookup"><span data-stu-id="5a574-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="5a574-146">*欄位語彙基元*儲存為`<input type="hidden" />`且包含其裝載中的下列資訊：</span><span class="sxs-lookup"><span data-stu-id="5a574-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="5a574-147">登入之使用者的使用者名稱 （如果通過驗證）。</span><span class="sxs-lookup"><span data-stu-id="5a574-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="5a574-148">所提供的任何其他資料[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)。</span><span class="sxs-lookup"><span data-stu-id="5a574-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="5a574-149">防 XSRF 權杖的承載都會經過加密並簽署，所以使用工具來檢查權杖時，您無法檢視的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="5a574-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="5a574-150">當 web 應用程式以 ASP.NET 4.0 為目標時，密碼編譯服務提供的[MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)常式。</span><span class="sxs-lookup"><span data-stu-id="5a574-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="5a574-151">當 web 應用程式的目標 ASP.NET 4.5 或更高版本、 密碼編譯服務所提供的[MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))常式，其可提供較佳的效能、 擴充性和安全性。</span><span class="sxs-lookup"><span data-stu-id="5a574-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="5a574-152">請參閱下列部落格文章以取得詳細資料：</span><span class="sxs-lookup"><span data-stu-id="5a574-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="5a574-153">ASP.NET 4.5 中的密碼編譯增強功能、 pt。1</span><span class="sxs-lookup"><span data-stu-id="5a574-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="5a574-154">ASP.NET 4.5 中的密碼編譯增強功能、 pt。2</span><span class="sxs-lookup"><span data-stu-id="5a574-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="5a574-155">ASP.NET 4.5 中的密碼編譯增強功能、 pt。3</span><span class="sxs-lookup"><span data-stu-id="5a574-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="5a574-156">產生權杖</span><span class="sxs-lookup"><span data-stu-id="5a574-156">Generating the tokens</span></span>

<span data-ttu-id="5a574-157">若要產生的防 XSRF 權杖，請呼叫[ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC 檢視中的方法或@AntiForgery.GetHtml從 Razor 頁面 （)。</span><span class="sxs-lookup"><span data-stu-id="5a574-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="5a574-158">然後，執行階段會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="5a574-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="5a574-159">如果目前的 HTTP 要求中已包含的防 XSRF 工作階段權杖 (防 XSRF cookie \_ \_RequestVerificationToken)，從其擷取安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="5a574-160">如果 HTTP 要求不包含防 XSRF 工作階段權杖或安全性權杖的擷取失敗，就會產生新的隨機的防 XSRF 權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="5a574-161">防 XSRF 欄位語彙基元會產生使用從上個步驟 (1) 和目前的登入之使用者的身分識別的安全性 token。</span><span class="sxs-lookup"><span data-stu-id="5a574-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="5a574-162">(如需判斷使用者的身分識別的詳細資訊，請參閱**[具有特殊的支援案例](#_Scenarios_with_special)**下一節。)此外，如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx)是設定，執行階段會呼叫其[GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)方法並將傳回的字串包含在欄位語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="5a574-163">(請參閱**[組態和擴充性](#_Configuration_and_extensibility)**節的詳細資訊。)</span><span class="sxs-lookup"><span data-stu-id="5a574-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="5a574-164">如果步驟 (1) 中產生新的 ANTI-XSRF 權杖，新的工作階段語彙基元會建立包含該，並將加入至傳出 HTTP cookie 集合。</span><span class="sxs-lookup"><span data-stu-id="5a574-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="5a574-165">步驟 (2) 中的欄位語彙基元會包裝在`<input type="hidden" />`項目，然後這個 HTML 標記將會傳回值`Html.AntiForgeryToken()`或`AntiForgery.GetHtml()`。</span><span class="sxs-lookup"><span data-stu-id="5a574-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="5a574-166">驗證權杖</span><span class="sxs-lookup"><span data-stu-id="5a574-166">Validating the tokens</span></span>

<span data-ttu-id="5a574-167">若要驗證連入的防 XSRF 權杖，包括開發人員[ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)屬性她 MVC 動作或控制器，或她呼叫`@AntiForgery.Validate()`從她 Razor 頁面。</span><span class="sxs-lookup"><span data-stu-id="5a574-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="5a574-168">執行階段會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="5a574-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="5a574-169">會讀取內送工作階段權杖和欄位語彙基元，並從每個擷取的防 XSRF 權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="5a574-170">防 XSRF 權杖必須是每個步驟 (2) 產生常式中完全相同。</span><span class="sxs-lookup"><span data-stu-id="5a574-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="5a574-171">如果目前的使用者驗證時，她的使用者名稱進行比較與儲存在欄位語彙基元中的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="5a574-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="5a574-172">使用者名稱必須相符。</span><span class="sxs-lookup"><span data-stu-id="5a574-172">The usernames must match.</span></span>
3. <span data-ttu-id="5a574-173">如果[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)設定時，執行階段呼叫其*ValidateAdditionalData*方法。</span><span class="sxs-lookup"><span data-stu-id="5a574-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="5a574-174">此方法必須傳回布林值*true*。</span><span class="sxs-lookup"><span data-stu-id="5a574-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="5a574-175">如果驗證成功，允許要求繼續執行。</span><span class="sxs-lookup"><span data-stu-id="5a574-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="5a574-176">如果驗證失敗，將會擲回架構*HttpAntiForgeryException*。</span><span class="sxs-lookup"><span data-stu-id="5a574-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="5a574-177">失敗狀況</span><span class="sxs-lookup"><span data-stu-id="5a574-177">Failure conditions</span></span>

<span data-ttu-id="5a574-178">任何從 ASP.NET Web 堆疊執行階段 v2 *HttpAntiForgeryException*期間擲回驗證將會包含有關錯誤的詳細的資訊。</span><span class="sxs-lookup"><span data-stu-id="5a574-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="5a574-179">目前已定義的失敗狀況如下：</span><span class="sxs-lookup"><span data-stu-id="5a574-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="5a574-180">表單語彙基元的工作階段權杖要求中沒有。</span><span class="sxs-lookup"><span data-stu-id="5a574-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="5a574-181">工作階段權杖或表單語彙基元無法讀取。</span><span class="sxs-lookup"><span data-stu-id="5a574-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="5a574-182">最可能的原因是伺服器陣列執行 ASP.NET Web 堆疊執行階段或伺服陣列的版本不相符， &lt;machineKey&gt; Web.config 中的項目各有不同的電腦。</span><span class="sxs-lookup"><span data-stu-id="5a574-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="5a574-183">您可以使用 Fiddler 之類的工具來強制執行此例外狀況任一防 XSRF 權杖遭到竄改。</span><span class="sxs-lookup"><span data-stu-id="5a574-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="5a574-184">已交換的工作階段權杖和欄位語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="5a574-185">工作階段權杖和欄位語彙基元包含不相符的安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="5a574-186">欄位語彙基元中內嵌使用者名稱不符合目前已登入之使用者的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="5a574-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="5a574-187">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)*方法會傳回*false*。</span><span class="sxs-lookup"><span data-stu-id="5a574-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="5a574-188">防 XSRF 設備可能也會執行其他檢查權杖產生或驗證期間，這些檢查期間發生的失敗可能會導致擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="5a574-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="5a574-189">請參閱[WIF / ACS 宣告型驗證](#_WIF_ACS)和**[組態和擴充性](#_Configuration_and_extensibility)**區段，如需詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="5a574-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="5a574-190">使用特殊的支援案例</span><span class="sxs-lookup"><span data-stu-id="5a574-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="5a574-191">匿名驗證</span><span class="sxs-lookup"><span data-stu-id="5a574-191">Anonymous authentication</span></span>

<span data-ttu-id="5a574-192">防 XSRF 系統包含 「 匿名 」 定義是以使用者的匿名使用者的特殊支援其中*IIdentity.IsAuthenticated*屬性會傳回*false*。</span><span class="sxs-lookup"><span data-stu-id="5a574-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="5a574-193">案例包括提供登入頁面 （之前驗證使用者），其中應用程式使用一種機制以外的自訂驗證配置來當做 XSRF 保護*IIdentity*來識別使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="5a574-194">若要支援這些案例，請記得安全性權杖，也就是 128 位元隨機產生不透明識別項聯結的工作階段和欄位 token。</span><span class="sxs-lookup"><span data-stu-id="5a574-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="5a574-195">這個安全性權杖用來追蹤她巡覽網站，讓它實際上可以做的匿名識別項目的個別使用者的工作階段。</span><span class="sxs-lookup"><span data-stu-id="5a574-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="5a574-196">取代使用者名稱會使用空的字串，如上面所述的產生和驗證常式。</span><span class="sxs-lookup"><span data-stu-id="5a574-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="5a574-197">WIF / ACS 宣告型驗證</span><span class="sxs-lookup"><span data-stu-id="5a574-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="5a574-198">一般來說， *IIdentity*內建於.NET Framework 類別都具有屬性的*IIdentity.Name*足以唯一識別特定的應用程式內的特定使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="5a574-199">例如， *FormsIdentity.Name*傳回使用者名稱儲存在成員資格資料庫中 （這是唯一的所有應用程式視資料庫而定）， *WindowsIdentity.Name*傳回網域限定識別使用者，等等。</span><span class="sxs-lookup"><span data-stu-id="5a574-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="5a574-200">這些系統提供的不只驗證，它們也*識別*應用程式的使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="5a574-201">宣告式驗證，相反地，不一定需要識別特定的使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="5a574-202">相反地， *ClaimsPrincipal*和*ClaimsIdentity*類型相關聯的一組*宣告*情況下，個別的宣告可能是"is 18 + 歲"或"是系統管理員 」 以任何其他項目。</span><span class="sxs-lookup"><span data-stu-id="5a574-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="5a574-203">由於尚未一定識別使用者，無法使用執行階段*ClaimsIdentity.Name*屬性做為此特定使用者的唯一識別碼。</span><span class="sxs-lookup"><span data-stu-id="5a574-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="5a574-204">小組已經看到真實世界範例其中*ClaimsIdentity.Name*傳回*null*、 傳回 （顯示） 的好記的名稱，或否則會傳回不適合做為唯一的識別項使用的字串使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="5a574-205">許多使用宣告式驗證的部署使用[Azure 存取控制服務](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx)(ACS) 特別。</span><span class="sxs-lookup"><span data-stu-id="5a574-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="5a574-206">ACS 可讓開發人員設定個別*身分識別提供者*（例如 Microsoft 帳戶提供者的 ADFS，OpenID 提供者類似 yahoo ！ 等），和身分識別提供者傳回*命名識別項*.</span><span class="sxs-lookup"><span data-stu-id="5a574-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="5a574-207">這些名稱識別項可能包含個人識別資訊 (PII)，像是電子郵件地址，或它們可以匿名像私有的個人識別碼 (PPID)。</span><span class="sxs-lookup"><span data-stu-id="5a574-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="5a574-208">不論如何，tuple （身分識別提供者，名稱識別項） 不夠作為特定的使用者適當的追蹤 token，而她瀏覽網站，因此 ASP.NET Web 堆疊執行階段產生時，可以使用 tuple 取代使用者名稱和驗證防 XSRF 欄位語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="5a574-209">身分識別提供者 」 和 「 名稱識別碼的特定 Uri 是：</span><span class="sxs-lookup"><span data-stu-id="5a574-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="5a574-210">(請參閱此[ACS 文件頁面](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)如需詳細資訊。)</span><span class="sxs-lookup"><span data-stu-id="5a574-210">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="5a574-211">當產生或驗證權杖時，ASP.NET Web 堆疊執行階段會在執行階段嘗試繫結的型別：</span><span class="sxs-lookup"><span data-stu-id="5a574-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="5a574-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` （適用於 WIF SDK。)</span><span class="sxs-lookup"><span data-stu-id="5a574-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="5a574-213">`System.Security.Claims.ClaimsIdentity` （適用於.NET 4.5)。</span><span class="sxs-lookup"><span data-stu-id="5a574-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="5a574-214">如果這些型別存在，且目前使用者的*IIIIdentity*下列其中一種實作或子類型、 身分識別提供者 （名稱識別項），將會使用防 XSRF 設備 tuple 取代產生時，使用者名稱和驗證權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="5a574-215">如果沒有這類 tuple 存在時，要求將會失敗，開發人員說明如何設定來了解使用中的特定宣告為基礎的驗證機制的防 XSRF 系統發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="5a574-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="5a574-216">請參閱**[組態和擴充性](#_Configuration_and_extensibility)**節的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="5a574-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="5a574-217">OAuth / OpenID 驗證</span><span class="sxs-lookup"><span data-stu-id="5a574-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="5a574-218">最後，防 XSRF 設備有特殊的應用程式使用 OAuth 或 OpenID 驗證的支援。</span><span class="sxs-lookup"><span data-stu-id="5a574-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="5a574-219">這項支援是啟發學習法為基礎： 如果目前*IIdentity.Name*開頭為 http:// 或 https:// ，然後將完成的使用者名稱比較使用序數比較子，而不是預設 OrdinalIgnoreCase 比較子。</span><span class="sxs-lookup"><span data-stu-id="5a574-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="5a574-220">組態和擴充性</span><span class="sxs-lookup"><span data-stu-id="5a574-220">Configuration and extensibility</span></span>

<span data-ttu-id="5a574-221">有時候，開發人員可能想更加嚴格控制的防 XSRF 產生和驗證行為。</span><span class="sxs-lookup"><span data-stu-id="5a574-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="5a574-222">比方說，或許自動新增至回應的 HTTP cookie 將 MVC 和網頁的協助程式的預設行為是讓人困擾，並開發人員可能想要保存其他地方的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="5a574-223">有兩個 Api，來協助進行此設定：</span><span class="sxs-lookup"><span data-stu-id="5a574-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="5a574-224">*GetTokens*方法會採用做為輸入現有 XSRF 要求驗證工作階段語彙基元 （這可能是 null） 和產生做為輸出的新 XSRF 要求驗證工作階段語彙基元和欄位語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="5a574-225">語彙基元是無裝飾; 只是不透明的字串*formToken*值將會執行個體不包裝在&lt;輸入&gt;標記。</span><span class="sxs-lookup"><span data-stu-id="5a574-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="5a574-226">*NewCookieToken*值可能為 null; 如果發生這種情況，則*oldCookieToken*值仍然有效，而且需要設定任何新的回應 cookie。</span><span class="sxs-lookup"><span data-stu-id="5a574-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="5a574-227">呼叫端*GetTokens*負責保存任何必要的回應 cookie 或產生任何必要的標記; *GetTokens*方法本身並不會更改副作用的回應。</span><span class="sxs-lookup"><span data-stu-id="5a574-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="5a574-228">*驗證*方法會採用內送工作階段和欄位語彙基元，而且其上執行上述的驗證邏輯。</span><span class="sxs-lookup"><span data-stu-id="5a574-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="5a574-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="5a574-229">AntiForgeryConfig</span></span>

<span data-ttu-id="5a574-230">開發人員可能會設定從應用程式的防 XSRF 系統\_開始。</span><span class="sxs-lookup"><span data-stu-id="5a574-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="5a574-231">以程式設計方式設定。</span><span class="sxs-lookup"><span data-stu-id="5a574-231">Configuration is programmatic.</span></span> <span data-ttu-id="5a574-232">靜態屬性*AntiForgeryConfig*類型說明如下。</span><span class="sxs-lookup"><span data-stu-id="5a574-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="5a574-233">大部分使用宣告的使用者會想要設定 UniqueClaimTypeIdentifier 屬性。</span><span class="sxs-lookup"><span data-stu-id="5a574-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="5a574-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="5a574-234">**Property**</span></span> | <span data-ttu-id="5a574-235">**描述**</span><span class="sxs-lookup"><span data-stu-id="5a574-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="5a574-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="5a574-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="5a574-237">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) ，在語彙基元產生期間提供額外的資料和權杖驗證期間會耗用額外的資料。</span><span class="sxs-lookup"><span data-stu-id="5a574-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="5a574-238">預設值是*null*。</span><span class="sxs-lookup"><span data-stu-id="5a574-238">The default value is *null*.</span></span> <span data-ttu-id="5a574-239">如需詳細資訊，請參閱[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) > 一節。</span><span class="sxs-lookup"><span data-stu-id="5a574-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="5a574-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="5a574-240">**CookieName**</span></span> | <span data-ttu-id="5a574-241">提供用來儲存防 XSRF 工作階段權杖的 HTTP cookie 名稱的字串。</span><span class="sxs-lookup"><span data-stu-id="5a574-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="5a574-242">如果未設定此值，產生的名稱將會自動根據應用程式的已部署的虛擬路徑。</span><span class="sxs-lookup"><span data-stu-id="5a574-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="5a574-243">預設值是*null*。</span><span class="sxs-lookup"><span data-stu-id="5a574-243">The default value is *null*.</span></span> |
| <span data-ttu-id="5a574-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="5a574-244">**RequireSsl**</span></span> | <span data-ttu-id="5a574-245">布林值，指出是否需要 SSL 安全保護的通道上送出的防 XSRF 權杖。</span><span class="sxs-lookup"><span data-stu-id="5a574-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="5a574-246">如果此值為*true*，任何自動產生的 cookie 會有 「 安全 」 的旗標設定，如果從呼叫中不會透過 SSL 提交的要求，將會擲回的防 XSRF Api。</span><span class="sxs-lookup"><span data-stu-id="5a574-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="5a574-247">預設值為 *false*。</span><span class="sxs-lookup"><span data-stu-id="5a574-247">The default value is *false*.</span></span> |
| <span data-ttu-id="5a574-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="5a574-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="5a574-249">布林值，指出是否防 XSRF 系統應該停用其支援的宣告式身分識別。</span><span class="sxs-lookup"><span data-stu-id="5a574-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="5a574-250">如果此值為*true*，系統會假設*IIdentity.Name*很適合做為每個使用者的唯一識別項，將不會嘗試特殊案例*IClaimsIdentity*或*ClClaimsIdentity*中所述[WIF / ACS 宣告型驗證](#_WIF_ACS)> 一節。</span><span class="sxs-lookup"><span data-stu-id="5a574-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="5a574-251">預設值是 `false`。</span><span class="sxs-lookup"><span data-stu-id="5a574-251">The default value is `false`.</span></span> |
| <span data-ttu-id="5a574-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="5a574-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="5a574-253">字串，表示哪些宣告型別很適合做為每個使用者的唯一識別項。</span><span class="sxs-lookup"><span data-stu-id="5a574-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="5a574-254">如果這個值是設定和目前*IIdentity*宣告為基礎，系統會嘗試擷取之型別的宣告所指定*UniqueClaimTypeIdentifier*，將會使用對應的值取代產生的欄位語彙基元時，使用者的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="5a574-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="5a574-255">如果找不到宣告類型，系統會讓要求失敗。</span><span class="sxs-lookup"><span data-stu-id="5a574-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="5a574-256">預設值是*null*，表示系統應該使用身分識別提供者 （名稱識別項） 來取代使用者的使用者名稱如先前所述的 tuple。</span><span class="sxs-lookup"><span data-stu-id="5a574-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="5a574-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="5a574-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="5a574-258">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)*類型可讓開發人員擴充以便在往返過程中每個語彙基元的其他資料的防 XSRF 系統行為。</span><span class="sxs-lookup"><span data-stu-id="5a574-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="5a574-259">*GetAdditionalData*每次呼叫方法會產生欄位語彙基元，並傳回值內嵌在產生的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="5a574-260">實作者可能從這個方法會傳回時間戳記、 nonce 或任何其他值，她希望。</span><span class="sxs-lookup"><span data-stu-id="5a574-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="5a574-261">同樣地， *ValidateAdditionalData*每次呼叫方法來驗證欄位語彙基元時，並已內嵌在權杖中的 [詳細資料] 字串傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="5a574-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="5a574-262">驗證常式無法實作的逾時 （藉由檢查目前的時間針對建立語彙基元時，已儲存的時間）、 nonce 檢查常式，或任何其他所需的邏輯。</span><span class="sxs-lookup"><span data-stu-id="5a574-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="5a574-263">設計決策和安全性考量</span><span class="sxs-lookup"><span data-stu-id="5a574-263">Design decisions and security considerations</span></span>

<span data-ttu-id="5a574-264">安全性權杖所連結的工作階段和欄位 token，技術上時才需要嘗試保護 XSRF 攻擊匿名 / 未經驗證的使用者。</span><span class="sxs-lookup"><span data-stu-id="5a574-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="5a574-265">當使用者進行驗證時，可用來驗證權杖本身 （假定提交 cookie 的形式） 做為其中一個一半的同步處理程式 token 組。</span><span class="sxs-lookup"><span data-stu-id="5a574-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="5a574-266">不過，有效的情況下保護未驗證的使用者所叫用的登入頁面和防 XSRF 邏輯一律產生及驗證安全性權杖，即使已驗證的使用者所做更簡單。</span><span class="sxs-lookup"><span data-stu-id="5a574-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="5a574-267">它也提供一些額外的保護，攻擊者，以設定或猜測的工作階段權杖為了克服攻擊者的另一個障礙曾經危害欄位語彙基元。</span><span class="sxs-lookup"><span data-stu-id="5a574-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="5a574-268">單一定義域中裝載多個應用程式時，開發人員應謹慎小心。</span><span class="sxs-lookup"><span data-stu-id="5a574-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="5a574-269">比方說，即使*example1.cloudapp.net*和*example2.cloudapp.net*是不同的主控件下的所有主機之間沒有隱含的信任關係 *\*.cloudapp.net*網域。</span><span class="sxs-lookup"><span data-stu-id="5a574-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="5a574-270">這個隱含的信任關係[讓可能不受信任的主機會影響彼此的 cookie](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) （控管 AJAX 要求的相同原始原則不一定會套用至 HTTP cookie）。</span><span class="sxs-lookup"><span data-stu-id="5a574-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="5a574-271">ASP.NET Web 堆疊執行階段提供某些風險降低，因為即使惡意的子網域可將覆寫工作階段語彙基元會無法產生使用者的有效的欄位語彙基元欄位語彙基元中，內嵌使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="5a574-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="5a574-272">不過，這類環境中裝載時的內建的防 XSRF 常式仍無法防禦劫持或登入 XSRF。</span><span class="sxs-lookup"><span data-stu-id="5a574-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="5a574-273">防 XSRF 常式目前不要不防範[clickjacking](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="5a574-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="5a574-274">應用程式想要自行防禦 clickjacking 輕鬆這樣傳送 X 框架選項： sameorigin 所使用的每個回應的標頭。</span><span class="sxs-lookup"><span data-stu-id="5a574-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="5a574-275">此標頭支援所有新的瀏覽器。</span><span class="sxs-lookup"><span data-stu-id="5a574-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="5a574-276">如需詳細資訊，請參閱[IE 部落格](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL 部落格](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)，和[OWASP](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="5a574-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="5a574-277">ASP.NET Web 堆疊執行階段可能在某些未來的版本建立的 MVC 和網頁防 XSRF helper 會自動將此標頭，讓應用程式會自動施以保護，對這種攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="5a574-278">Web 開發人員應該繼續以確保其站台不會受到影響 XSS 攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="5a574-279">XSS 攻擊非常強大，而且成功利用也會中斷 ASP.NET Web 堆疊執行階段防禦 XSRF 攻擊。</span><span class="sxs-lookup"><span data-stu-id="5a574-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="5a574-280">通知</span><span class="sxs-lookup"><span data-stu-id="5a574-280">Acknowledgment</span></span>

<span data-ttu-id="5a574-281">[@LeviBroderick](https://twitter.com/LeviBroderick)撰寫者 ASP.NET 安全性驗證碼的大部分的這項資訊。</span><span class="sxs-lookup"><span data-stu-id="5a574-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
