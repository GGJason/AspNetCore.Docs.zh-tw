---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: 全域錯誤處理中 ASP.NET Web API 2 |Microsoft 文件
author: davidmatson
description: ''
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: c593c56ba3d0ee8ebf6dc425408d2c3b91c83f93
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/24/2018
ms.locfileid: "28042582"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="55090-102">全域錯誤處理中 ASP.NET Web API 2</span><span class="sxs-lookup"><span data-stu-id="55090-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="55090-103">由[David Matson](https://github.com/davidmatson)， [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="55090-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

<span data-ttu-id="55090-104">現今記錄或全域處理錯誤的 Web API 中沒有簡單的方式。</span><span class="sxs-lookup"><span data-stu-id="55090-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="55090-105">可以透過處理一些未處理的例外狀況[例外狀況篩選條件](exception-handling.md)，但無法處理的例外狀況篩選條件的案例數目。</span><span class="sxs-lookup"><span data-stu-id="55090-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="55090-106">例如: </span><span class="sxs-lookup"><span data-stu-id="55090-106">For example:</span></span>

1. <span data-ttu-id="55090-107">從控制器建構函式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="55090-108">從訊息處理常式擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="55090-109">在路由期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="55090-110">回應內容序列化期間擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="55090-111">我們想要提供簡單且一致的方式，來記錄並處理 （如果可能的話） 這些例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="55090-112">有兩個主要的情況下處理例外狀況，我們就能傳送錯誤回應，並我們可以在其中執行該案例會記錄例外狀況的情況。</span><span class="sxs-lookup"><span data-stu-id="55090-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="55090-113">後者的情況下一個範例是當中間串流處理回應的內容; 擲回例外狀況在此情況下它是太晚傳送新的回應訊息，因為狀態碼、 標頭和部分內容已經透過網路，因此我們只是中止連接。</span><span class="sxs-lookup"><span data-stu-id="55090-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="55090-114">即使無法處理此例外狀況，以產生新的回應訊息，我們仍然支援記錄例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="55090-115">在我們可以在此偵測到錯誤的情況下，我們可以傳回適當的錯誤回應，如下列所示：</span><span class="sxs-lookup"><span data-stu-id="55090-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="55090-116">現有的選項</span><span class="sxs-lookup"><span data-stu-id="55090-116">Existing Options</span></span>

<span data-ttu-id="55090-117">除了[例外狀況篩選條件](exception-handling.md)，[訊息處理常式](../advanced/http-message-handlers.md)可以立即用來觀察所有 500 層級回應，但這些回應所引發的動作是很困難，他們缺乏原始錯誤的相關內容。</span><span class="sxs-lookup"><span data-stu-id="55090-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="55090-118">訊息處理常式也有一些相同的限制相關的情況下，它們能夠處理的例外狀況篩選條件。雖然 Web API 有擷取錯誤狀況的追蹤基礎結構追蹤基礎結構供診斷之用和未設計或適合在生產環境中執行。</span><span class="sxs-lookup"><span data-stu-id="55090-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="55090-119">全域例外狀況處理和記錄應該可以在實際執行期間執行，並插入到現有的監視解決方案服務 (例如， [ELMAH](https://code.google.com/p/elmah/) )。</span><span class="sxs-lookup"><span data-stu-id="55090-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="55090-120">解決方案概觀</span><span class="sxs-lookup"><span data-stu-id="55090-120">Solution Overview</span></span>

 <span data-ttu-id="55090-121">我們提供兩個新的使用者可取代服務， [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)和 IExceptionHandler，記錄並處理未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="55090-122">服務是非常類似，但有兩個主要差異：</span><span class="sxs-lookup"><span data-stu-id="55090-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="55090-123">我們支援註冊多個例外狀況記錄器，但只有單一例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="55090-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="55090-124">例外狀況記錄器一律取得呼叫，即使我們即將中止連接。</span><span class="sxs-lookup"><span data-stu-id="55090-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="55090-125">只有當我們仍然可以選擇要傳送的回應訊息時，取得呼叫例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="55090-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="55090-126">這兩項服務提供存取權包含來自例外狀況已偵測到，點的相關資訊的例外狀況內容特別[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)、 [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)，則會擲回例外狀況和例外狀況來源 （下面的詳細資料）。</span><span class="sxs-lookup"><span data-stu-id="55090-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="55090-127">設計原則</span><span class="sxs-lookup"><span data-stu-id="55090-127">Design Principles</span></span>

1. <span data-ttu-id="55090-128">**沒有重大變更**因為在次要版本中，其中一個重要影響方案的條件約束是，不會有任何重大變更，請輸入合約或行為，要加入這項功能。</span><span class="sxs-lookup"><span data-stu-id="55090-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="55090-129">我們想要根據現有開啟 500 個回應例外狀況的 catch 區塊完成某些清除並非這個條件約束。</span><span class="sxs-lookup"><span data-stu-id="55090-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="55090-130">此額外清除是我們可能會考慮針對後續的主要版本。</span><span class="sxs-lookup"><span data-stu-id="55090-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="55090-131">如果這是重要請投票上在[ASP.NET Web API 使用者語音](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)。</span><span class="sxs-lookup"><span data-stu-id="55090-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="55090-132">**維護與 Web API 的一致性建構**Web API 的篩選器管線是套用在特定的動作、 控制器專用或全域範圍的邏輯的彈性處理跨碼橫切入顧慮的好方法。</span><span class="sxs-lookup"><span data-stu-id="55090-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="55090-133">篩選條件，包括例外狀況篩選條件，一定要有動作和控制器內容，即使是在全域範圍中註冊。</span><span class="sxs-lookup"><span data-stu-id="55090-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="55090-134">篩選中，合約意義，但這不表示例外狀況篩選條件，即使全域範圍的項目，並不適合用來處理其中任何動作或控制器內容的情況下，例如例外狀況訊息處理常式，從某些例外狀況存在。</span><span class="sxs-lookup"><span data-stu-id="55090-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="55090-135">如果我們想要使用的例外狀況處理篩選條件所提供之彈性範圍，我們仍需要例外狀況篩選條件。</span><span class="sxs-lookup"><span data-stu-id="55090-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="55090-136">但是，如果我們需要處理例外狀況的控制器內容之外，我們也需要不同的建構 （項目不含控制器內容和動作內容的條件約束） 的完整全域錯誤處理。</span><span class="sxs-lookup"><span data-stu-id="55090-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="55090-137">使用時機</span><span class="sxs-lookup"><span data-stu-id="55090-137">When to Use</span></span>

- <span data-ttu-id="55090-138">例外狀況記錄器是解決方案，可查看所有 Web 應用程式開發介面攔截到的未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="55090-139">例外狀況處理常式會攔截之 Web API 的未處理例外狀況的所有可能回應，自訂方案。</span><span class="sxs-lookup"><span data-stu-id="55090-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="55090-140">例外狀況篩選條件是最簡單的解決方案，以處理特定動作或控制器相關的子集未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="55090-141">服務詳細資料</span><span class="sxs-lookup"><span data-stu-id="55090-141">Service Details</span></span>

 <span data-ttu-id="55090-142">例外狀況記錄器和處理常式服務介面是簡單的非同步方法都會個別的內容：</span><span class="sxs-lookup"><span data-stu-id="55090-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="55090-143">我們也會提供針對這兩種介面的基底類別。</span><span class="sxs-lookup"><span data-stu-id="55090-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="55090-144">覆寫核心 （同步或非同步） 方法是所有記錄，或在建議處理所需的時間。</span><span class="sxs-lookup"><span data-stu-id="55090-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="55090-145">如需記錄，`ExceptionLogger`基底類別可確保，核心記錄方法只能呼叫一次針對每個例外狀況 （即使稍後會傳播進一步呼叫堆疊和攔截到一次）。</span><span class="sxs-lookup"><span data-stu-id="55090-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="55090-146">`ExceptionHandler`基底類別會呼叫處理方法，只會針對上方的呼叫堆疊，並忽略舊版巢狀例外狀況的 catch 區塊的核心。</span><span class="sxs-lookup"><span data-stu-id="55090-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="55090-147">（這些基底類別的簡化的版本是在下列附錄中）。同時`IExceptionLogger`和`IExceptionHandler`接收透過例外狀況的相關資訊`ExceptionContext`。</span><span class="sxs-lookup"><span data-stu-id="55090-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="55090-148">時，架構會呼叫例外狀況記錄器或例外狀況處理常式，它一律會提供`Exception`和`Request`。</span><span class="sxs-lookup"><span data-stu-id="55090-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="55090-149">除了單元測試，可能會也永遠提供`RequestContext`。</span><span class="sxs-lookup"><span data-stu-id="55090-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="55090-150">它很少會提供`ControllerContext`和`ActionContext`（只有在呼叫 catch 區塊中的例外狀況篩選條件）。</span><span class="sxs-lookup"><span data-stu-id="55090-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="55090-151">它很少會提供`Response`（只在特定 IIS 情況下，當中間嘗試寫入回應）。</span><span class="sxs-lookup"><span data-stu-id="55090-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="55090-152">請注意，其中部分屬性可能是因為`null`檢查取用者負責決定是否`null`之前存取例外狀況類別的成員。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="55090-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="55090-153">這字串，表示哪些 catch 區塊所看到的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="55090-154">Catch 區塊字串如下所示：</span><span class="sxs-lookup"><span data-stu-id="55090-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="55090-155">HttpServer （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="55090-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="55090-156">HttpControllerDispatcher （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="55090-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="55090-157">HttpBatchHandler （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="55090-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="55090-158">IExceptionFilter （ApiController 的處理的例外狀況篩選條件中管線 ExecuteAsync）</span><span class="sxs-lookup"><span data-stu-id="55090-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="55090-159">OWIN 主機：</span><span class="sxs-lookup"><span data-stu-id="55090-159">OWIN host:</span></span>

    - <span data-ttu-id="55090-160">HttpMessageHandlerAdapter.BufferResponseContentAsync （緩衝的輸出）</span><span class="sxs-lookup"><span data-stu-id="55090-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="55090-161">HttpMessageHandlerAdapter.CopyResponseContentAsync （適用於資料流輸出）</span><span class="sxs-lookup"><span data-stu-id="55090-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="55090-162">Web 主機：</span><span class="sxs-lookup"><span data-stu-id="55090-162">Web host:</span></span>

    - <span data-ttu-id="55090-163">HttpControllerHandler.WriteBufferedResponseContentAsync （緩衝的輸出）</span><span class="sxs-lookup"><span data-stu-id="55090-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="55090-164">HttpControllerHandler.WriteStreamedResponseContentAsync （適用於資料流輸出）</span><span class="sxs-lookup"><span data-stu-id="55090-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="55090-165">HttpControllerHandler.WriteErrorResponseContentAsync （適用於在緩衝的輸出模式下的錯誤復原的失敗）</span><span class="sxs-lookup"><span data-stu-id="55090-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="55090-166">也可以透過靜態唯讀屬性的 catch 區塊的字串清單。</span><span class="sxs-lookup"><span data-stu-id="55090-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="55090-167">（核心 catch 區塊字串位於靜態 ExceptionCatchBlocks; 其餘部分會顯示一個靜態類別上每個 OWIN 和 web 主機）。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="55090-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="55090-168">可協助遵循建議的模式處理例外狀況只能在呼叫堆疊的頂端。</span><span class="sxs-lookup"><span data-stu-id="55090-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="55090-169">而不是開啟隨處巢狀的 catch 區塊，就會發生 500 個回應例外狀況，例外狀況處理常式可以讓例外狀況傳播直到它們即將主控件無法看到。</span><span class="sxs-lookup"><span data-stu-id="55090-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="55090-170">除了`ExceptionContext`，記錄器取得更多的某項資訊透過完整`ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="55090-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="55090-171">第二個屬性， `CanBeHandled`，允許以識別無法處理的例外狀況記錄器。</span><span class="sxs-lookup"><span data-stu-id="55090-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="55090-172">當連接即將中止和可以傳送任何新的回應訊息，記錄器就會呼叫但此處理常式會***不***呼叫，而且記錄器可以識別此案例中的從這個屬性。</span><span class="sxs-lookup"><span data-stu-id="55090-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="55090-173">在進行其他`ExceptionContext`，處理常式會取得一個屬性可以設定完整`ExceptionHandlerContext`處理此例外狀況：</span><span class="sxs-lookup"><span data-stu-id="55090-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="55090-174">例外狀況處理常式會指出它已設定處理例外狀況`Result`的動作結果的屬性 (例如， [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)， [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)， [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)，或自訂的結果)。</span><span class="sxs-lookup"><span data-stu-id="55090-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="55090-175">如果`Result`屬性為 null、 例外狀況未處理，而且會重新擲回原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="55090-176">對於例外狀況呼叫堆疊的頂端，我們採用額外的步驟，以確保應用程式開發介面呼叫的適當回應。</span><span class="sxs-lookup"><span data-stu-id="55090-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="55090-177">如果例外狀況會傳播到主機，呼叫端會看到的黃色死亡畫面，或某個其他主機提供回應通常是 HTML，而且通常不適當的 API 錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="55090-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="55090-178">在這些情況下，不是 null，而且只有自訂例外狀況處理常式明確設定出結果開始回`null`（未處理的） 將例外狀況傳播到主機。</span><span class="sxs-lookup"><span data-stu-id="55090-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="55090-179">設定`Result`至`null`在這類情況下可適用於兩個案例：</span><span class="sxs-lookup"><span data-stu-id="55090-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="55090-180">OWIN 裝載 Web 應用程式開發介面使用自訂的例外狀況處理登錄之前/外部 Web API 的中介軟體。</span><span class="sxs-lookup"><span data-stu-id="55090-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="55090-181">本機偵錯透過瀏覽器，其中的黃色死亡畫面是實際上很有幫助回應未處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="55090-182">例外狀況記錄器和例外狀況處理常式中，我們不執行任何動作來復原如果記錄器或處理常式本身會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55090-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="55090-183">（不讓例外狀況傳播，請保留此頁面底部的意見反應，如果您有更好的方法）。例外狀況記錄器和處理常式的合約是它們不應該讓例外狀況傳播至其呼叫端;否則，例外狀況將只會傳播，通常到主機導致 HTML 錯誤 （例如 ASP。網路的黃色螢幕） 傳送回用戶端 （這通常不會預期 JSON 或 XML 的應用程式開發介面呼叫端的慣用的選項）。</span><span class="sxs-lookup"><span data-stu-id="55090-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="55090-184">範例</span><span class="sxs-lookup"><span data-stu-id="55090-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="55090-185">追蹤例外狀況記錄器</span><span class="sxs-lookup"><span data-stu-id="55090-185">Tracing Exception Logger</span></span>

<span data-ttu-id="55090-186">例外狀況，將資料傳送至設定的追蹤來源 （包括 Visual Studio 中的 [偵錯輸出] 視窗） 如下的例外狀況記錄器。</span><span class="sxs-lookup"><span data-stu-id="55090-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="55090-187">自訂錯誤訊息的例外狀況處理常式</span><span class="sxs-lookup"><span data-stu-id="55090-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="55090-188">下列會產生用戶端，包括電子郵件地址連絡支援人員的自訂錯誤回應。</span><span class="sxs-lookup"><span data-stu-id="55090-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="55090-189">註冊例外狀況篩選條件</span><span class="sxs-lookup"><span data-stu-id="55090-189">Registering Exception Filters</span></span>

<span data-ttu-id="55090-190">如果您使用 「 ASP.NET MVC 4 Web 應用程式 」 專案範本來建立專案時，將 Web API 組態程式碼內`WebApiConfig`類別中*啟動應用程式/（_s)* 資料夾：</span><span class="sxs-lookup"><span data-stu-id="55090-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="55090-191">附錄： 基底類別的詳細資料</span><span class="sxs-lookup"><span data-stu-id="55090-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
